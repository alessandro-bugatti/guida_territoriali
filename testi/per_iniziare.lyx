#LyX 2.2 created this file. For more info see http://www.lyx.org/
\lyxformat 508
\begin_document
\begin_header
\save_transient_properties true
\origin unavailable
\textclass book
\begin_preamble
\date{}
\end_preamble
\use_default_options false
\master guida.lyx
\maintain_unincluded_children true
\language italian
\language_package default
\inputencoding auto
\fontencoding global
\font_roman "palatino" "default"
\font_sans "helvet" "default"
\font_typewriter "courier" "default"
\font_math "auto" "auto"
\font_default_family default
\use_non_tex_fonts false
\font_sc false
\font_osf false
\font_sf_scale 100 100
\font_tt_scale 100 100
\graphics default
\default_output_format default
\output_sync 0
\bibtex_command default
\index_command default
\paperfontsize default
\spacing single
\use_hyperref false
\papersize a4paper
\use_geometry true
\use_package amsmath 1
\use_package amssymb 1
\use_package cancel 1
\use_package esint 1
\use_package mathdots 1
\use_package mathtools 1
\use_package mhchem 1
\use_package stackrel 1
\use_package stmaryrd 1
\use_package undertilde 1
\cite_engine basic
\cite_engine_type default
\biblio_style plain
\use_bibtopic false
\use_indices false
\paperorientation portrait
\suppress_date false
\justification true
\use_refstyle 0
\index Indice
\shortcut idx
\color #008000
\end_index
\leftmargin 3cm
\topmargin 3cm
\rightmargin 3cm
\bottommargin 3cm
\secnumdepth 3
\tocdepth 3
\paragraph_separation indent
\paragraph_indentation default
\quotes_language english
\papercolumns 1
\papersides 1
\paperpagestyle default
\tracking_changes false
\output_changes false
\html_math_output 0
\html_css_as_file 0
\html_be_strict false
\end_header

\begin_body

\begin_layout Chapter
\begin_inset CommandInset label
LatexCommand label
name "cha:Per-iniziare"

\end_inset

Per iniziare
\end_layout

\begin_layout Quotation

\emph on
\begin_inset Quotes eld
\end_inset

Non fatevi prendere dal panico.
\begin_inset Quotes erd
\end_inset


\end_layout

\begin_layout Quotation
\align right

\shape italic
Douglas Adams
\shape default
, Guida galattica per autostoppisti.
\end_layout

\begin_layout Standard
La prima cosa necessaria per affrontare una gara è conoscere la struttura
 dei problemi proposti, che è abbastanza costante a tutti i livelli e tra
 tutte le gare online.
 Come esempio vediamo un testo delle territoriali, precisamente il problema
 
\emph on
nimbus
\emph default
 delle territoriali 2007, mostrato 
\begin_inset CommandInset ref
LatexCommand vpageref
reference "subsec:Giri-sulla-Scopa"

\end_inset

.
 Guardiamo quali sono gli elementi che ne contraddistinguono la struttura
 e il loro significato:
\end_layout

\begin_layout Itemize

\series bold
Titolo
\series default
: nella prima riga c'è un titolo lungo (Giri sulla scopa Nimbus3000) e uno
 breve (nimbus).
 Il titolo lungo serve solo per 
\begin_inset Quotes eld
\end_inset

folklore
\begin_inset Quotes erd
\end_inset

, in modo da dare un indizio della storia che seguirà, mentre quello breve
 è usato per dare il nome al codice sorgente della soluzione che dovremo
 sottoporre al correttore (in questo caso, supponendo di scrivere il codice
 in C++, il file si chiamerà nimbus.cpp)
\end_layout

\begin_layout Itemize

\series bold
Difficoltà
\series default
: l'indicatore della difficoltà ha un duplice scopo.
 Da una parte permette a chi sta svolgendo la prova di capire quale esercizio
 è più semplice e orientarsi di conseguenza (ad esempio partendo prima dalla
 soluzione dell'esercizio più semplice), dall'altra è il coefficiente che
 viene utilizzato nel meccanismo di valutazione mostrato in figura 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:Schema-di-valutazione"

\end_inset

, quindi gli esercizi con difficoltà più alta danno un punteggio maggiore,
 se risolti correttamente.
 Pur essendo un parametro oggettivo, che quindi rispecchia piuttosto esattamente
 la difficoltà di ogni problema, può essere che soggettivamente la valutazione
 di ogni singolo problema possa essere diversa.
 In questo caso viene posto anche un tempo limite di esecuzione, cioè il
 tempo massimo entro il quale il programma sottoposto deve dare una risposta
 al caso di test da risolvere, il cui scopo verrà meglio spiegato nel capitolo
 
\begin_inset CommandInset ref
LatexCommand ref
reference "cha:Complessità-computazionale"

\end_inset


\end_layout

\begin_layout Itemize

\series bold
Descrizione del problema
\series default
: tutti i problemi, a qualsiasi livello, vengono presentati attraverso una
 
\begin_inset Quotes eld
\end_inset

storiella
\begin_inset Quotes erd
\end_inset

 di fantasia, che spiega quale tipo di problema bisogna risolvere attraverso
 una prosa in generale leggera e di facile comprensione.
 Lo scopo di questa spiegazione è quello di chiarire, con un linguaggio
 il più semplice e chiaro possibile, qual è lo scopo dell'algoritmo che
 bisogna progettare.
 Pur con questi obbiettivi non sempre lo scopo viene raggiunto pienamente,
 quindi anche dopo averla letta possono rimanere dei dubbi sulla comprensione
 esatta del testo, cosa che è fondamentale per poter avere almeno la possibilità
 di arrivare alla soluzione corretta del problema (è ovvio che se non si
 è capito il testo sarà impossibile arrivare a una soluzione corretta).
 Per evitare questo problema si vedrà poi che vengono aggiunti ulteriori
 
\begin_inset Quotes eld
\end_inset

indizi
\begin_inset Quotes erd
\end_inset

.
\end_layout

\begin_layout Itemize

\series bold
Dati di input
\series default
: come già detto la valutazione avverrà dando in pasto al programma dei
 casi di test che servono a rappresentare un'istanza specifica del problema
 ed è quindi necessario specificare esattamente cosa dovrà aspettarsi il
 vostro programma, per permettere al programmatore di acquisire correttamente
 i dati da elaborare.
 Questo punto e quello successivo verranno trattati in modo approfondito
 nel paragrafo 
\begin_inset CommandInset ref
LatexCommand ref
reference "sec:Input/output"

\end_inset

.
\end_layout

\begin_layout Itemize

\series bold
Dati di output
\series default
: anche qui, sempre per le considerazioni espresse al punto precedente,
 viene spiegato l'esatto formato della risposta che dovrà fornire il programma.
\end_layout

\begin_layout Itemize

\series bold
Esempi di input/output
\series default
: questa sezione è molto utile per verificare se la descrizione del problema
 è stata compresa correttamente o, nel caso che non la si sia compresa,
 per arrivare a una comprensione esatta del problema.
 Attraverso una tabella vengono fornite una o più istanze (in questo caso
 una sola) di casi di test del problema, tramite i casi di input (nella
 colonna input.txt) e le relative soluzioni (nella colonna output.txt).
\end_layout

\begin_layout Itemize

\series bold
Nota/e
\series default
: quest'ultima sezione contiene delle note di vario genere relative o al
 problema o ai meccanismi di attribuzione del punteggio (come in questo
 caso).
 A volte non è presente.
\end_layout

\begin_layout Standard
\begin_inset Box Framed
position "t"
hor_pos "c"
has_inner_box 0
inner_pos "t"
use_parbox 0
use_makebox 0
width "100col%"
special "none"
height "1in"
height_special "totalheight"
thickness "0.4pt"
separation "3pt"
shadowsize "4pt"
framecolor "black"
backgroundcolor "none"
status collapsed

\begin_layout Subsection*
\begin_inset CommandInset label
LatexCommand label
name "subsec:Giri-sulla-Scopa"

\end_inset

Giri sulla Scopa Nimbus3000 (nimbus) 
\end_layout

\begin_layout Subsubsection*
Difficoltà D = 2 (tempo limite 1 sec).
 
\end_layout

\begin_layout Subsubsection*
Descrizione del problema
\end_layout

\begin_layout Plain Layout
Al celebre maghetto Harry Potter è stata regalata una scopa volante modello
 Nimbus3000 e tutti i suoi compagni del Grifondoro gli chiedono di poterla
 provare.
 Il buon Harry ha promesso che nei giorni a venire soddisferà le richieste
 di tutti, ma ogni ragazzo è impaziente e vuole provare la scopa il giorno
 stesso.
 Ognuno propone ad Harry un intervallo di tempo della giornata durante il
 quale, essendo libero da lezioni di magia, può fare un giro sulla scopa,
 e per convincerlo gli offre una fantastica caramella Tuttigusti+1.
 Tenendo presente che una sola persona alla volta può salire sulla Nimbus3000
 in ogni istante di tempo, Harry decide di soddisfare, tra tutte le richieste
 dei ragazzi, quelle che gli procureranno la massima quantità di caramelle
 (che poi spartirà coi suoi amici Ron e Hermione).
 Aiutalo a trovare la migliore soluzione possibile.
 
\end_layout

\begin_layout Subsubsection*
Dati di input
\end_layout

\begin_layout Plain Layout
Il file input.txt contiene nella prima riga un intero positivo N, che indica
 il numero di richieste, che sono numerate da 1 a N.
 Ognuna delle successive N righe contiene una coppia di interi.
 Ciascuna di tali righe contiene una coppia di interi positivi A e B, separati
 da uno spazio, a rappresentare la richiesta di poter utilizzare la scopa
 dall'istante iniziale A fino all'istante finale B, in cambio di una caramella
 (dove A < B).
 A tal fine, il tempo è diviso in istanti discreti numerati a partire da
 1 in poi.
 
\end_layout

\begin_layout Subsubsection*
Dati di output
\end_layout

\begin_layout Plain Layout
Il file output.txt è composto da una riga contenente un solo intero, che
 rappresenta il massimo numero di caramelle che Harry può ottenere.
 Assunzioni
\end_layout

\begin_layout Plain Layout
1 < N < 1000 Gli interi nelle N coppie sono distinti l'uno dall'altro (non
 esistono due interi uguali, anche in coppie diverse).
\end_layout

\begin_layout Subsubsection*
Esempi di input/output
\end_layout

\begin_layout Plain Layout
\begin_inset Tabular
<lyxtabular version="3" rows="2" columns="2">
<features tabularvalignment="middle">
<column alignment="left" valignment="bottom" width="1in">
<column alignment="left" valignment="top">
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
File input.txt
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
File output.txt
\end_layout

\end_inset
</cell>
</row>
<row topspace="default" bottomspace="default" interlinespace="default">
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
5
\end_layout

\begin_layout Plain Layout
1 5
\end_layout

\begin_layout Plain Layout
3 7
\end_layout

\begin_layout Plain Layout
9 11
\end_layout

\begin_layout Plain Layout
10 12 
\end_layout

\begin_layout Plain Layout
6 13
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
2
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Subsubsection*
Nota/e
\end_layout

\begin_layout Plain Layout
Un programma che restituisce sempre lo stesso valore, indipendentemente
 dai dati in input.txt, non totalizza alcun punteggio rilevante.
\end_layout

\end_inset


\end_layout

\begin_layout Section
\begin_inset CommandInset label
LatexCommand label
name "sec:Nuova-mod_sottoposizione"

\end_inset

Nuova modalità di sottomissione (a partire dalle Territoriali 2018)
\end_layout

\begin_layout Standard
In questo paragrafo viene presentata la nuova modalità di sottoposizione
 delle soluzioni, che diventerà ufficiale dalle territoriali 2018.
\end_layout

\begin_layout Standard
Una premessa: perchè si è scelta questa nuova modalità? Una delle critiche
 più frequenti che venivano fatte dai referenti e dagli studenti rispetto
 alla modalità di sottoposizione era quella di non avere nessun tipo di
 feedback rispetto ai codici sottoposti, se non che l'upload avesse funzionato
 e che i nomi dei file fossero quelli giusti.
 Questo in qualche caso portava alla non qualificazione a causa di errori
 banali (vedi ad esempio 
\begin_inset CommandInset ref
LatexCommand vref
reference "attenzione-agli-errori"

\end_inset

 ), che probabilmente sarebbero stati corretti se lo studente avesse avuto
 accesso a qualche tipo di feedback, come succede ai Nazionali.
 Purtroppo però non era possibile utilizzare il correttore delle selezioni
 Nazionali, per due ordini di motivi:
\end_layout

\begin_layout Itemize
utilizzo da remoto su un server centrale: difficoltà per le scuole a isolare
 le postazioni degli atleti da Internet e, cosa peggiore, nel caso di non
 funzionamento del collegamento a Internet il giorno della prova nella scuola
 sede di gara, la gara non si sarebbe potuta disputare
\end_layout

\begin_layout Itemize
utilizzo in locale su un server della scuola: pur non essendo particolarmente
 complesso, il software CMS non è semplicissimo da usare nella parte di
 gestione/amministrazione, quindi poteva comportare dei problemi durante
 la gara se si fosse dovuto intervenire.
 Inoltre la struttura di correzione prevede comunque un certo carico di
 lavoro sul server: se la macchina o il network di macchine che fungono
 da correttore sono abbastanza potenti non ci sono problemi perchè è progettato
 per scalare bene, ma dovendo girare su una macchina virtuale nelle sedi
 territoriali, avrebbe presumibilmente creato problemi.
 Fa ricordato infatti che i limiti sul tempo di esecuzione dei problemi
 del livello territoriale sono fissati a 5 minuti, quindi le soluzioni non
 corrette che al proprio interno creassero dei cicli infiniti, andrebbero
 a utilizzare le risorse del server in maniera molto pesante.
 
\end_layout

\begin_layout Standard
Il team di supporto alle Olimpiadi ha così pensato di risolvere i problemi
 creando un software che utilizzasse un meccanismo già presente in altre
 competizioni, ad esempio 
\begin_inset CommandInset href
LatexCommand href
name "Google Code Jam"
target "https://code.google.com/codejam/"

\end_inset

.
 
\end_layout

\begin_layout Standard
L'idea di base è quella di dare allo studente un file di input contenente
 tutti i test case e permettergli di creare, tramite il proprio programma,
 un file di output con tutte le risposte.
 
\end_layout

\begin_layout Standard
Il file di input che l'utente dovrà scaricare sarà fatto ad esempio in questo
 modo e dovrà produrre un file di output strutturalmente simile a quello
 mostrato:
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement h
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename ../materiali/per_iniziare/nuova_sottomissione.eps
	scale 50

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Nuova modalità di sottoposizione
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Successivamente il file di output verrà caricato sul server che risponderà
 con il numero di punti ottenuti, indicando anche quali test case hanno
 avuto una risposta corretta e quali no
\begin_inset Foot
status open

\begin_layout Plain Layout
Al momento della scrittura di questo paragrafo (19/02/2018) esiste una piattafor
ma di prova all'indirizzo 
\begin_inset CommandInset href
LatexCommand href
name "https://territoriali.olinfo.it/"
target "https://territoriali.olinfo.it/"

\end_inset

 su cui si possono fare dei test relativi ai problemi dei territoriali 2017.
\end_layout

\end_inset

.
 
\end_layout

\begin_layout Standard
Nel caso di risposte non corrette o solo parzialmente corrette, lo studente
 avrà quindi la possibilità di individuare gli errori attraverso l'analisi
 dei casi che non hanno dato una risposta corretta e correggere il proprio
 programma.
 Una volta arrivato a una soluzione soddisfacente, lo studente chiederà
 al sistema un altro file di input, con una serie di test case differenti
 dai precedenti e lo risolverà con il nuovo programma, spedendo il nuovo
 file di output, iterando il processo fino a che arriverà alla soluzione
 del problema (o comunque al massimo di punti che riesce a ottenere).
\end_layout

\begin_layout Standard
In questo modo è possibile fornire allo studente un feedback preciso su
 quanto fatto e allo stesso tempo fornire alle varie sedi territoriali una
 macchina virtuale su cui fare girare il server, che a questo punto non
 ha più problemi di carico, dovendosi sostanzialmente limitare a creare
 e confrontare file, senza dover far eseguire le soluzioni dei concorrenti
 in una sandbox locale.
\end_layout

\begin_layout Standard
Questa nuova modalità prevede sostanzialmente due modi per poter ottenere
 delle soluzioni da sottoporre:
\end_layout

\begin_layout Enumerate
il programma utilizza l'input/output da file, come nella precedente modalità
\end_layout

\begin_layout Enumerate
il programma sfrutta la ridirezione di I/O messa a disposizione dai terminali
 dei sistemi operativi (anche in quello di Windows, che notoriamente ha
 delle funzionalità molto limitate).
\end_layout

\begin_layout Subsection
Lettura/scrittura da codice
\end_layout

\begin_layout Standard
Come nella modalità in uso fino al 2017, il programma si occupa di aprire
 il file 
\emph on
input.txt
\emph default
, che è quello che il sistema permette di scaricare.
 Questo file, a differenza della modalità precedente, contiene generalmente
 un primo intero T che rappresenta il numero di test case, dopodichè seguono
 i dati di input di ognuno dei singoli test case, come se i casi che una
 volta venivano dati su file separati fossero stati tutti accodati nello
 stesso file.
\end_layout

\begin_layout Standard
Per fare un esempio si faccia riferimento al testo del problema 
\begin_inset CommandInset ref
LatexCommand ref
reference "sec:Crittografia-LWF"

\end_inset

, di cui qua vengono riportati per brevità le definizioni degli input/output.
\end_layout

\begin_layout Standard
\begin_inset Box Framed
position "t"
hor_pos "c"
has_inner_box 0
inner_pos "t"
use_parbox 0
use_makebox 0
width "100col%"
special "none"
height "1in"
height_special "totalheight"
thickness "0.4pt"
separation "3pt"
shadowsize "4pt"
framecolor "black"
backgroundcolor "none"
status open

\begin_layout Subsubsection*
Dati di input
\end_layout

\begin_layout Plain Layout
La prima riga del file di input contiene un intero 
\series bold
T
\series default
, il numero di testcase.
 Le successive 
\series bold
T
\series default
 righe contengono un intero ciascuna: il valore intero 
\series bold
N
\series default
 del relativo testcase.
\end_layout

\begin_layout Subsubsection*
Dati di output
\end_layout

\begin_layout Plain Layout
Il file di output deve essere composto da 
\series bold
T
\series default
 righe, ciascuna delle quali contenente la dicitura 
\family typewriter
Case #x: y
\family default
 dove 
\family typewriter
x
\family default
 è il numero del testcase (a partire da 1) e 
\family typewriter
y
\family default
 è una sequenza di cifre binarie corrispondente al valore di N del testcase,
 che termina con '1'.
\end_layout

\begin_layout Subsubsection*
Esempi di input/output 
\end_layout

\begin_layout Plain Layout
\begin_inset space ~
\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Tabular
<lyxtabular version="3" rows="2" columns="2">
<features tabularvalignment="middle">
<column alignment="left" valignment="top" width="1.5in">
<column alignment="left" valignment="top" width="5cm">
<row>
<cell alignment="left" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
File input.txt
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
File output.txt
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
2
\end_layout

\begin_layout Plain Layout

\family typewriter
19
\end_layout

\begin_layout Plain Layout

\family typewriter
9
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
Case #1: 1011001 
\end_layout

\begin_layout Plain Layout

\family typewriter
Case #2: 11101
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Dovendo leggere un file di input definito nel modo precedente è necessario
 scrivere del codice simile al seguente:
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "basicstyle={\small\ttfamily},frame=lr,language={C++},numbers=left,showstringspaces=false,tabsize=4"
inline false
status open

\begin_layout Plain Layout

int main()
\end_layout

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

	int T, N;
\end_layout

\begin_layout Plain Layout

	ifstream in("input.txt");
\end_layout

\begin_layout Plain Layout

	ofstream out("output.txt");
\end_layout

\begin_layout Plain Layout

	in >> T;
\end_layout

\begin_layout Plain Layout

	for (int i = 0; i < T; i++)
\end_layout

\begin_layout Plain Layout

	{
\end_layout

\begin_layout Plain Layout

        //Esegue le elaborazioni richieste
\end_layout

\begin_layout Plain Layout

        out << "Case #" << i+1 << ": ";
\end_layout

\begin_layout Plain Layout

        out << "Risultati dell'algoritmo ..." << endl;
\end_layout

\begin_layout Plain Layout

    }
\end_layout

\begin_layout Plain Layout

	return 0;
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Come si può vedere la soluzione del problema si trova all'interno del ciclo
 
\emph on
for
\emph default
 e viene eseguita T volte su casi di input diversi contenuti all'interno
 del file 
\emph on
input.txt
\emph default
.
\end_layout

\begin_layout Subsection
Ridirezione dell'I/O
\end_layout

\begin_layout Standard
La seconda possibilità è quella di leggere/scrivere come se si lavorasse
 normalmente con 
\emph on
scanf/printf
\emph default
 o 
\emph on
cin/cout
\emph default
 e passare il file utilizzando la ridirezione in questo modo:
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "language=bash,showstringspaces=false"
inline false
status open

\begin_layout Plain Layout

./mio_programma < input.txt > output.txt
\end_layout

\end_inset


\end_layout

\begin_layout Standard
I segni di minore e maggiore indicano rispettivamente che il file 
\emph on
input.txt
\emph default
 verrà utilizzato per fornire l'input e il file 
\emph on
output.txt
\emph default
 conterrà l'output.
 Facendo sempre riferimento all'esempio del paragrafo precedente, il codice
 che permette di creare il file che dopo dovrà essere sottoposto al server
 sarà simile al seguente:
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "basicstyle={\small\ttfamily},frame=lr,language={C++},numbers=left,showstringspaces=false,tabsize=4"
inline false
status open

\begin_layout Plain Layout

int main()
\end_layout

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

	int T, N;
\end_layout

\begin_layout Plain Layout

	cin >> T;
\end_layout

\begin_layout Plain Layout

	for (int i = 0; i < T; i++)
\end_layout

\begin_layout Plain Layout

	{
\end_layout

\begin_layout Plain Layout

        //Esegue le elaborazioni richieste
\end_layout

\begin_layout Plain Layout

        cout << "Case #" << i+1 << ": ";
\end_layout

\begin_layout Plain Layout

        cout << "Risultati dell'algoritmo ..." << endl;
\end_layout

\begin_layout Plain Layout

    }
\end_layout

\begin_layout Plain Layout

	return 0;
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Standard
Come si può notare la lettura/scrittura avviene attraverso i normali canali
 di I/O e tramite il comando indicato sopra viene creato il file di output
 da sottoporre.
 L'unica difficoltà può essere quella di sapere dove scrivere quel comando,
 per chi non fosse avvezzo all'utilizzo del terminale.
 Come prima cosa è necessario portarsi nella cartella dove è contenuto l'eseguib
ile, nell'esempio 
\family typewriter
mio_programma
\family default
, copiare nella stessa cartella il file di input e dopo aver eseguito il
 comando apparirà il file di output (se queste istruzioni risultassero incompren
sibili si consiglia di chiedere al proprio professore o utilizzare la prima
 modalità).
\end_layout

\begin_layout Section
Input/output su file (valido fino alle Territoriali 2017)
\begin_inset CommandInset label
LatexCommand label
name "sec:Input/output"

\end_inset


\end_layout

\begin_layout Standard
Sebbene dalle territoriali 2018 il meccanismo di sottomissione cambierà,
 questo paragrafo è stato mantenuto per giustificare il modo con cui sono
 gestiti input e output fino ai problemi del 2016
\begin_inset Foot
status collapsed

\begin_layout Plain Layout
I problemi del 2017 sono stati proposti in gara con la modalità 
\begin_inset Quotes eld
\end_inset

vecchia
\begin_inset Quotes erd
\end_inset

, ma su questa guida vengono risolti utilizzando la nuova modalità, per
 far vedere almeno un esempio concreto di come saranno i problemi dal 2018
 in poi.
 
\end_layout

\end_inset

, che altrimenti risulterebbe incomprensibile ai nuovi lettori.
 Viene lasciato il tempo presente nel testo perchè renderlo adeguato al
 fatto che è una modalità ormai passata avrebbe richiesto un lavoro che
 ritengo inutile.
\end_layout

\begin_layout Labeling
\labelwidthstring 00.00.0000

\family sans
\series bold
ATTENZIONE: rimane solo come riferimento 
\begin_inset Quotes eld
\end_inset

storico
\begin_inset Quotes erd
\end_inset

, adesso non è più così.
\end_layout

\begin_layout Standard
Il meccanismo di valutazione del correttore prevede che i programmi debbano
 leggere il proprio input da un file chiamato 
\emph on
input.txt
\emph default
 e debbano stampare il proprio output su un file chiamato 
\emph on
output.txt
\emph default

\begin_inset Foot
status collapsed

\begin_layout Plain Layout
In un futuro potrebbe essere tolto questo vincolo, permettendo la lettura
 direttamente da tastiera, come succede ad esempio nelle gare COCI, ma finchè
 ci sarà bisogna abituarsi a leggere/scrivere su file.
\end_layout

\end_inset

.
 Questa richiesta è molto rigida poiché siccome il correttore è a sua volta
 un programma, non può gestire errori formali di nessun tipo
\begin_inset Foot
status collapsed

\begin_layout Plain Layout
Un mio allievo un anno non si si è classificato ai nazionali perché nella
 sua soluzione cercava di aprire il file 
\emph on
i
\bar under
m
\bar default
put.txt
\emph default
 piuttosto che 
\emph on
input.txt, 
\emph default
quindi occorre porre attenzione a questi aspetti.
\end_layout

\end_inset

.
\end_layout

\begin_layout Standard
Si vedrà comunque come la scrittura/lettura da file abbia davvero poche
 differenze con i meccanismi normalmente utilizzati per leggere da tastiera
 e scrivere a video, anche perché nelle Olimpiadi viene usata solo una parte
 delle possibilità di accesso ai file.
\end_layout

\begin_layout Standard
L'I/O su file prevede sempre tre passi:
\end_layout

\begin_layout Enumerate
apertura del file
\end_layout

\begin_layout Enumerate
operazioni sul file
\end_layout

\begin_layout Enumerate
chiusura del file
\end_layout

\begin_layout Standard
Dovendo ad esempio leggere da un file di nome 
\emph on
input.txt
\emph default
 un unico numero intero, in C si farà in questo modo:
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "basicstyle={\small\ttfamily},frame=lr,language=C,numbers=left,showstringspaces=false,tabsize=4"
inline false
status open

\begin_layout Plain Layout

FILE *in; 				//puntatore alla struttura FILE
\end_layout

\begin_layout Plain Layout

int n;
\end_layout

\begin_layout Plain Layout

in = fopen("input.txt","r");//apertura del file
\end_layout

\begin_layout Plain Layout

fscanf(in,"%d",&n);		//operazione sul file
\end_layout

\begin_layout Plain Layout

fclose(in);				//chiusura del file
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Vediamo gli aspetti principali di questo breve listato:
\end_layout

\begin_layout Itemize
riga 1: ogni file aperto deve avere un 
\begin_inset Quotes eld
\end_inset

reference
\begin_inset Quotes erd
\end_inset

 che verrà usato nel resto del codice per riferirsi a quel file (nel caso
 del C questo sarà un puntatore a struttura, mentre nel caso del C++ sarà
 un oggetto di una classe standard)
\end_layout

\begin_layout Itemize
riga 3: l'apertura avviene attraverso la chiamata alla funzione 
\emph on
fopen
\emph default
, passandogli due parametri: il nome del file completo e la modalità di
 apertura, che nel caso di lettura sarà 
\emph on
r
\emph default
 (read), mentre per la scrittura sarà 
\emph on
w
\emph default
 (write).
 La funzione ritorna il 
\begin_inset Quotes eld
\end_inset

reference
\begin_inset Quotes erd
\end_inset

 che viene assegnato al parametro 
\emph on
in
\emph default
.
 A questo punto sarebbe buona norma di programmazione controllare se l'apertura
 del file è andata a buon fine, cosa che potrebbe non essere vera e che
 porterebbe in generale a comportamenti anomali del programma, ma nel caso
 di una gara si può omettere questo passaggio perché viene assicurato che
 il file è presente con il nome dichiarato
\end_layout

\begin_layout Itemize
riga 4: vengono effettuate una o più operazioni sul file, utilizzando le
 funzioni opportune.
 In questo esempio viene utilizzata la 
\emph on
fscanf
\emph default
, che ha una sintassi del tutto identica alla 
\emph on
scanf
\emph default
, a parte il primo parametro che è il 
\begin_inset Quotes eld
\end_inset

reference
\begin_inset Quotes erd
\end_inset

 acquisito all'apertura del file, per indicargli dove deve andare a leggere.
 Anche in questo caso non vengono fatti controlli perché viene garantito
 che quello che ci si aspetta di leggere sia presente davvero nel file.
\end_layout

\begin_layout Itemize
riga 5: viene chiuso il file.
 Questa operazione nelle Olimpiadi può anche essere omessa in quanto alla
 chiusura del programma comunque eventuali file aperti verranno chiusi correttam
ente.
\end_layout

\begin_layout Standard
Nella parte successiva del capitolo verranno mostrati alcuni esempi concreti
 di lettura/scrittura da file sia in C che in C++.
\end_layout

\begin_layout Subsection
Esempi di I/O 
\end_layout

\begin_layout Standard
Partiamo dal caso più semplice, che è forse anche il caso più comune di
 lettura nei problemi delle Olimpiadi (anche se con qualche variante), nel
 quale lo schema è quello di avere un numero intero che indica quanti altri
 numeri dovranno poi essere letti nel seguito del file.
 Supponiamo quindi che il problema sia quello di sommare una serie di numeri
 interi e che il file di input contenga come primo intero un valore N che
 indica quanti sono i numeri da sommare: nelle successive N righe
\begin_inset Foot
status collapsed

\begin_layout Plain Layout
A volte viene data una formulazione equivalente in cui si dice che gli N
 interi si trovano su una sola linea e sono separati dallo spazio: per quanto
 riguarda l'imput non c'è alcuna differenza, poichè la fscanf (o l'equivalente
 C++) interpreta sia gli spazi che gli a capo come separatori.
\end_layout

\end_inset

 ci saranno quindi gli N numeri che dovranno essere sommati per portare
 alla soluzione del problema.
 La lettura avverrebbe quindi in questo modo:
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "basicstyle={\small\ttfamily},frame=lr,language=C,showstringspaces=false,tabsize=4"
inline false
status open

\begin_layout Plain Layout

FILE *in; 				//puntatore alla struttura FILE
\end_layout

\begin_layout Plain Layout

int N, i, temp, somma = 0;
\end_layout

\begin_layout Plain Layout

in = fopen("input.txt","r");//apertura del file
\end_layout

\begin_layout Plain Layout

fscanf(in,"%d",&N);		//viene letto il primo numero intero
\end_layout

\begin_layout Plain Layout

for (i=0; i< N ; i++)//ciclo per leggere gli N numeri seguenti
\end_layout

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

	fscanf(in,"%d",&temp);	
\end_layout

\begin_layout Plain Layout

	somma += temp;
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Come si può vedere non ci sono molte differenze da un programma che legge
 i suoi dati da tastiera: ovviamente mancano quelle istruzioni di output
 che solitamente vengono messe per chiarire all'utente quali dati deve inserire,
 in quanto i dati vengono forniti dal correttore secondo quanto definito
 nel testo del problema.
 La scrittura è ancora più semplice, riferendosi allo stesso problema visto
 sopra verrebbe fatta in questo modo:
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "basicstyle={\small\ttfamily},frame=lr,language=C,showstringspaces=false,tabsize=4"
inline false
status open

\begin_layout Plain Layout

FILE *out; 					//puntatore alla struttura FILE
\end_layout

\begin_layout Plain Layout

out = fopen("output.txt","w");	//apertura del file
\end_layout

\begin_layout Plain Layout

fprintf(out,"%d
\backslash
n",somma);
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Anche in questo caso viene usata una funzione, la 
\emph on
fprintf
\emph default
, del tutto analoga per sintassi e comportamento alla 
\emph on
printf
\emph default
, a parte la presenza nel primo parametro del 
\begin_inset Quotes eld
\end_inset

reference
\begin_inset Quotes erd
\end_inset

 al file.
 
\series bold
Attenzione
\series default
: in gara è assolutamente necessario che le funzioni per l'output si limitino
 a stampare 
\series bold
\bar under
solo
\series default
\bar default
 quanto chiesto, esattamente nel modo richiesto; quindi ad esempio eventuali
 istruzioni di output ai fini di debug dovranno essere tolte dalla versione
 definitiva del programma.
\end_layout

\begin_layout Standard
Per concludere questo semplice esempio riscriviamo tutto il programma in
 C++, dove anche in questo caso vedremo che la differenza con la normale
 lettura/scrittura da tastiera/video è ancora minore.
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "basicstyle={\small\ttfamily},frame=lr,language={C++},showstringspaces=false,tabsize=4"
inline false
status open

\begin_layout Plain Layout

ifstream in("input.txt"); 	//oggetto per gestire l'input
\end_layout

\begin_layout Plain Layout

ofstream out("output.txt");	//oggetto per gestire l'output
\end_layout

\begin_layout Plain Layout

int N, i, temp, somma = 0;
\end_layout

\begin_layout Plain Layout

in >> N;		//viene letto il primo numero intero
\end_layout

\begin_layout Plain Layout

for (i=0; i< N ; i++) //ciclo per leggere gli N numeri seguenti
\end_layout

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

	in >> temp;	
\end_layout

\begin_layout Plain Layout

	somma += temp;
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

out << somma << endl;	//scrittura del risultato
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Un altro modo per aprire i file in C++, usando un costruttore diverso è
 il seguente
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "basicstyle={\small\ttfamily},frame=lr,language={C++},showstringspaces=false,tabsize=4"
inline false
status open

\begin_layout Plain Layout

fstream in("input.txt",ios::in); 	//oggetto per gestire l'input
\end_layout

\begin_layout Plain Layout

fstream out("output.txt",ios::out);	//oggetto per gestire l'output
\end_layout

\end_inset


\end_layout

\begin_layout Standard
dove si usa l'oggetto generico 
\emph on
fstream
\emph default
 e nel costruttore, tramite le costanti 
\emph on
ios::in
\emph default
 e 
\emph on
ios::out
\emph default
 si specifica se l'oggetto creato è in lettura o in scrittura.
\end_layout

\begin_layout Subsection
Errori comuni
\end_layout

\begin_layout Standard
Durante la gara, per esperienza diretta come organizzatore delle territoriali,
 vengono commessi degli errori banali che però hanno delle conseguenze fatali
 (in senso relativo, nessuno è mai morto a causa di questi errori).
\end_layout

\begin_layout Standard
Finora (anche se la situazione dovrebbe cambiare nei prossimi anni
\begin_inset Foot
status collapsed

\begin_layout Plain Layout
In effetti dal 2015 è cambiata e allo stato attuale (fine 2016) quasi tutte
 le sedi territoriali effettuano la gara su una macchina virtuale Linux
 Ubuntu.
 Ritengo comunque utile lasciare questa parte in quanto inizialmente molti
 ragazzi hanno Windows come piattaforma di allenamento.
 
\end_layout

\end_inset

) Windows nelle sue varie versioni è stata la piattaforma più utilizzata
 (spesso l'unica) a livello delle selezioni territoriali.
 Alcune sue caratteristiche possono condurre ai seguenti problemi:
\end_layout

\begin_layout Itemize
nelle installazioni normali Windows è configurato per non mostrare le estensioni
 dei file, quindi il file input.txt compare a video solo con il nome input
 e con la classica icona dei file di testo.
 Dal punto di vista del vostro programma però il file è sempre input.txt,
 il fatto che non si veda l'estensione è solo dovuto a una scelta di usabilità
 per non 
\begin_inset Quotes eld
\end_inset

disturbare
\begin_inset Quotes erd
\end_inset

 gli utenti con poca dimestichezza con il computer (il 90-95%).
 Siccome in gara è necessario creare un file input.txt per testare se il
 programma scritto funziona, il software che si usa di solito è il Blocco
 Note, che però ha un comportamento maligno, sempre a causa della scelta
 di cui sopra: nel momento di salvare il file se si sceglie come nome input.txt
 il Blocco Note aggiungerà di suo l'estensione .txt e il vero nome del file
 sarà quindi input.txt.txt.
 Questo farà si che il vostro programma fallirà nell'apertura del file perché
 il file input.txt non è presente; però guardando nella cartella si vedrà
 che c'è un file che si chiama input.txt (sempre per il discorso che l'estensione
 non viene mostrata) e quindi si inizierà a dare la colpa, nell'ordine,
 al computer di gara, all'ambiente di sviluppo, i più temerari anche al
 linguaggio di programmazione, mentre se sapete queste cose non dovreste
 avere problemi.
 Inoltre è sempre possibile usare direttamente l'ambiente di sviluppo per
 creare il file input.txt oppure abilitare la visualizzazione delle estensioni
 attraverso il menù Opzioni cartella che si trova in ogni cartella aperta
\end_layout

\begin_layout Itemize
sempre in Windows, i nomi dei file sono case-insensitive, quindi bisogna
 essere certi nel proprio codice sorgente di indicare i nomi dei file con
 tutte le lettere minuscole, perché se ad esempio si scrivesse Input.txt,
 il programma funzionerebbe se testato sotto Windows, ma fallirebbe se testato
 con Linux (nel quale i file system sono case-sensitive).
 Siccome dalle territoriali in poi e in tutte le gare online il correttore
 gira sotto Linux, è bene abituarsi a scrivere i nomi dei file in minuscolo
\end_layout

\begin_layout Itemize
il file input.txt che verrà creato per fare delle prove deve trovarsi in
 una posizione per cui il vostro programma lo riesca ad aprire, quindi non
 può essere messo dove capita, ma solo in alcuni posti.
 Siccome il correttore si aspetta che il file sia nella stessa cartella
 dell'eseguibile, il programma lo cerca nella cartella dove è in esecuzione:
 gli ambienti di sviluppo di gara in generale permettono anche di metterlo
 nella stessa cartella del codice sorgente, quindi vale la pena di fare
 un po' di prove per capire esattamente dove posizionarlo e evitare di scoprire
 durante la gara che il file non viene letto perché il programma non riesce
 a trovarlo
\end_layout

\begin_layout Subsection
Utilizzo di Linux
\end_layout

\begin_layout Standard
Dall'edizione 2014-2015 l'organizzazione nazionale ha invitato le sedi territori
ali che avevano la possibilità di farlo
\begin_inset Foot
status collapsed

\begin_layout Plain Layout
Va comunque verificato cosa verrà usato nella propria sede di gara, poichè
 l'utilizzo di Linux non è obbligatorio e alcune sedi potrebbero ancora
 utilizzare Windows.
 
\end_layout

\end_inset

 a proporre agli studenti il sistema operativo Linux, con la suite di compilazio
ne 
\emph on
gcc
\emph default
 e i normali strumenti di programmazione (CodeBlocks, Geany, Vim, ecc.),
 come piattaforma di gara.
 Per uniformità tra le varie sedi e nel tentativo di creare il minor disagio
 possibile agli organizzatori si è optato per utilizzare una macchina virtuale
 VirtualBox, basata sulla distribuzione Ubuntu.
\end_layout

\begin_layout Standard
Questa nuova modalità, almeno per quanto riguarda le selezioni territoriali,
 non ha un forte impatto sulla conduzione della gara, in quanto la maggior
 parte degli allievi, nella mia esperienza, usano ancora CodeBlocks come
 avrebbero fatto su un sistema Windows e si limitano a usare i normali strumenti
 grafici di gestione dei file per tutte le operazioni che coinvolgono spostament
o/copia/cancellazione di file.
\end_layout

\begin_layout Standard
Chiaramente chi volesse potrebbe anche pensare di approfondire la propria
 conoscenza di questo ambiente e dei vari strumenti, da linea di comando
 e non solo, che le distribuzioni Linux normalmente metteno a disposizione
 e che possono essere utilizzati per alcune attività 
\begin_inset Quotes eld
\end_inset

collaterali
\begin_inset Quotes erd
\end_inset

 (ad esempio creazione di casi di test di grandi dimensioni).
 La mia opinione è che l'allenamento sulla piattaforma di gara ufficiale,
 che solitamente viene comunicata e messa a disposizione per il download
 intorno a febbraio-marzo, sia assolutamente indispensabile, ulteriori approfond
imenti possono invece essere lasciati a dopo l'eventuale passaggio alla
 finale nazionale.
\end_layout

\begin_layout Subsection
\begin_inset CommandInset label
LatexCommand label
name "subsec:Subtask-e-template"

\end_inset

Subtask e template di soluzione
\end_layout

\begin_layout Standard
Un'altra novità che è stata aggiunta negli ultimi anni è quella di dividere
 i casi di test in una serie di gruppi denominati 
\series bold
subtask
\series default
.
 Sebbene a livello delle territoriali questo non sia stato ancora fatto,
 sapere cosa sono può essere interessante poiche moltissimi dei problemi
 a disposizione per allenarsi sul correttore contengono subtask, le ultime
 edizioni delle Olimpiadi a squadre contengono problemi strutturati in questo
 modo e le finali nazionali e internazionali delle Olimpiadi sono strutturate
 usando questa modalità.
\end_layout

\begin_layout Standard
Un problema contiene normalmente 5-6 subtask, ognuno dei quali contiene
 una serie di casi di test che hanno delle caratteristiche in comune, tipicament
e delle limitazioni sulle dimensioni o sul tipo dei dati di input (per un
 esempio si veda il problema 
\begin_inset CommandInset ref
LatexCommand ref
reference "sec:Anno-luce"

\end_inset

 
\begin_inset CommandInset ref
LatexCommand vpageref
reference "sec:Anno-luce"

\end_inset

).
 Il punteggio a questo punto non è più dato in base al numero di casi di
 test che vengono risolti, ma per ogni subtask vengono dati una serie di
 punti solo se tutti i casi del subtask vengono risolti correttamente.
 Può quindi capitare che dato un subtask contenente ad esempio 5 casi di
 test, 4 di essi siano risolti correttamente e 1 no, e quindi i punti assegnati
 siano 0.
\end_layout

\begin_layout Standard
La differenza sostanziale è che, essendo i subtask relativi a certe limitazioni
 particolari, ci si può concentrare a risolvere solo alcuni casi del problema,
 evitando di cercare la soluzione che permette di risolvere in maniera completa
 il problema.
 In molti casi questa può essere una condotta di gara più fruttuosa, soprattutto
 se si riesce fin da subito a valutare la difficoltà della soluzione generale
 del problema e invece la relativa facilità nella soluzione di alcuni subtask.
\end_layout

\begin_layout Standard
Insieme a questa nuova impostazione dei casi di test, nelle ultime edizioni
 delle Nazionali e delle Olimpiadi a squadre viene fornito un 
\emph on
template di soluzione,
\emph default
 cioè uno o più file in cui sono già presenti dei frammenti di codice che
 possono essere utilizzati per scrivere la propria soluzione.
 Tipicamente il file contiene già il 
\emph on
main
\emph default
, nel quale è presente la lettura dell'input e la scrittura dell'output
 e una funzione senza corpo, che deve essere completata per implementare
 l'algoritmo risolutivo.
 Sebbene non sia obbligatorio utilizzare il template fornito, risulta molto
 comodo in quanto non è più necessario scrivere il codice di I/O, che risulta
 già ottimizzato ed è garantito essere corretto.
 Per il resto, nel codice possono essere aggiunte funzioni, variabili, definizio
ni di strutture o classi o qualunque altra cosa si ritenga necessaria.
\end_layout

\begin_layout Section
Le funzioni
\end_layout

\begin_layout Standard
In questo paragrafo si farà un breve ripasso sull'utilizzo delle funzioni,
 che, anche se non strettamente necessarie (se non nella ricorsione), sono
 estremamente utili nella stesura di codice modulare, caratteristica sicuramente
 desiderabile anche nella scrittura di programmi di piccole dimensioni.
 Quello che verrà mostrato sarà inerente all'utilizzo che viene fatto delle
 funzioni durante le gare e quindi saranno volutamente omessi dettagli su
 altre modalità di utilizzo che non trovano applicazione nelle Olimpiadi.
\end_layout

\begin_layout Standard
Il concetto di 
\emph on
funzione
\emph default
 è simile a quello che viene presentato in matematica o in altri campi scientifi
ci, però siccome non tutti i lettori potrebbero averlo presente, verrà presentat
o a un livello più intuitivo.
 
\end_layout

\begin_layout Standard
L'idea di base è quella di raggruppare in un solo punto il codice necessario
 per eseguire un compito specifico (trovare la radice quadrata di un numero,
 fare il totale di una fattura, stampare un biglietto aereo, ecc.) e isolarlo
 dal resto del programma, in modo da ottenere una suddivisione dei compiti
 tra pezzi di codice 
\begin_inset Quotes eld
\end_inset

specializzati
\begin_inset Quotes erd
\end_inset

, utilizzabili in qualunque punto del programma.
 I principali vantaggi delle funzioni sono quindi:
\end_layout

\begin_layout Itemize
ogni funzione può essere sviluppata indipendentemente dal resto del codice
 e testata separatamente
\end_layout

\begin_layout Itemize
posso riutilizzare algoritmi comuni attraverso la creazione di librerie
 di funzione (che di fatto è quello che avviene nella libreria del C e del
 C++)
\end_layout

\begin_layout Itemize
il programma nel suo complesso diventa più facile da sviluppare e mantenere,
 poichè non è più una lunga sequenza di istruzioni di basso livello, ma
 l'insieme di chiamate di funzioni che svolgono operazioni a un livello
 di astrazione più elevato
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement h
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename ../materiali/funzioni/disegno funzione.eps
	scale 50

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:disegno funzione"

\end_inset

Rappresentazione generale di una funzione
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Una rappresentazione grafica del concetto di funzione può essere vista in
 figura 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:disegno funzione"

\end_inset

, dove, al contrario di come spesso viene disegnata in altri contesti, la
 funzione è una 
\begin_inset Quotes eld
\end_inset

scatola nera
\begin_inset Quotes erd
\end_inset

 che riceve degli input (In
\begin_inset Formula $_{\text{1}}$
\end_inset

, In
\begin_inset Formula $_{\text{2}}$
\end_inset

, \SpecialChar ldots
, In
\begin_inset Formula $_{\text{n}}$
\end_inset

) a destra e fornisce in uscita un output Out, mostrato a sinistra.
 La scelta di porre gli input a destra e gli output a sinistra deriva dall'analo
gia con la sintassi effettiva delle funzioni nei linguaggi C/C++ (e in molti
 altri), in cui gli input, chiamati 
\emph on
parametri
\emph default
, si trovano a destra del nome della funzione e l'output, chiamato 
\emph on
valore di ritorno
\emph default
, si trova a sinistra del nome di funzione.
 Quella rappresentata è la forma più generale di funzione, poi può essere
 che alcune funzioni non abbiano parametri o valore di ritorno o manchino
 di entrambi.
\end_layout

\begin_layout Standard
Sintatticamente una funzione viene definita nel seguente modo:
\end_layout

\begin_layout Quotation

\emph on
valore_di_ritorno nome_funzione(lista_dei_parametri)
\end_layout

\begin_layout Standard
dove:
\end_layout

\begin_layout Description
valore_di_ritorno: può essere 
\emph on
void
\emph default
, se non presenta output, oppure un qualsiasi tipo di dato elementare (int,
 char, float, ecc.) o definito dall'utente (struttura o classe)
\end_layout

\begin_layout Description
nome_funzione: è un qualsiasi identificatore valido (come i nomi di variabili)
 che indica la semantica della funzione, cioè il suo scopo
\end_layout

\begin_layout Description
lista_di_parametri: una lista di variabili, elencate con tipo e nome, separate
 da virgola
\end_layout

\begin_layout Standard
Per comprenderne meglio il significato ricorriamo a un esempio semplicissimo:
 supponiamo di voler sapere quale sia il massimo tra due numeri interi inseriti
 dall'utente.
 Un codice possibile
\begin_inset Foot
status open

\begin_layout Plain Layout
Il codice è volutamente 
\begin_inset Quotes eld
\end_inset

didattico
\begin_inset Quotes erd
\end_inset

 per evidenziare alcuni aspetti legati al passaggio di parametri, un'implementaz
ione più realistica utilizzerebbe una sola riga di codice.
\end_layout

\end_inset

 per raggiungere lo scopo è quello presentato di seguito:
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "basicstyle={\small\ttfamily},breaklines=true,frame=lr,language=C,numbers=left,showstringspaces=false,tabsize=4"
inline false
status open

\begin_layout Plain Layout

int massimo(int r, int s)
\end_layout

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

	int max;
\end_layout

\begin_layout Plain Layout

	if (r > s)
\end_layout

\begin_layout Plain Layout

		max = r;
\end_layout

\begin_layout Plain Layout

	else
\end_layout

\begin_layout Plain Layout

		max = s;
\end_layout

\begin_layout Plain Layout

	return max;
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

int main()
\end_layout

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

	int a, b, c;
\end_layout

\begin_layout Plain Layout

	scanf("%d",&a);
\end_layout

\begin_layout Plain Layout

	scanf("%d",&b);
\end_layout

\begin_layout Plain Layout

	c = massimo(a, b);
\end_layout

\begin_layout Plain Layout

	printf("Il massimo è %d
\backslash
n",c);
\end_layout

\begin_layout Plain Layout

	return 0;
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Come si può vedere dalla figura 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:Passaggio-di-parametri"

\end_inset

 nel programma principale, all'interno del 
\emph on
main
\emph default
, compaiono tre variabili locali, 
\emph on
a
\emph default
, 
\emph on
b
\emph default
 e 
\emph on
c
\emph default
, e i valori delle prime due vengono inseriti dall'utente tramite le solite
 funzioni di input.
 Alla riga 16 il programma principale chiama la funzione 
\emph on
massimo
\emph default
, passando come parametri le variabili 
\emph on
a
\emph default
 e 
\emph on
b
\emph default
 (passaggio 1 in figura).
 Questo fa si che i valori contenuti in 
\emph on
a
\emph default
 e 
\emph on
b
\emph default
 vengano copiati all'interno dei parametri formali 
\emph on
r
\emph default
 e 
\emph on
s
\emph default
, che sono a tutti gli effetti delle variabili contenute 
\begin_inset Quotes eld
\end_inset

all'interno
\begin_inset Quotes erd
\end_inset

 della funzione 
\emph on
massimo
\emph default
.
 Detta funzione esegue quindi le operazioni sui valori passati e inserisce
 il risultato all'interno della variabile 
\emph on
max
\emph default
, che viene poi 
\begin_inset Quotes eld
\end_inset

ritornata
\begin_inset Quotes erd
\end_inset

 tramite l'istruzione alla riga 8 (passaggio 2 in figura).
 Il valore ritornato viene poi assegnato alla variabile 
\emph on
c
\emph default
, che come già detto è locale al 
\emph on
main
\emph default
.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename ../materiali/funzioni/passaggio parametri.eps
	scale 50

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:Passaggio-di-parametri"

\end_inset

Passaggio di parametri per copia
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Questo semplice schema può essere usato in moltissime situazioni, ne esistono
 però altre dove non è possibile cavarsela allo stesso modo, basti pensare
 ad esempio a una funzione che faccia l'ordinamento di un vettore o la ricerca
 del minimo in una matrice: in questi esempi difatti dover passare un vettore
 o una matrice a una funzione richiede di comprendere alcuni concetti legati
 agli indirizzi e ai puntatori che in generale risultano poco intuitivi
 e che, se usati male, portano a degli errori difficili da individuare.
 Nelle gare quindi si risolve il problema in un modo che, seppure possa
 risultare indigesto agli ingegneri del software, permette di gestire i
 casi indicati (e altri simili) in modo indolore.
 Il 
\begin_inset Quotes eld
\end_inset

trucco
\begin_inset Quotes erd
\end_inset

 è quello di lavorare direttamente con le 
\emph on
variabili globali
\emph default
, che, proprio per questa loro caratteristica, vengono viste da tutte le
 funzioni, le quali possono agire direttamente su di esse, senza bisogno
 di ricorrere al passaggio dei parametri, come mostrato nel codice seguente:
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "basicstyle={\small\ttfamily},breaklines=true,frame=lr,language=C,numbers=left,showstringspaces=false,tabsize=4"
inline false
status open

\begin_layout Plain Layout

#define N 5
\end_layout

\begin_layout Plain Layout

int V[N];
\end_layout

\begin_layout Plain Layout

int somma()
\end_layout

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

	int s = 0;
\end_layout

\begin_layout Plain Layout

	for (int i = 0; i<N; i++)
\end_layout

\begin_layout Plain Layout

		s+=V[i];
\end_layout

\begin_layout Plain Layout

	return max;
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

int main()
\end_layout

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

	int c;
\end_layout

\begin_layout Plain Layout

	for (int i = 0; i<N; i++)
\end_layout

\begin_layout Plain Layout

		scanf("%d",&V[i]);
\end_layout

\begin_layout Plain Layout

	c = somma();
\end_layout

\begin_layout Plain Layout

	printf("La somma degli elementi del vettore è %d
\backslash
n",c);
\end_layout

\begin_layout Plain Layout

	return 0;
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Come si vede esiste un vettore globale V, di lunghezza 5, che viene visto
 sia dal 
\emph on
main
\emph default
 che dalla funzione 
\emph on
somma
\emph default
, le quali lo utilizzano per valorizzarlo (il 
\emph on
main
\emph default
) e per calcolarne la somma, senza che la funzione 
\emph on
somma
\emph default
 abbia bisogno del passaggio di parametri
\begin_inset Foot
status collapsed

\begin_layout Plain Layout
Si vedrà più avanti che l'utilizzo delle variabili globali comporta altri
 vantaggi che fanno si che l'uso in gara sia altamente consigliato.
\end_layout

\end_inset

.
\end_layout

\end_body
\end_document
