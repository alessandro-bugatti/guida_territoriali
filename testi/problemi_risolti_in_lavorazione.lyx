#LyX 2.2 created this file. For more info see http://www.lyx.org/
\lyxformat 508
\begin_document
\begin_header
\save_transient_properties true
\origin unavailable
\textclass book
\begin_preamble
\date{}
\end_preamble
\use_default_options false
\master guida.lyx
\maintain_unincluded_children true
\language italian
\language_package default
\inputencoding auto
\fontencoding global
\font_roman "palatino" "default"
\font_sans "helvet" "default"
\font_typewriter "courier" "default"
\font_math "auto" "auto"
\font_default_family default
\use_non_tex_fonts false
\font_sc false
\font_osf false
\font_sf_scale 100 100
\font_tt_scale 100 100
\graphics default
\default_output_format default
\output_sync 0
\bibtex_command default
\index_command default
\paperfontsize default
\spacing single
\use_hyperref false
\papersize a4paper
\use_geometry true
\use_package amsmath 1
\use_package amssymb 1
\use_package cancel 1
\use_package esint 1
\use_package mathdots 1
\use_package mathtools 1
\use_package mhchem 1
\use_package stackrel 1
\use_package stmaryrd 1
\use_package undertilde 1
\cite_engine basic
\cite_engine_type default
\biblio_style plain
\use_bibtopic false
\use_indices false
\paperorientation portrait
\suppress_date false
\justification true
\use_refstyle 0
\index Indice
\shortcut idx
\color #008000
\end_index
\leftmargin 3cm
\topmargin 3cm
\rightmargin 3cm
\bottommargin 3cm
\secnumdepth 3
\tocdepth 3
\paragraph_separation indent
\paragraph_indentation default
\quotes_language english
\papercolumns 1
\papersides 1
\paperpagestyle default
\tracking_changes false
\output_changes false
\html_math_output 0
\html_css_as_file 0
\html_be_strict false
\end_header

\begin_body

\begin_layout Chapter
Problemi territoriali risolti
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

% Questo documento è solo per rendere la compilazione più veloce, una volta
 che un problema viene considerato definitivo viene copiato e incollato
 nel file corretto (il mio computer non è velocissimo, ci si arrangia come
 si può :-)
\end_layout

\end_inset


\end_layout

\begin_layout Section
Gerarchie di tutor - Territoriali 2019
\end_layout

\begin_layout Standard
\begin_inset Box Framed
position "t"
hor_pos "c"
has_inner_box 0
inner_pos "t"
use_parbox 0
use_makebox 0
width "100col%"
special "none"
height "1in"
height_special "totalheight"
thickness "0.4pt"
separation "3pt"
shadowsize "4pt"
framecolor "black"
backgroundcolor "none"
status open

\begin_layout Subsection*
Gerarchie di tutor (gerarchie)
\end_layout

\begin_layout Subsubsection*
Punteggio massimo: 19
\end_layout

\begin_layout Subsubsection*
\noindent
Descrizione del problema
\end_layout

\begin_layout Plain Layout
Le Olimpiadi Italiane di Informatica sono gestite da Luigi con l’aiuto di
 
\emph on
N
\emph default
 ragazzi e ragazze che prendono il nome di 
\series bold
tutor
\series default
.
 Questi membri dello staff (che in passato hanno partecipato alle OII come
 voi!) con grande impegno e dedizione mettono a beneficio delle OII le loro
 conoscenze tecniche.
 In così tanti però è difficile organizzarsi, per questo già da molti anni
 è stata definita una gerarchia molto precisa che, se rispettata, massimizza
 l’efficienza della squadra.
 
\end_layout

\begin_layout Plain Layout
Al tutor 
\emph on
i
\emph default
-esimo è stato associato un 
\series bold
tutor di riferimento
\series default
 
\begin_inset Formula $R_{i}$
\end_inset

 , che è in pratica un altro tutor incaricato di supervisionare il suo lavoro.
 In cima alla gerarchia si trova il 
\series bold
tutor leader
\series default
, al quale non è assegnato alcun tutor di riferimento.
\end_layout

\begin_layout Plain Layout
\begin_inset VSpace defskip
\end_inset


\end_layout

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename /home/alex/repositories/guida_territoriali/materiali/problemi territoriali/2019_gerarchie/gerarchia.png
	scale 25

\end_inset


\end_layout

\begin_layout Plain Layout
L’efficacia di questa politica è massima quando ogni tutor di riferimento
 risulta 
\emph on
più competente di tutti i tutor che è incaricato di supervisionare
\emph default
.
 Negli ultimi anni però, Luigi si è accorto che qualcosa non va: sembra
 infatti che i livelli di competenza 
\begin_inset Formula $C_{i}$
\end_inset

 dei vari tutor siano cambiati e che quindi non ci sia più il bilanciamento
 necessario.
 Urge una riorganizzazione! Però, essendo tra amici, ed essendo la burocrazia
 molto costosa, sarà necessario prestare molta attenzione alle promozioni
 fatte.
 
\end_layout

\begin_layout Plain Layout
La promozione di un tutor 
\emph on
i
\emph default
 consiste nello scambio di ruolo tra 
\emph on
i
\emph default
 ed il suo tutor di riferimento, di fatto facendo salire 
\emph on
i
\emph default
 nella gerarchia e facendo scendere il suo supervisore.
 Ognuna di queste operazioni ha un costo e, per ribilanciare l’intera struttura,
 Luigi vorrebbe farne il minor numero possibile.
 
\end_layout

\begin_layout Plain Layout
Essendo tra amici, Luigi vuole evitare che un tutor venga continuamente
 promosso e declassato durante la riorganizzazione.
 Per evitare ogni problema si impone quindi la seguente regola: se un tutor
 viene promosso, tutti i 
\series bold
successivi
\series default
 scambi di ruolo che lo coinvolgono dovranno essere ancora delle 
\emph on
promozioni
\emph default
.
 
\end_layout

\begin_layout Plain Layout
Aiuta Luigi a calcolare il numero di minimo di scambi che deve fare per
 riorganizzare la gerarchia senza però mai violare la sua regola!
\end_layout

\begin_layout Subsubsection*
Dati di input
\end_layout

\begin_layout Plain Layout
La prima riga del file di input contiene un intero 
\emph on
T,
\emph default
 il numero di casi di test.
 Seguono 
\emph on
T
\emph default
 casi di test, numerati da 1 a 
\emph on
T
\emph default
 .
 Ogni caso di test è preceduto da una riga vuota.
 
\end_layout

\begin_layout Plain Layout
Ciascun caso di test è composto da 
\emph on
N
\emph default
 + 1 righe: la prima contiene un numero intero 
\emph on
N
\emph default
, il numero di tutor.
 Ciascuna delle seguenti 
\emph on
N
\emph default
 righe contiene due interi 
\begin_inset Formula $R_{i}$
\end_inset

 e 
\begin_inset Formula $C_{i}$
\end_inset

 separati da spazio: rispettivamente l’indice del tutor di riferimento ed
 il livello di competenza dell’
\emph on
i
\emph default
-esimo tutor (con 
\emph on
i
\emph default
 che va da 0 a 
\emph on
N
\emph default
 − 1).
\end_layout

\begin_layout Subsubsection*
Dati di output
\end_layout

\begin_layout Plain Layout
Il file di output deve contenere la risposta ai casi di test che sei riuscito
 a risolvere.
 Per ogni caso di test che hai risolto, il file di output deve contenere
 una riga con la dicitura
\end_layout

\begin_layout Verbatim

Case #t: s
\end_layout

\begin_layout Plain Layout
dove 
\emph on
t
\emph default
 è il numero del caso di test (a partire da 1) e il valore 
\emph on
s
\emph default
 è il minimo numero di scambi per bilanciare la gerarchia rispettando le
 regole.
\end_layout

\begin_layout Subsubsection*
Assunzioni
\end_layout

\begin_layout Itemize

\emph on
T
\emph default
 = 19, nei file di input che scaricherai saranno presenti esattamente 19
 casi di test.
 
\end_layout

\begin_layout Itemize
1 ≤ 
\emph on
N
\emph default
 ≤ 1000.
 
\end_layout

\begin_layout Itemize
0 ≤ 
\begin_inset Formula $C_{i}$
\end_inset

 ≤ 
\emph on
N
\emph default
 − 1.
 
\end_layout

\begin_layout Itemize
0 ≤ 
\begin_inset Formula $R_{i}$
\end_inset

 ≤ 
\emph on
N
\emph default
 − 1 se i non è il tutor leader, 
\begin_inset Formula $R_{i}$
\end_inset

 = −1 se i è il tutor leader.
 
\end_layout

\begin_layout Itemize
I valori di competenza dei tutor sono numeri da 0 a 
\emph on
N
\emph default
 − 1 e sono tutti distinti.
 
\end_layout

\begin_layout Itemize
Non è consentito declassare un tutor dopo una sua promozione ma è possibile
 declassarlo prima.
 
\end_layout

\begin_layout Itemize
Esiste uno ed un solo tutor leader.
 Risalendo la catena di supervisori di un qualsiasi tutor, si raggiunge
 sempre il tutor leader.
\end_layout

\begin_layout Plain Layout
\begin_inset Tabular
<lyxtabular version="3" rows="3" columns="2">
<features islongtable="true" longtabularalignment="center">
<column alignment="left" valignment="top" width="2.5in">
<column alignment="left" valignment="top" width="5cm">
<row>
<cell alignment="left" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
File input.txt
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
File output.txt
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none
2 
\end_layout

\begin_layout Plain Layout
\begin_inset VSpace defskip
\end_inset


\end_layout

\begin_layout Plain Layout

\family typewriter
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none
7 
\end_layout

\begin_layout Plain Layout

\family typewriter
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none
6 6 
\end_layout

\begin_layout Plain Layout

\family typewriter
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none
-1 0 
\end_layout

\begin_layout Plain Layout

\family typewriter
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none
4 4 
\end_layout

\begin_layout Plain Layout

\family typewriter
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none
1 2 
\end_layout

\begin_layout Plain Layout

\family typewriter
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none
1 1 
\end_layout

\begin_layout Plain Layout

\family typewriter
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none
4 3 
\end_layout

\begin_layout Plain Layout

\family typewriter
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none
4 5 
\end_layout

\begin_layout Plain Layout

\family typewriter
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none
8 3 
\end_layout

\begin_layout Plain Layout
\begin_inset VSpace defskip
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none
Case #1: 6 
\end_layout

\begin_layout Plain Layout

\family typewriter
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none
Case #2: 2 
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none
6 
\end_layout

\begin_layout Plain Layout

\family typewriter
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none
2 4 
\end_layout

\begin_layout Plain Layout

\family typewriter
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none
-1 7 
\end_layout

\begin_layout Plain Layout

\family typewriter
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none
2 5 
\end_layout

\begin_layout Plain Layout

\family typewriter
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none
5 1 
\end_layout

\begin_layout Plain Layout

\family typewriter
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none
2 0 
\end_layout

\begin_layout Plain Layout

\family typewriter
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none
3 2 
\end_layout

\begin_layout Plain Layout

\family typewriter
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none
5 3
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Subsubsection*
Spiegazione
\end_layout

\begin_layout Plain Layout
\noindent
La spiegazione degli esempi, essendo lunga, può essere recuperata nei testi
 originali.
\end_layout

\begin_layout Plain Layout
.
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Suggerimenti
\end_layout

\begin_layout Itemize
Nonostante la figura e il testo del problema suggeriscano che i dati e le
 loro relazioni abbiano una topologia ad albero, è necessaio usare una strutture
 dati esplicita per rappresentarli?
\end_layout

\begin_layout Itemize
Come si può garantire che un tutor dopo essere stato promosso non vanga
 declassato in un momento successivo?
\end_layout

\begin_layout Itemize
Ci sono delle scelte ottime che una volta effettuate non richiedano di tornare
 più sui propri passi? 
\end_layout

\begin_layout Itemize
Come si può garantire che una scelta di scambi non solo porti a una soluzione
 del problema, ma sia anche quella migliore possibile?
\end_layout

\begin_layout Subsection
Soluzione
\end_layout

\begin_layout Standard
A prima vista potrebbe non essere chiaro come affrontare il problema, dato
 che la struttura ad albero induce a cercare una soluzione nella quale venga
 rappresentano esplicitamente questo tipo di struttura dati.
\end_layout

\begin_layout Standard
Provando un po' a riflettere sui casi di esempio si può vedere che se si
 parte da un tutor a caso per fare un eventuale scambio con il suo tutor
 di riferimento, si rischia di violare la regola che non vuole che un tutor
 venga declassato dopo essere stato promosso: nel primo esempio, se partissimo
 dal tutor numero 2, con competenza uguale a 4, verrebbe prima scambiato
 con il proprio tutor di riferimento, il numero 4 con competenza 1, ottenendo
 così una promozione.
 Successivamente però dovrebbe però essere retrocesso perchè comunque si
 troverebbe a un livello più alto sia del numero 6, con competenza 5, che
 del numero 0 con competenza 6.
 
\end_layout

\begin_layout Standard
Questa osservazione evidenzia che partire da un tutor a caso non è l'idea
 corretta, allora sembra necessario trovare una strategia per stabilere
 l'ordine con cui analizzare e eventualmente spostare i tutor.
 L'osservazione astuta, che permette di risolvere il problema, è quella
 di notare che è sufficiente mettere i tutor al posto corretto partendo
 da quelli più competenti fino a quelli con meno competenza.
 
\end_layout

\begin_layout Standard
Si supponga infatti di aver ordinato i tutor per competenza e che inizialmente,
 per quanto ci è dato sapere, nessuno dei tutor sia nella sua posizione
 finale.
 Partendo dal tutor più competente, si può procedere a scambiarlo con i
 propri tutor di riferimento, finchè finirà inevitabilmente alla radice
 dell'albero, essendo quello con la competenza maggiore.
 Sicuramente non potrà più essere declassato, essendo nella sua posizione
 finale, e, anche se nel procedere degli scambi altri tutor sono stati declassat
i, questo non è un problema, perchè fa parte delle regole di scambio.
 
\end_layout

\begin_layout Standard
Procedendo adesso con il secondo tutor più competente, anche questo 
\begin_inset Quotes eld
\end_inset

risalirà
\begin_inset Quotes erd
\end_inset

 (a meno che non sia già al livello sotto al tutor più competente) fino
 ad arrivare alla sua posizione definitiva e anche in questo caso non potrà
 più scendere, perchè i tutor che rimangono da posizionare hanno competenza
 inferiore alla sua.
 Iterando questo procedimento per tutti i tutor, sempre nell'ordine dal
 più competente a quello meno, si arriverà alla soluzione del problema.
 Il numero di scambi è garantito essere il minimo poichè ogni tutor, dovendo
 risalire a una posizione che si trova a 
\emph on
L
\emph default
 livelli più in alto, ha bisogno di fare non meno di 
\emph on
L
\emph default
 scambi per arrivarci (si ricorda che ogni tutor può scambiarsi solo con
 il tutor di riferimento e non con altri tutor più 
\begin_inset Quotes eld
\end_inset

distanti
\begin_inset Quotes erd
\end_inset

 di così).
\end_layout

\begin_layout Standard
Si può anche notare che questa è una soluzione di tipo 
\emph on
greedy
\emph default
, poichè ad ogni passaggio viene posizionato un tutor nella sua posizione
 definitiva, che non dovrà più essere modificata perchè è già parte della
 soluzione del problema.
\end_layout

\begin_layout Standard
A questo punto una possibile implementazione è la seguente:
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "basicstyle={\small\ttfamily},frame=lr,language={C++},numbers=left,showstringspaces=false,tabsize=4"
inline false
status open

\begin_layout Plain Layout

const int MAXN = 1000;
\end_layout

\begin_layout Plain Layout

struct Nodo{
\end_layout

\begin_layout Plain Layout

	int R;
\end_layout

\begin_layout Plain Layout

	int C;
\end_layout

\begin_layout Plain Layout

	bool sistemato = false;
\end_layout

\begin_layout Plain Layout

};
\end_layout

\begin_layout Plain Layout

Nodo nodi[MAXN];
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

int maggiore(Nodo nodi[], int N)
\end_layout

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

	int massimo = -1, indice;
\end_layout

\begin_layout Plain Layout

	for (int i = 0; i < N; i++)
\end_layout

\begin_layout Plain Layout

		if (nodi[i].C > massimo && nodi[i].sistemato == false){
\end_layout

\begin_layout Plain Layout

			indice = i;
\end_layout

\begin_layout Plain Layout

			massimo = nodi[i].C;
\end_layout

\begin_layout Plain Layout

		} 
\end_layout

\begin_layout Plain Layout

	return indice;
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

	
\end_layout

\begin_layout Plain Layout

int solve() {
\end_layout

\begin_layout Plain Layout

    int N;
\end_layout

\begin_layout Plain Layout

    cin >> N;
\end_layout

\begin_layout Plain Layout

    int risposta = 0;     
\end_layout

\begin_layout Plain Layout

    for (int i=0; i<N; i++) {
\end_layout

\begin_layout Plain Layout

        cin >> nodi[i].R >> nodi[i].C;
\end_layout

\begin_layout Plain Layout

        nodi[i].sistemato = false;
\end_layout

\begin_layout Plain Layout

    }
\end_layout

\begin_layout Plain Layout

	for (int i=0; i<N; i++) {
\end_layout

\begin_layout Plain Layout

        int da_sistemare = maggiore(nodi, N);
\end_layout

\begin_layout Plain Layout

        while (nodi[da_sistemare].R != -1 && 
\end_layout

\begin_layout Plain Layout

			nodi[da_sistemare].C > nodi[nodi[da_sistemare].R].C)
\end_layout

\begin_layout Plain Layout

        {
\end_layout

\begin_layout Plain Layout

			int temp = nodi[da_sistemare].C;
\end_layout

\begin_layout Plain Layout

			nodi[da_sistemare].C = nodi[nodi[da_sistemare].R].C;
\end_layout

\begin_layout Plain Layout

			nodi[nodi[da_sistemare].R].C = temp;
\end_layout

\begin_layout Plain Layout

			da_sistemare = nodi[da_sistemare].R;
\end_layout

\begin_layout Plain Layout

			risposta++;
\end_layout

\begin_layout Plain Layout

		}
\end_layout

\begin_layout Plain Layout

		nodi[da_sistemare].sistemato = true;
\end_layout

\begin_layout Plain Layout

    }
\end_layout

\begin_layout Plain Layout

	return risposta;
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

int main() {
\end_layout

\begin_layout Plain Layout

    freopen("input.txt", "r", stdin);
\end_layout

\begin_layout Plain Layout

    freopen("output.txt", "w", stdout);
\end_layout

\begin_layout Plain Layout

    int T, t;
\end_layout

\begin_layout Plain Layout

    scanf("%d", &T);
\end_layout

\begin_layout Plain Layout

    for (t = 1; t <= T; t++) {
\end_layout

\begin_layout Plain Layout

        cout << "Case #" << t << ": " << solve() << endl;
\end_layout

\begin_layout Plain Layout

    }
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Alla riga 3 viene definita la struttura che conterrà le informazioni relative
 ad un singolo tutor, cioè il suo tutor di riferimento R, la sua competenza
 C e un flag che servirà successivante per sapere se un tutor è ancora da
 sistemare oppure è già stato sistemato, cioè è già nella sua posizione
 definitiva all'interno dell'albero delle gerarchie.
 Alla riga 9 viene predisposto l'array che conterrà le informazioni su tutti
 i tutor, dove il numero identificativo del tutor si assume essere l'indice
 dove si trova il tutor, quindi il tutor 0 sarà nella posizione 0, il tutor
 1 nella posizione 1 e così via.
\end_layout

\begin_layout Standard
La funzione 
\emph on
solve
\emph default
, dopo aver effettuato l'input dei dati (righe 24-29), esegue un ciclo per
 scorrere tutti i tutor e andarli a spostare nella loro posizione definitiva.
 Come detto, l'ordine con cui vengono presi in considerazione i tutor deve
 essere dal più competente a quello meno, quindi la funzione 
\emph on
maggiore
\emph default
 (riga 11 e seguenti) si preoccupa di ritornare l'indice del tutor 
\emph on
ancora da sistemare
\emph default
 con la competenza maggiore (verrà spiegato oltre perchè si è deciso di
 cercare ogni volta il massimo e di non procedere invece a un ordinamento
 iniziale).
\end_layout

\begin_layout Standard
A questo punto il ciclo 
\emph on
while
\emph default
 porterà il tutor nella sua posizione definitiva, effettuando uno scambio
 se non è già nella radice e se il suo tutor di riferimento ha una competenza
 minore della sua.
 Lo scambio consiste semplicemente nello scambio dei valori delle rispettive
 competenze (righe 35-37), poichè la topologia dell'albero non cambia, e
 successivamente viene indicato come nuovo nodo da analizzare quello che
 prima era quello del tutor di riferimento (riga 38) e viene incrementato
 il contatore degli scambi.
 Una volta finito questo ciclo viene settato il flag 
\emph on
sistemato
\emph default
 in modo che la funzione di ricerca del maggiore non proponga nuovamente
 questo nodo come nodo da sistemare, poichè porterebbe ovviamente al fallimento
 del programma.
\end_layout

\begin_layout Standard
Perchè non sono stati direttamente ordinati i tutor? Siccome i tutor devono
 essere spostati in posizioni diverse da quelle che occupavano inizialmente,
 sarebbe poi necessario tenere una mappa che associ il numero che avevano
 inizialmente con la posizione che poi andranno ad assumere nel vettore
 dei nodi una volta spostati.
 Questo porterebbe a una complicazione nel codice con un miglioramento delle
 performance intorno al 30%, passando da un tempo totale di 0.1 secondi a
 0.077 secondi, quindi in questo caso sembra un'ottimizzazione non necessaria.
\end_layout

\end_body
\end_document
