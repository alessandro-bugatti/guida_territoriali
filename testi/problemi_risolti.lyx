#LyX 2.2 created this file. For more info see http://www.lyx.org/
\lyxformat 508
\begin_document
\begin_header
\save_transient_properties true
\origin unavailable
\textclass book
\begin_preamble
\date{}
\end_preamble
\use_default_options false
\master guida.lyx
\maintain_unincluded_children true
\language italian
\language_package default
\inputencoding auto
\fontencoding global
\font_roman "palatino" "default"
\font_sans "helvet" "default"
\font_typewriter "courier" "default"
\font_math "auto" "auto"
\font_default_family default
\use_non_tex_fonts false
\font_sc false
\font_osf false
\font_sf_scale 100 100
\font_tt_scale 100 100
\graphics default
\default_output_format default
\output_sync 0
\bibtex_command default
\index_command default
\paperfontsize default
\spacing single
\use_hyperref false
\papersize a4paper
\use_geometry true
\use_package amsmath 1
\use_package amssymb 1
\use_package cancel 1
\use_package esint 1
\use_package mathdots 1
\use_package mathtools 1
\use_package mhchem 1
\use_package stackrel 1
\use_package stmaryrd 1
\use_package undertilde 1
\cite_engine basic
\cite_engine_type default
\biblio_style plain
\use_bibtopic false
\use_indices false
\paperorientation portrait
\suppress_date false
\justification true
\use_refstyle 0
\index Indice
\shortcut idx
\color #008000
\end_index
\leftmargin 3cm
\topmargin 3cm
\rightmargin 3cm
\bottommargin 3cm
\secnumdepth 3
\tocdepth 3
\paragraph_separation indent
\paragraph_indentation default
\quotes_language english
\papercolumns 1
\papersides 1
\paperpagestyle default
\tracking_changes false
\output_changes false
\html_math_output 0
\html_css_as_file 0
\html_be_strict false
\end_header

\begin_body

\begin_layout Chapter
Problemi territoriali risolti
\end_layout

\begin_layout Standard
In questo capitolo sono inseriti tutti i problemi territoriali
\begin_inset Foot
status collapsed

\begin_layout Plain Layout
Non viene affrontato il problema denominato 
\begin_inset Quotes eld
\end_inset

La poltrona di Korrot
\begin_inset Quotes erd
\end_inset

 perché la formulazione risulta noiosa e complessa.
\end_layout

\end_inset

 non trattati negli esempi visti in precedenza, con suggerimenti per la
 soluzione e la soluzione stessa con spiegazioni.
 I suggerimenti vengono posti sotto forma di domande per sollecitare la
 riflessione e mostrare aspetti del problema che potrebbero non essere immediata
mente evidenti, oltre che per sviluppare osservazioni magari non direttamente
 applicabili al problema, ma che potrebbero essere d'aiuto in altri.
 Quindi si consiglia di leggere le domande una ad una, verificare mentalmente
 quanto proposto ed eventualmente implementarlo e solo alla fine procedere
 alla soluzione personale del problema, per poi sottoporlo al correttore
 automatico (vedi 
\begin_inset CommandInset ref
LatexCommand ref
reference "sec:Il-correttore"

\end_inset

) e infine passare ad un confronto con la soluzione proposta, individuandone
 le differenze per poterne trarre vantaggio in altri problemi.
\end_layout

\begin_layout Section
Codice segreto - territoriali 2005
\end_layout

\begin_layout Standard
\begin_inset Box Framed
position "t"
hor_pos "c"
has_inner_box 0
inner_pos "t"
use_parbox 0
use_makebox 0
width "100col%"
special "none"
height "1in"
height_special "totalheight"
thickness "0.4pt"
separation "3pt"
shadowsize "4pt"
framecolor "black"
backgroundcolor "none"
status open

\begin_layout Subsection*
Codice segreto (codice) 
\end_layout

\begin_layout Subsubsection*
Difficoltà D = 1 
\end_layout

\begin_layout Subsubsection*
Descrizione del problema
\end_layout

\begin_layout Plain Layout
Chicco e Spillo comunicano con dei messaggi scritti in codice per non essere
 scoperti.
 Il loro codice funziona così: ogni vocale è rappresentata con la vocale
 successiva in ordine alfabetico, e ogni consonante con la consonante successiva.
 La Y, che è l'ultima vocale, è rappresentata in codice dalla A, che è la
 prima vocale.
 Allo stesso modo, la Z è rappresentata in codice dalla B.
 Per le cifre il discorso è simile: ogni cifra è rappresentata dalla successiva,
 e 9 è rappresentato da 0.
 
\end_layout

\begin_layout Plain Layout
Il codice mantiene la distinzione maiuscole/minuscole.
 Gli spazi e i segni d'interpunzione (compresi gli accenti) non sono modificati
 dal codice segreto.
\end_layout

\begin_layout Plain Layout
Aiutiamo Chicco e Spillo scrivendo un programma per codificare i loro messaggi!
\end_layout

\begin_layout Subsubsection*
Dati di input
\end_layout

\begin_layout Plain Layout
Il file input.txt contiene un intero N nella prima riga.
 Le successive N righe contengono del testo in chiaro, con al più 80 caratteri
 per riga.
 
\end_layout

\begin_layout Subsubsection*
Dati di output
\end_layout

\begin_layout Plain Layout
Il programma, leggendo il file di input, deve scrivere in output N righe
 contenenti il corrispondente testo in codice.
 
\end_layout

\begin_layout Subsubsection*
Assunzioni
\end_layout

\begin_layout Itemize
Il testo in input è composto soltanto da lettere, cifre e segni d'interpunzione.
 
\end_layout

\begin_layout Itemize
Non ci sono caratteri accentati: al posto degli accenti, si usano gli apostrofi.
 
\end_layout

\begin_layout Itemize
Ogni riga di testo contiene al più 80 caratteri in formato ASCII.
 
\end_layout

\begin_layout Itemize
L'alfabeto è quello esteso a 26 lettere: A B C D E F G H I J K L M N O P
 Q R S T U V W X Y Z.
 
\end_layout

\begin_layout Itemize
Le vocali sono A E I O U Y.
 Tutte le altre lettere sono consonanti.
 
\end_layout

\begin_layout Subsubsection*
Esempi di input/output
\end_layout

\begin_layout Plain Layout
\begin_inset Tabular
<lyxtabular version="3" rows="2" columns="2">
<features tabularvalignment="middle">
<column alignment="center" valignment="top" width="2.5in">
<column alignment="center" valignment="top" width="2.7in">
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
File input.txt
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
File output.txt
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\align left
2 
\end_layout

\begin_layout Plain Layout
\align left
Il cellulare di Elena e' 338-4189961.
 
\end_layout

\begin_layout Plain Layout
\align left
Ti aspetta alla stazione alle 8, VAI!
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\align left
Om dimmymesi fo Imipe i' 449-5290072.
 
\end_layout

\begin_layout Plain Layout
\align left
Vo etqivve emme tveboupi emmi 9, WEO!
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Suggerimenti
\end_layout

\begin_layout Standard
Il problema chiede di ricodificare una stringa di caratteri secondo certe
 regole spiegate nel testo.
\end_layout

\begin_layout Itemize
Sai come sono rappresentati i caratteri a basso livello (ti dice qualcosa
 il termine codice ASCII)?
\end_layout

\begin_layout Itemize
Sai leggere una stringa di caratteri in input (non capita spesso in questi
 problemi)?
\end_layout

\begin_layout Itemize
Sai come memorizzare una stringa di caratteri in C o in C++?
\end_layout

\begin_layout Itemize
Conviene leggere le strighe una a una e effettuare le trasformazioni alla
 fine di ogni lettura o farle carattere per carattere?
\end_layout

\begin_layout Itemize
É possibile applicare una banale trasformazione a tutti i caratteri 
\begin_inset Quotes eld
\end_inset

spostandoli
\begin_inset Quotes erd
\end_inset

 di una posizione in avanti per ottenere il codice desiderato? Sembrerebbe
 di no.
\end_layout

\begin_layout Itemize
Se non è possibile applicare la semplice trasformazione indicata sopra è
 perchè ogni gruppo di caratteri (vocali, consonanti, numeri e altri segni)
 deve essere trattato in maniera separata.
 Sai come è possibile discriminare un carattere di un gruppo dagli altri?
 Esistono delle funzioni di libreria che possono aiutare?
\end_layout

\begin_layout Itemize
Il codice deve mantenere la distinzione tra maiuscole e minuscole: conviene
 fare due codifiche diverse a seconda che il carattere sia minuscolo o maiuscolo
 oppure si può fare in un altro modo?
\end_layout

\begin_layout Subsection
Soluzione
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "basicstyle={\small\ttfamily},breaklines=true,frame=lr,language=C,numbers=left,showstringspaces=false,tabsize=4"
inline false
status open

\begin_layout Plain Layout

int N; 
\end_layout

\begin_layout Plain Layout

char buffer[100]; 
\end_layout

\begin_layout Plain Layout

char vocali[]="aeiouy"; 
\end_layout

\begin_layout Plain Layout

char vocaliCambiate[]="eiouya"; 
\end_layout

\begin_layout Plain Layout

char consonanti[]="bcdfghjklmnpqrstvwxz"; 
\end_layout

\begin_layout Plain Layout

char consonantiCambiate[]="cdfghjklmnpqrstvwxzb";
\end_layout

\begin_layout Plain Layout

int vocale(char c) {     
\end_layout

\begin_layout Plain Layout

return (c=='a' || c=='e' || c=='i' || c=='o' || c=='u' || c=='y'); 
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

char traduciVocali(char c) {     
\end_layout

\begin_layout Plain Layout

	int i;     
\end_layout

\begin_layout Plain Layout

	for (i=0; i<6; i++)         
\end_layout

\begin_layout Plain Layout

		if (c==vocali[i]) return vocaliCambiate[i]; 
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

char traduciConsonanti(char c) {     
\end_layout

\begin_layout Plain Layout

	int i;     
\end_layout

\begin_layout Plain Layout

	for (i=0; i<20; i++)         
\end_layout

\begin_layout Plain Layout

		if (c==consonanti[i]) return consonantiCambiate[i]; 
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

int main() 
\end_layout

\begin_layout Plain Layout

{     
\end_layout

\begin_layout Plain Layout

	FILE *in, *out; 	
\end_layout

\begin_layout Plain Layout

	int i,j;     
\end_layout

\begin_layout Plain Layout

	in=fopen("input.txt","r");     
\end_layout

\begin_layout Plain Layout

	out=fopen("output.txt","w");     
\end_layout

\begin_layout Plain Layout

	fscanf(in,"%d",&N); 	
\end_layout

\begin_layout Plain Layout

	fgets(buffer,81,in);     
\end_layout

\begin_layout Plain Layout

	for (j=0; j<N; j++)     
\end_layout

\begin_layout Plain Layout

	{         
\end_layout

\begin_layout Plain Layout

		fgets(buffer,81,in);         
\end_layout

\begin_layout Plain Layout

		for (i=0;buffer[i]!='
\backslash
0';i++)         
\end_layout

\begin_layout Plain Layout

		{             
\end_layout

\begin_layout Plain Layout

			int flag=0;             
\end_layout

\begin_layout Plain Layout

			char temp, c=tolower(buffer[i]);
\end_layout

\begin_layout Plain Layout

            if (c!=buffer[i]) flag=1;             
\end_layout

\begin_layout Plain Layout

			if (isalpha(c))             
\end_layout

\begin_layout Plain Layout

			{                 
\end_layout

\begin_layout Plain Layout

				if (vocale(c)) temp=traduciVocali(c);                
\end_layout

\begin_layout Plain Layout

				else temp=traduciConsonanti(c);
\end_layout

\begin_layout Plain Layout

				if (flag) temp=toupper(temp);
\end_layout

\begin_layout Plain Layout

				fprintf(out,"%c",temp);             
\end_layout

\begin_layout Plain Layout

			}             
\end_layout

\begin_layout Plain Layout

			else if (isdigit(c)) fprintf(out,"%d",((c-'0')+1)%10);   
\end_layout

\begin_layout Plain Layout

			else fprintf(out,"%c",c);         
\end_layout

\begin_layout Plain Layout

		}     
\end_layout

\begin_layout Plain Layout

	}                 
\end_layout

\begin_layout Plain Layout

	return 0; 
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
La soluzione è piuttosto semplice, in questo esercizio forse le difficoltà
 maggiori risiedono nella lettura dell'input: il creatore del testo fornendo
 l'input in quel modo, con l'intero che indica il numero di righe, ha forse
 pensato di rendere più semplice la successiva lettura, ma a causa del modo
 in cui il C gestisce l'input questo causa più problemi che altro.
 Dopo aver letto con la 
\emph on
fscanf
\emph default
 (riga 26) il numero di righe, rimane nel buffer di input un 
\begin_inset Quotes eld
\end_inset

a capo
\begin_inset Quotes erd
\end_inset

, che deve essere tolto per permettere la lettura della riga successiva:
 a questo proposito viene usata la 
\emph on
fgets
\emph default

\begin_inset Foot
status collapsed

\begin_layout Plain Layout
Non viene usata la più usuale 
\emph on
fscanf
\emph default
, poichè nella lettura di stringhe lo spazio verrebbe interpretato come
 terminatore di lettura, spezzando le frasi prima del loro termine naturale.
\end_layout

\end_inset

, che alla riga 27 ha l'unico scopo di eliminare il ritorno a capo e che
 successivamente verrà invece usata per leggere ogni riga.
 Una volta letta una riga e inserita in un buffer si tratta semplicemente
 di scorrerla e applicare le regole del problema ad ogni singolo carattere.
 
\end_layout

\begin_layout Standard
Per le trasformazioni delle lettere sono state create delle stringhe (righe
 3-6) che fungono da 
\begin_inset Quotes eld
\end_inset

mappa
\begin_inset Quotes erd
\end_inset

 per passare dalla lettera originale a quella codificata, in modo molto
 semplice: si cerca nella stringa originale la posizione della lettera da
 convertire e poi si cerca nella stringa che rappresenta la codifica la
 lettera in quella stessa posizione.
 Per i numeri non si fa altro che sommare 1, avendo l'accortezza di usare
 l'operatore di modulo per gestire la trasformazione della cifra 9 e tutto
 quello che avanza viene ristampato così com'è (tra le altre cose anche
 il ritorno a capo viene letto dalla 
\emph on
gets
\emph default
 e ristampato in output).
\end_layout

\begin_layout Standard
La complessità in questo esercizio non costituisce un problema, perché è
 evidente che si tratta di un algoritmo lineare, in quanto scorre ogni riga
 senza mai tornare indietro, e quindi potrebbe gestire senza problemi anche
 input molto grossi.
\end_layout

\begin_layout Section
Il nobile chimico - territoriali 2005
\end_layout

\begin_layout Standard
\begin_inset Box Framed
position "t"
hor_pos "c"
has_inner_box 0
inner_pos "t"
use_parbox 0
use_makebox 0
width "100col%"
special "none"
height "1in"
height_special "totalheight"
thickness "0.4pt"
separation "3pt"
shadowsize "4pt"
framecolor "black"
backgroundcolor "none"
status open

\begin_layout Subsection*
Il nobile chimico (chimico) 
\end_layout

\begin_layout Subsubsection*
Difficoltà  D = 2 
\end_layout

\begin_layout Plain Layout
Il problema Il nobile chimico Alfredo produce nel suo laboratorio due sostanze
 liquide potenzialmente inquinanti: l'Aminozalina e il Brinofulo.
 A fine giornata le deve smaltire in appositi contenitori, dislocati lungo
 il tragitto che parte dal laboratorio e arriva alla sua abitazione.
 Per limitare le possibilità  d'inquinamento, Alfredo deve distribuire l'Aminoza
lina nel maggior numero possibile di contenitori mentre deve dividere il
 Brinofulo nel minor numero possibile di contenitori.
 Tuttavia Aminozalina e Brinofulo non possono essere assolutamente mescolati
 nel medesimo contenitore, altrimenti la loro miscela esplode.
 Ogni volta che raggiunge un contenitore per lo smaltimento dei liquidi,
 Alfredo deve eseguire una sola delle tre seguenti azioni: 
\end_layout

\begin_layout Plain Layout
(i) versare Aminozalina fino al riempimento del contenitore; 
\end_layout

\begin_layout Plain Layout
(ii) versare Brinofulo fino al riempimento del contenitore; 
\end_layout

\begin_layout Plain Layout
(iii) non versare nulla nel contenitore.
 
\end_layout

\begin_layout Plain Layout
Data la quantità  A di litri di Aminozalina e la quantità  B di litri di
 Brinofulo da smaltire, e conoscendo l'elenco degli N contenitori (con rispettiv
a capacità) nell'ordine secondo cui sono incontrati lungo il tragitto dal
 laboratorio alla sua abitazione, Alfredo deve decidere se e quale sostanza
 versare in ciascun contenitore.
 
\end_layout

\begin_layout Subsubsection*
Dati di input 
\end_layout

\begin_layout Plain Layout
Il file input.txt contiene nella prima riga gli interi A e B (rispettivamente
 i litri di Aminozalina e di Brinofulo da smaltire) e il numero N di contenitori
 disponibili.
 Tali valori sono separati da uno spazio.
 Nelle successive N righe (usando una riga per ogni contenitore) è contenuto
 un numero per riga: tali numeri rappresentano le capacità  dei singoli
 contenitori elencati nell'ordine in cui vengono incontrati da Alfredo.
 
\end_layout

\begin_layout Subsubsection*
Dati di output 
\end_layout

\begin_layout Plain Layout
Il file output.txt deve contenere N righe, una per ogni contenitore.
 Ogni riga contiene due numeri separati da uno spazio, rispettivamente il
 numero di litri di Aminozalina e di Brinofulo smaltiti nel corrispondente
 contenitore.
 Si noti che ogni riga deve contenere uno zero nei casi (i) e (ii) descritti
 sopra, e due zeri nel caso (iii).
 
\end_layout

\begin_layout Subsubsection*
Assunzioni 
\end_layout

\begin_layout Itemize
1 < A, B < 10000 
\end_layout

\begin_layout Itemize
1 < N < 100 
\end_layout

\begin_layout Itemize
Le singole capacità  dei contenitori sono degli interi positivi di valore
 inferiore a 10000.
 
\end_layout

\begin_layout Itemize
Le capacità  dei contenitori sono sicuramente sufficienti per smaltire tutta
 l'Aminozalina e il Brinofulo prodotti.
 
\end_layout

\begin_layout Itemize
I dati in input garantiscono l'esistenza di una (e una sola) soluzione ottima,
 quindi Alfredo ha un unico modo ottimo per smaltire le sostanze.
 
\end_layout

\begin_layout Itemize
La soluzione ottima prevede che tutti i contenitori utilizzati vengano riempiti
 completamente (non puo' succedere che l'Aminozalina o il Brinofulo terminino
 prima che i contenitori effettivamente usati per lo smaltimento siano tutti
 completamente riempiti).
 
\end_layout

\begin_layout Subsubsection*
Esempi di input/output 
\end_layout

\begin_layout Plain Layout
\begin_inset Tabular
<lyxtabular version="3" rows="2" columns="2">
<features tabularvalignment="middle">
<column alignment="left" valignment="top" width="1in">
<column alignment="left" valignment="top" width="1.5in">
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
File input.txt
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
File output.txt 
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
20 25 7 
\end_layout

\begin_layout Plain Layout
1 
\end_layout

\begin_layout Plain Layout
13 
\end_layout

\begin_layout Plain Layout
4 
\end_layout

\begin_layout Plain Layout
5 
\end_layout

\begin_layout Plain Layout
8 
\end_layout

\begin_layout Plain Layout
2 
\end_layout

\begin_layout Plain Layout
12
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
1 0 
\end_layout

\begin_layout Plain Layout
0 13 
\end_layout

\begin_layout Plain Layout
4 0 
\end_layout

\begin_layout Plain Layout
5 0 
\end_layout

\begin_layout Plain Layout
8 0 
\end_layout

\begin_layout Plain Layout
2 0 
\end_layout

\begin_layout Plain Layout
0 12 
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Suggerimenti
\end_layout

\begin_layout Standard
Il problema richiede di scorrere un vettore di numeri e vedere se soddisfano
 alcune condizioni.
\end_layout

\begin_layout Itemize
Ti sembra un problema greedy?
\end_layout

\begin_layout Itemize
Puoi provare che lo è?
\end_layout

\begin_layout Itemize
La prova vale sia per l'Aminozalina che per il Brinofulo, solo per uno dei
 due o per entrambi?
\end_layout

\begin_layout Itemize
Supposto che il problema sia greedy, ti basta un solo ordinamento o sono
 necessari due ordinamenti diversi per le due sostanze?
\end_layout

\begin_layout Itemize
Se riordini i bidoni, sei poi in grado di stampare la soluzione?
\end_layout

\begin_layout Subsection
Soluzione
\end_layout

\begin_layout Standard
C'è un consenso unanime da parte dei responsabili territoriali
\begin_inset Foot
status open

\begin_layout Plain Layout
Almeno questo è ciò che ricordo, ma la discussione sul problema è avvenuta
 nel 2011, il problema è del 2005 e questa revisione che sto facendo è del
 2013, quindi potrei ricordare cose sbagliate.
 Nel caso, come per tutto quello che scrivo, gli eventuali errori sono solo
 da imputarsi a me.
\end_layout

\end_inset

 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
enlargethispage{-
\backslash
baselineskip}
\end_layout

\end_inset

che la stesura del testo non rispecchi esattamente l'intenzione dell'ideatore,
 che voleva si usasse un approccio greedy, cosa che è dimostrata dal fatto
 che il correttore da il massimo punteggio alle soluzioni di tipo greedy.
 Siccome però non c'è nessuna evidenza sicura che sia così se non i risultati
 che da il correttore, si mostreranno due soluzioni, una semplice che usa
 un approccio greedy, ma che in generale potrebbe dare risultati scorretti,
 l'altra, più complessa, che dovrebbe dare risultati giusti.
 
\end_layout

\begin_layout Subsubsection*
Soluzione greedy
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "basicstyle={\small\ttfamily},breaklines=true,frame=lr,language={C++},numbers=left,showstringspaces=false,tabsize=4"
inline false
status collapsed

\begin_layout Plain Layout

int A; //Aminozalina 
\end_layout

\begin_layout Plain Layout

int B; //Brinofulo 
\end_layout

\begin_layout Plain Layout

int N; //numero di contenitori
\end_layout

\begin_layout Plain Layout

struct bidone {     
\end_layout

\begin_layout Plain Layout

	int posizione;     
\end_layout

\begin_layout Plain Layout

	int capacita;     
\end_layout

\begin_layout Plain Layout

	int riempito; //0 = vuoto, 1 = Aminozalina 2 = Brinofulo 
\end_layout

\begin_layout Plain Layout

};
\end_layout

\begin_layout Plain Layout

bidone bidoni[100];
\end_layout

\begin_layout Plain Layout

int compare_posizione(const void *a, const void *b) {   
\end_layout

\begin_layout Plain Layout

	bidone ba = *(const bidone *) a;   
\end_layout

\begin_layout Plain Layout

	bidone bb = *(const bidone *) b;
\end_layout

\begin_layout Plain Layout

	return (ba.posizione > bb.posizione) - (ba.posizione < bb.posizione);
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

int compare_capacita(const void *a, const void *b) {   
\end_layout

\begin_layout Plain Layout

	bidone ba = *(const bidone *) a;   
\end_layout

\begin_layout Plain Layout

	bidone bb = *(const bidone *) b;
\end_layout

\begin_layout Plain Layout

	return (ba.capacita > bb.capacita) - (ba.capacita < bb.capacita); 
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

int main() 
\end_layout

\begin_layout Plain Layout

{     
\end_layout

\begin_layout Plain Layout

	fstream in,out;     
\end_layout

\begin_layout Plain Layout

	in.open("input.txt",ios::in);     	out.open("output.txt",ios::out);     
\end_layout

\begin_layout Plain Layout

	in >> A >> B >> N;     
\end_layout

\begin_layout Plain Layout

	for (int i=0; i<N; i++){         
\end_layout

\begin_layout Plain Layout

		bidoni[i].posizione=i;         
\end_layout

\begin_layout Plain Layout

		in >> bidoni[i].capacita;         
\end_layout

\begin_layout Plain Layout

		bidoni[i].riempito=0;     
\end_layout

\begin_layout Plain Layout

	}
\end_layout

\begin_layout Plain Layout

	qsort(bidoni,N,sizeof(bidone),compare_capacita);     
\end_layout

\begin_layout Plain Layout

	for (int i=0; i<N && A > 0;i++){         
\end_layout

\begin_layout Plain Layout

		A-=bidoni[i].capacita;         
\end_layout

\begin_layout Plain Layout

		bidoni[i].riempito=1;     
\end_layout

\begin_layout Plain Layout

	}
\end_layout

\begin_layout Plain Layout

	for (int i=N-1; i>=0 && B > 0; i--){         
\end_layout

\begin_layout Plain Layout

		if (B >= bidoni[i].capacita){             
\end_layout

\begin_layout Plain Layout

			B-=bidoni[i].capacita;             
\end_layout

\begin_layout Plain Layout

			bidoni[i].riempito=2;         
\end_layout

\begin_layout Plain Layout

		}     
\end_layout

\begin_layout Plain Layout

	}      
\end_layout

\begin_layout Plain Layout

	qsort(bidoni,N,sizeof(bidone),compare_posizione);     
\end_layout

\begin_layout Plain Layout

	for (int i=0; i<N ; i++)         
\end_layout

\begin_layout Plain Layout

		if (bidoni[i].riempito == 0)             
\end_layout

\begin_layout Plain Layout

			out << "0 0" << endl;         
\end_layout

\begin_layout Plain Layout

		else if(bidoni[i].riempito == 1)
\end_layout

\begin_layout Plain Layout

        	out << bidoni[i].capacita << " 0" << endl;         
\end_layout

\begin_layout Plain Layout

		else             
\end_layout

\begin_layout Plain Layout

			out << "0 " << bidoni[i].capacita << endl;     
\end_layout

\begin_layout Plain Layout

	return 0; 
\end_layout

\begin_layout Plain Layout

} 
\end_layout

\end_inset

Sia per l'Aminozalina che per il Brinofulo, date le condizioni del problema,
 non è detto che iniziando a svuotarli in modo greedy, a partire cioè dal
 contenitore meno capiente per l'Aminozalina o dal più capiente per il Brinofulo
 si arrivi alla soluzione ottima.
 Volendo vedere un controesempio supponiamo di avere 30 litri di Brinofluoro
 e avere la sequenza di contenitori, già ordinati, fatta così: 21 10 10
 10 3 3 3.
 Svuotando il Brinofulo nel primo contenitore dovrei poi usare i tre contenitori
 con capienza 3 litri, non potendo riempire completamente quelli da 10,
 arrivando così ad usare 4 recipienti.
 Se invece non avessi svuotato il Brinofulo nel primo contenitore, poi avrei
 potuto svuotarlo nei tre successivi, usando complessivamente solo 3 contenitori.
\end_layout

\begin_layout Standard
Chiarito questo fatto guardiamo la soluzione greedy, che come già detto
 permette di arrivare al punteggio massimo.
 almeno sul correttore online.
 Il primo passo per affrontare il problema consiste nell'ordinare la sequenza
 dei contenitori in base alla loro capacità, per poi svuotare il Brinofulo
 a partire da quello più grande e l'Aminozalina a partire da quello più
 piccolo.
 Il problema è che, per come viene richiesto di stampare l'output, abbiamo
 necessità di ricordarci la loro collocazione originale: un modo per risolvere
 questo problema è quello di memorizzare all'interno di una struttura (righe
 4-8) sia la capacità del bidone, che la sua posizione originale, che il
 tipo di sostanza che eventualmente è stata versata dentro.
 In questo modo possiamo ordinare il vettore dei contenitori per capienza
 così da poter applicare l'algoritmo greedy nei due sensi e successivamente
 riordinare per posizione originale, avendo salvato nella variabile 
\emph on
riempito
\emph default
 il tipo di sostanza che vi è stata versata dentro (oppure se non vi è stato
 versato nulla).
 A questo proposito basta semplicemente definire due funzioni, 
\emph on
compare_posizione
\emph default
 (riga 10) e 
\emph on
compare_capacita
\emph default
 (riga 15) che se utilizzate nell'algoritmo 
\emph on
qsort
\emph default
 riordinano il vettore o per capienza (riga 31) o per posizione originale
 (riga 42).
\end_layout

\begin_layout Standard
La parte greedy della soluzione è poi semplice: per l'Aminozalina è sufficiente
 scorrere i contenitori a partire dal più piccolo e riempirli finché c'è
 della sostanza da smaltire (righe 32-35), mentre per il Brinofulo bisogna
 anche controllare se la sostanza da smaltire riempie completamente il contenito
re (riga 37), altrimenti bisogna passare al bidone successivo (potrebbe
 anche essere che questo passaggio non serva a niente, dipende da come sono
 stati creati i dati in ingresso).
\end_layout

\begin_layout Standard
Infine, dopo aver riordinato i bidoni per rimetterli nella sequenza originale,
 si scorrono tutti per stampare il loro stato attuale (righe 43-49).
\end_layout

\begin_layout Subsubsection*
Soluzione dinamica
\end_layout

\begin_layout Standard
La soluzione dinamica è decisamente più complessa
\begin_inset Foot
status open

\begin_layout Plain Layout
Decisamente troppo complessa a mio modo di vedere per il livello del problema,
 il che supporta la tesi che l'autore del problema volesse portare gli studenti
 a implementare la versione greedy.
\end_layout

\end_inset

, ma come idea fondamentale si basa sullo stesso principio che era già stato
 illustrato nel problema di Lino il giornalaio (vedi 
\begin_inset CommandInset ref
LatexCommand ref
reference "sec:Esempio:-Lino"

\end_inset

): dopo aver ordinato i bidoni si costruiscono le sottosoluzioni per ogni
 quantità possibile di sostanza, considerando che se conosco la soluzione
 per una data quantità 
\emph on
k
\emph default
 ottima avendo a disposizione i barili da 
\emph on
0
\emph default
 a 
\emph on
j-1
\emph default
, aggiungendo il barile 
\emph on
j-esim
\emph default
o avrò la soluzione ottima per la quantità 
\emph on
k + capacità del barile j-esimo.
\end_layout

\begin_layout Standard
Ovviamente questo approccio si può usare sia per l'Aminozalina che per il
 Brinofulo, modificando opportunamente il controllo che viene fatto per
 verificare la soluzione ottima, dal momento che in un caso interessa usare
 meno bidoni possibili, mentre nell'altro il numero maggiore possibile.
 Premetto che in tutto quello che si dirà di seguito si suppone che le due
 soluzioni, per l'Aminozalina e il Brinofulo, siano disgiunte, cioè non
 ci sono bidoni che fanno parte della soluzione ottima sia per una sostanza
 che per l'altra: nel testo questo non è detto, ma sembra una supposizione
 ragionevole, considerando anche il fatto che se si verificasse ciò il testo
 del problema non definisce cosa sia l'ottimo.
\end_layout

\begin_layout Standard
Per comprendere la soluzione meglio analizziamo tramite dei grafici alcuni
 casi d'esempio, partendo da una situazione semplice per poi complicarla
 in modo da renderla più generale.
 Gli esempi prenderanno in considerazione solo il problema di avere meno
 bidoni possibile, ma come si vedrà nel codice proposto l'idea è esattamente
 la stessa se si volesse avere il maggior numero di bidoni.
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement h
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename ../materiali/problemi territoriali/2005_chimico/dinamica.eps
	display false
	scale 50

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:Esempio-1-chimico"

\end_inset

Esempio con 4 bidoni diversi
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
La figura 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:Esempio-1-chimico"

\end_inset

 mostra un caso con quattro bidoni, di capacità rispettivamente 1, 2, 3
 e 4.
 Per ogni sottoproblema viene aggiornata la tabella, dove nella prima riga
 compare la casella da cui si è partiti per arrivare alla soluzione (serve
 per poi poter ricostruire la soluzione), nella seconda il numero di bidoni
 che occorrono per arrivare a quella soluzione e nella terza la quantità
 di liquido che si riesce a smaltire.
 Aggiornare la tabella è semplice, almeno apparentemente: 
\end_layout

\begin_layout Itemize
dato il bidone 
\emph on
j
\emph default
 di capacità 
\emph on
k
\emph default
,
\begin_inset Separator latexpar
\end_inset


\end_layout

\begin_deeper
\begin_layout Itemize
per ogni casella a partire dalla quantità 
\emph on
k
\emph default
 fino alla somma di tutti i bidoni visti in precedenza, compreso l'attuale,
 si aggiorna la soluzione della casella corrente 
\emph on
i
\emph default
 verificando se porta a una soluzione migliore, cioè se (soluzione per il
 problema
\emph on
 i-k
\emph default
) + 1 è migliore di quando già scoperto per la casella 
\emph on
i
\emph default
 (nel caso non ci fosse niente è sicuramente migliore)
\end_layout

\end_deeper
\begin_layout Standard
Guardiamo ad esempio la terza tabella, quella per il sottoproblema con 3
 bidoni, in cui si parte dalla casella 3 (capacità del nuovo bidone) e si
 arriva fino alla casella 6 (somma delle capacità di tutti i bidoni)
\end_layout

\begin_layout Itemize
casella 3: fino a questo momento la soluzione era con 2 bidoni (la somma
 del primo con il secondo), però vedo che la soluzione per la casella 0
 (cioè i-k) + 1 è migliore e quindi scrivo 1 nella casella 3.
\end_layout

\begin_layout Itemize
casella 4: non è stata ancora esplorata, quindi la soluzione è sicuramente
 ottima e vale (soluzione della casella 1) + 1, cioè 2
\end_layout

\begin_layout Itemize
casella 5: come sopra
\end_layout

\begin_layout Itemize
casella 6: come sopra (ma attenzione...)
\end_layout

\begin_layout Standard
A differenza del problema di Lino, in questo problema i bidoni possono essere
 usati esattamente una volta, il che può portare a dei problemi, come evidenziat
o in figura e nella discussione appena fatta sull'esempio.
 Davvero la quantità di liquido 6 può essere smaltita con due bidoni, nel
 sottoproblema di dimensione 3? In realtà no, perchè il risultato della
 casella 3 è stato ottenuto usando il bidone 3, che non può essere riutilizzato
 una seconda volta.
 Come risolvere, dal momento che comunque esiste una soluzione per la quantità
 6 nel sottoproblema con 3 bidoni? Potrei verificare che se il barattolo
 usato in una soluzione precedente ha la stessa dimensione di quello con
 cui sto aggiornando allora non posso usarlo, a meno che non esistesse in
 precedenza una soluzione peggiore che però non faceva uso di quel barattolo,
 come in effetti succede in questo esempio.
 
\end_layout

\begin_layout Standard
Da qui in poi entro in quella che solitamente con i miei allievi chiamo
 la modalità 
\begin_inset Quotes eld
\end_inset

ginepraio
\begin_inset Quotes erd
\end_inset

, cioè il problema inizia a sfuggire di mano e non si sa dove possa andare
 a finire, quindi quello che dirò va un po' preso con le molle.
 
\end_layout

\begin_layout Standard
La soluzione potrebbe essere quella di ricordare non solo la soluzione ottima
 ma anche, se presente, la soluzione precedente (non ne servono altre perchè
 per come viene fatto l'aggiornamento se non posso usare un bidone perchè
 è già stato usato sicuramente l'altra soluzione non lo usa).
 Quindi, se in ogni casella tengo la soluzione ottima e quella precedente,
 in una situazione come quella descritta faccio questo controllo:
\end_layout

\begin_layout Enumerate
se la soluzione ottima non contiene il bidone che sto aggiornando, uso quella
\end_layout

\begin_layout Enumerate
se la soluzione ottima contiene il bidone che sto aggiornando, ma ne esiste
 un'altra, allora posso usare l'altra.
\end_layout

\begin_layout Standard
Così, a patto di complicare la struttura dati di supporto, posso gestire
 situazioni come quelle mostrate.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename ../materiali/problemi territoriali/2005_chimico/dinamica-2.eps
	display false
	scale 50

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:Esempio-con-barili-doppi"

\end_inset

Esempio con barili doppi
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
C'è però un altro problema evidenziato dalla figura 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:Esempio-con-barili-doppi"

\end_inset

: ci possono essere più barili con la stessa capacità, quindi se faccio
 un controllo come spiegato al punto 2, nel sottoproblema con due bidoni
 non riuscirei a aggiornare la soluzione con la capacità 6, perchè troverei
 che la soluzione con capacità 3 usa già un bidone della stessa capacità
 e non ha una soluzione alternativa: per risolvere questo problema è stato
 usato un flag che memorizza se lo specifico bidone, al di là della sua
 capacità, è già stato usato un'altra volta e questo permette di gestire
 anche la presenza di casi con barili che si ripetono n-volte.
\end_layout

\begin_layout Standard
Si riporta di seguito solo la parte di codice che si occupa della generazione
 della tabella dinamica, con il dubbio che possa essere utile a qualcuno...
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "basicstyle={\footnotesize\ttfamily},breaklines=true,frame=lr,language={C++},numbers=left,showstringspaces=false,tabsize=4"
inline false
status open

\begin_layout Plain Layout

void costruisci_vettore(nodo *a, int (*cmp)(int,int)) { 	
\end_layout

\begin_layout Plain Layout

	int somma_precedenti = 0;     
\end_layout

\begin_layout Plain Layout

	for (int i=0; i<N;i++){ 		
\end_layout

\begin_layout Plain Layout

		int inizio = bidoni[i].capacita; 		
\end_layout

\begin_layout Plain Layout

		int fine = bidoni[i].capacita + somma_precedenti;         
\end_layout

\begin_layout Plain Layout

		for (int j = inizio; j <= fine; j++) 			
\end_layout

\begin_layout Plain Layout

		if (a[j - bidoni[i].capacita].raggiungibile)
\end_layout

\begin_layout Plain Layout

			{
\end_layout

\begin_layout Plain Layout

				int flag = 0; 				
\end_layout

\begin_layout Plain Layout

				if (cmp(a[j - bidoni[i].capacita].soluzioni[0].quanti + 1,   						a[j].soluzion
i[0].quanti) ||  
\end_layout

\begin_layout Plain Layout

						a[j].soluzioni[0].quanti == 0)
\end_layout

\begin_layout Plain Layout

						{
\end_layout

\begin_layout Plain Layout

							if(a[j-bidoni[i].capacita].soluzioni[0].precedente
\end_layout

\begin_layout Plain Layout

								!= bidoni[i].capacita)
\end_layout

\begin_layout Plain Layout

							{
\end_layout

\begin_layout Plain Layout

								a[j].soluzioni[1] = a[j].soluzioni[0]; 
\end_layout

\begin_layout Plain Layout

								a[j].soluzioni[0].quanti =
\end_layout

\begin_layout Plain Layout

								a[j - bidoni[i].capacita].soluzioni[0].quanti + 1;
\end_layout

\begin_layout Plain Layout

								a[j].soluzioni[0].precedente = bidoni[i].capacita;
\end_layout

\begin_layout Plain Layout

								a[j].raggiungibile = true;
\end_layout

\begin_layout Plain Layout

							} 							 							
\end_layout

\begin_layout Plain Layout

						if((a[j - bidoni[i].capacita].soluzioni[0].precedente ==
\end_layout

\begin_layout Plain Layout

							bidoni[i].capacita &&
\end_layout

\begin_layout Plain Layout

							a[j - bidoni[i].capacita].soluzioni[1].quanti != 0)
\end_layout

\begin_layout Plain Layout

							|| flag == 0) 
\end_layout

\begin_layout Plain Layout

						{
\end_layout

\begin_layout Plain Layout

							if(a[j-bidoni[i].capacita].soluzioni[0].precedente ==
\end_layout

\begin_layout Plain Layout

								bidoni[i].capacita &&
\end_layout

\begin_layout Plain Layout

								a[j - bidoni[i].capacita].soluzioni[1].quanti != 0)
\end_layout

\begin_layout Plain Layout

								{ 									
\end_layout

\begin_layout Plain Layout

									a[j].soluzioni[0].quanti = 
\end_layout

\begin_layout Plain Layout

									a[j - bidoni[i].capacita].soluzioni[1].quanti + 1;
\end_layout

\begin_layout Plain Layout

									a[j].soluzioni[0].precedente = bidoni[i].capacita;
\end_layout

\begin_layout Plain Layout

									a[j].raggiungibile = true; 								
\end_layout

\begin_layout Plain Layout

								} 								
\end_layout

\begin_layout Plain Layout

							else 								 								
\end_layout

\begin_layout Plain Layout

								{ 									
\end_layout

\begin_layout Plain Layout

									a[j].soluzioni[0].quanti = 
\end_layout

\begin_layout Plain Layout

									a[j - bidoni[i].capacita].soluzioni[0].quanti + 1;
\end_layout

\begin_layout Plain Layout

									a[j].soluzioni[0].precedente = bidoni[i].capacita;
\end_layout

\begin_layout Plain Layout

									a[j].raggiungibile = true;
\end_layout

\begin_layout Plain Layout

									flag = 1;
\end_layout

\begin_layout Plain Layout

								} 						
\end_layout

\begin_layout Plain Layout

						} 						
\end_layout

\begin_layout Plain Layout

					} 			
\end_layout

\begin_layout Plain Layout

		}         
\end_layout

\begin_layout Plain Layout

		somma_precedenti += bidoni[i].capacita;     
\end_layout

\begin_layout Plain Layout

	} 
\end_layout

\begin_layout Plain Layout

}  
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Si possono individuare le parti principali:
\end_layout

\begin_layout Itemize

\emph on
for
\emph default
 alla riga 3: scansione di tutti i sottoproblemi di dimensione 
\emph on
i
\end_layout

\begin_layout Itemize
riga 4-5: inizializzazione dell'intervallo di aggiornamento del bidone 
\emph on
i-esimo
\end_layout

\begin_layout Itemize

\emph on
for
\emph default
 alla riga 6: scorrimento l'intervallo appena inizializzato per aggiornare
 la tabella dinamica
\end_layout

\begin_layout Itemize

\emph on
if
\emph default
 alla riga 10: controllo se si otteiene una soluzione migliore o se è la
 prima volta che si esplora la casella
\end_layout

\begin_layout Itemize

\emph on
if
\emph default
 alla riga 13: controllo se la soluzione ottima precedente non contiene
 un bidone con la capacità dell'attuale
\end_layout

\begin_layout Itemize

\emph on
if
\emph default
 alla riga 22: controllo se la soluzione ottima precedente contiene un bidone
 con la capacità dell'attuale, ma c'è un'altra soluzione subottima oppure
 è la prima volta che uso il bidone corrente
\end_layout

\begin_layout Itemize

\emph on
if
\emph default
 alla riga 27 e 
\emph on
else
\emph default
 alla riga 36: distinzione tra i casi gestiti dall'
\emph on
if
\emph default
 precedente, altra soluzione o prima volta che si usa il bidone corrente.
\end_layout

\begin_layout Standard
Può essere interessante notare che, essendo le soluzioni per Aminolazina
 e Brinofulo equivalenti a meno di un controllo, viene passata come parametro
 la funzione che si occupa del controllo (riga 10), in modo da evitare di
 dover scrivere due funzioni esattamente uguali tranne che per una riga.
\end_layout

\begin_layout Standard
Per il resto il codice è simile a quello visto per la soluzione greedy,
 con l'ordinamento iniziale dei bidoni e l'ordinamento successivo dei bidoni
 per stampare la soluzione nell'ordine in cui i bidoni vengono incontrati.
\end_layout

\begin_layout Section
Torero Escamillo - territoriali 2007
\end_layout

\begin_layout Standard
\begin_inset Box Framed
position "t"
hor_pos "c"
has_inner_box 0
inner_pos "t"
use_parbox 0
use_makebox 0
width "100col%"
special "none"
height "1in"
height_special "totalheight"
thickness "0.4pt"
separation "3pt"
shadowsize "4pt"
framecolor "black"
backgroundcolor "none"
status open

\begin_layout Subsection*
Torero Escamillo (torero) 
\end_layout

\begin_layout Subsubsection*
Difficoltà D = 2 (tempo limite 1 sec) 
\end_layout

\begin_layout Subsubsection*
Descrizione del problema
\end_layout

\begin_layout Plain Layout
Il celebre torero Escamillo deve indossare il proprio costume prima di entrare
 nell'arena.
 Egli è costretto a rispettare un dato numero di precedenze, indossando
 certi indumenti prima di altri, mentre alcuni indumenti possono essere
 liberamente indossati in un ordine qualsiasi.
 Per esempio, le "medias" (calze) vanno indossate prima delle "zapatillas"
 (scarpe), ma non vi è alcun vincolo sull'ordine con cui indossare la "chaquetil
la" (giacca) e la "montera" (cappello).
 Il costume di Escamillo è particolarmente raffinato ed elaborato e si compone
 di N indumenti.
 Sfortunatamente, Carmen non ha ancora consegnato uno degli N indumenti
 necessari alla vestizione di Escamillo.
 Aiutalo a vestirsi il più possibile, calcolando il massimo numero di indumenti
 che può indossare in attesa che Carmen gli consegni l'indumento mancante.
 
\end_layout

\begin_layout Subsubsection*
Dati di input
\end_layout

\begin_layout Plain Layout
Il file input.txt contiene nella prima riga una tripla di interi, separati
 da uno spazio: l'intero positivo N che indica il numero di indumenti per
 la vestizione di Escamillo, dove gli indumenti sono numerati da 1 a N;
 l'intero positivo M che indica il numero di precedenze tra coppie di indumenti
 da rispettare durante la vestizione; l'intero Q, compreso tra 1 e N, che
 indica l'indumento non ancora consegnato da Carmen.
 Ognuna delle successive M righe contiene una coppia di interi, compresi
 tra 1 e N, separati da uno spazio.
 Tale coppia di interi I e J rappresenta la precedenza in cui l'indumento
 numero I deve essere indossato prima dell'indumento numero J.
 
\end_layout

\begin_layout Subsubsection*
Dati di output
\end_layout

\begin_layout Plain Layout
Il file output.txt è composto da una riga contenente un solo intero, che
 rappresenta il massimo numero di indumenti che Escamillo riesce a indossare
 in attesa dell'indumento Q che Carmen deve ancora consegnargli.
 
\end_layout

\begin_layout Subsubsection*
Assunzioni
\end_layout

\begin_layout Plain Layout
1 < N < 100000 1 < M < 100000 1 ≤ Q ≤ N
\end_layout

\begin_layout Subsubsection*
Esempi di input/output
\end_layout

\begin_layout Plain Layout
\begin_inset Tabular
<lyxtabular version="3" rows="2" columns="2">
<features tabularvalignment="middle">
<column alignment="center" valignment="top" width="1in">
<column alignment="left" valignment="top">
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
File input.txt
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
File output.txt
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\align left
4 5 3 
\end_layout

\begin_layout Plain Layout
\align left
1 3 
\end_layout

\begin_layout Plain Layout
\align left
1 4 
\end_layout

\begin_layout Plain Layout
\align left
3 2 
\end_layout

\begin_layout Plain Layout
\align left
3 4 
\end_layout

\begin_layout Plain Layout
\align left
4 2 
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
1 
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Suggerimenti
\end_layout

\begin_layout Standard
Il problema, di semplice comprensione, chiede di individuare in una serie
 di regole di precedenza, quelle che vengono implicate una volta che una
 di esse viene a mancare.
\end_layout

\begin_layout Itemize
Qual è la struttura dati appropriata per rappresentare la struttura dei
 dati in input (in particolre qual è l'elemento che dovrebbe condurre subito
 a individuare quella corretta)?
\end_layout

\begin_layout Itemize
Supponendo che tu abbia risposto 
\begin_inset Quotes eld
\end_inset

Un grafo!
\begin_inset Quotes erd
\end_inset

 alla domanda precedente (che fra l'altro è la risposta corretta) puoi pensare
 se saresti in grado di usare un vettore per rappresentarlo (magari un vettore
 di strutture)?
\end_layout

\begin_layout Itemize
Che struttura useresti per rappresentare una regola di precedenza?
\end_layout

\begin_layout Itemize
Se ordini il vettore delle regole di precedenza e continui a ciclare su
 di esso togliendo di volta in volta le regole che non possono essere soddisfatt
e, hai la sicurezza di arrivare alla soluzione del problema? Quand'è che
 ti devi fermare? É importante ordinare il vettore prima di ciclare su di
 esso o è indifferente?
\end_layout

\begin_layout Itemize
Siccome le dimensioni dell'input sono dell'ordine di n=100000 sia nel numero
 di nodi (i vestiti) che nel numero di archi (le regole di precedenza) qual
 è la massima complessità computazionale accettabile dell'algoritmo risolutivo?
\end_layout

\begin_layout Itemize
Indipendentemente dal tipo di soluzione che intendi adottare, sei in grado
 di garantire che la complessità sia di tipo lineare?
\end_layout

\begin_layout Subsection
Soluzione
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "basicstyle={\small\ttfamily},breaklines=true,frame=lr,language={C++},numbers=left,showstringspaces=false,tabsize=4"
inline false
status open

\begin_layout Plain Layout

struct indumento{ 	
\end_layout

\begin_layout Plain Layout

	bool indossabile; 	
\end_layout

\begin_layout Plain Layout

	vector<int> lista; 	
\end_layout

\begin_layout Plain Layout

	indumento():indossabile(true){} 
\end_layout

\begin_layout Plain Layout

};
\end_layout

\begin_layout Plain Layout

int N,M,Q,non_indossabili; 
\end_layout

\begin_layout Plain Layout

indumento indumenti[100000]; 
\end_layout

\begin_layout Plain Layout

void propaga(int n) { 	
\end_layout

\begin_layout Plain Layout

	if (indumenti[n].indossabile == false) return; 
\end_layout

\begin_layout Plain Layout

	indumenti[n].indossabile = false;	
\end_layout

\begin_layout Plain Layout

	non_indossabili++;
\end_layout

\begin_layout Plain Layout

	for (int j = 0; j < indumenti[n].lista.size(); j++)
\end_layout

\begin_layout Plain Layout

		propaga(indumenti[n].lista[j]); 	 
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

int main(int argc, char** argv) 
\end_layout

\begin_layout Plain Layout

{ 	
\end_layout

\begin_layout Plain Layout

	ifstream in("input.txt"); 	
\end_layout

\begin_layout Plain Layout

	ofstream out("output.txt"); 	
\end_layout

\begin_layout Plain Layout

	in >> N >> M >> Q; 	
\end_layout

\begin_layout Plain Layout

	for (int i=0; i < M; i++) { 		
\end_layout

\begin_layout Plain Layout

		int r,s; 		
\end_layout

\begin_layout Plain Layout

		in >> r >> s; 		
\end_layout

\begin_layout Plain Layout

		indumenti[r].lista.push_back(s); 	
\end_layout

\begin_layout Plain Layout

	} 
\end_layout

\begin_layout Plain Layout

	propaga(Q); 	
\end_layout

\begin_layout Plain Layout

	out << N - non_indossabili << endl; 	
\end_layout

\begin_layout Plain Layout

	return 0; 
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Anche in questo caso un'opportuna scelta della struttura dati e un procedimento
 ricorsivo ci permettono di arrivare velocemente alla soluzione
\begin_inset Foot
status collapsed

\begin_layout Plain Layout
Alla data della stesura di questo paragrafo, nonostante una serie di prove
 che inducono a pensare che la soluzione sia corretta, il correttore ufficiale
 indica che tutte i casi di test producono risposte sbagliate.
 L'impressione è che siano sbagliati i casi del correttore, oppure mi sfugga
 qualcosa di essenziale nella comprensione del test.
 Successive versioni di questo manuale potranno risolvere la questione.
\end_layout

\end_inset

.
 Il fatto che il grafo sia la struttura più adatta è evidente dalla non
 linearità delle relazioni tra vestiti, per cui uno stesso vestito può essere
 necessario per indossare altri vestiti e a sua volta abbia bisogno di altri
 vestiti per poter essere indossato.
 Alle righe 1-5 viene definita la struttura che rappresenta un indumento,
 dove la variabile booleana 
\emph on
indossabile
\emph default
 (settata a 
\emph on
true
\emph default
 dal costruttore) indica se quell'indumento è indossabile e un vettore di
 interi che contiene gli indumenti che devono essere indossati dopo questo.
 In questa soluzione è stato usato un 
\emph on
vector
\emph default
 al posto della 
\emph on
list
\emph default
 già usata in altre soluzioni per mostrare che, nella rappresentazione di
 questo tipo di problemi, di fatto non ci sono differenze significative
 e la sintassi nella scansione di un vettore potrebbe risultare più naturale
 a chi è abituato ad utilizzare il C.
 La lettura e l'inserimento dei dati (righe 17-24) è molto semplice, poichè
 si usa l'indice del vettore degli indumenti come numero dell'indumento
 e si aggiungono in 
\emph on
lista
\emph default
 gli indumenti di cui esso è precedenza.
\end_layout

\begin_layout Standard
A questo punto la funzione ricorsiva 
\emph on
propaga
\emph default
 non deve far altro che una visita (in profondità o in ampiezza è in questo
 caso indifferente) del grafo ottenuto partendo dal nodo che rappresenta
 l'indumento mancante: la visita si concluderà dopo che tutte le precedenze
 sono state propagate e alcuni nodi potrebbero rimanerne esclusi, ma in
 questo caso non si prosegue con la visita in quanto essi sono proprio l'insieme
 degli indumenti indossabili, perchè nessuna regola di precedenza li riguarda.
 Siccome il problema chiedeva la loro quantità, è stata usata la variabile
 globale 
\emph on
non_indossabili
\emph default
, incrementata ogni volta che un indumento si aggiungeva all'insieme degli
 elementi non indossabili durante l'esplorazione (riga 11), per ottenere
 come differenza il numero di indumenti indossabili.
\end_layout

\begin_layout Standard
A questo punto ci si potrebbe domandare se la soluzione proposta rientra
 nei vincoli di complessità imposti dalle dimensioni dell'input del problema,
 dal momento che, come sappiamo, alcuni algoritmi ricorsivi possono comportare
 costi di tipo esponenziale: in questo caso invece è evidente che l'algoritmo
 è lineare nel numero di nodi, dal momento che una volta che un nodo risulta
 visitato viene escluso da eventuali visite successive e quindi ogni nodo
 verrà visitato al più una volta.
\end_layout

\begin_layout Section
Codici e pizzini - territoriali 2008
\end_layout

\begin_layout Standard
\begin_inset Box Framed
position "t"
hor_pos "c"
has_inner_box 0
inner_pos "t"
use_parbox 0
use_makebox 0
width "100col%"
special "none"
height "1in"
height_special "totalheight"
thickness "0.4pt"
separation "3pt"
shadowsize "4pt"
framecolor "black"
backgroundcolor "none"
status collapsed

\begin_layout Subsection*
Codici e pizzini (pizzini) 
\end_layout

\begin_layout Subsubsection*
Difficoltà D = 1.
 
\end_layout

\begin_layout Subsubsection*
Descrizione del problema
\end_layout

\begin_layout Plain Layout
Il Commissario Basettoni è riuscito a localizzare il nascondiglio del pericoloso
 Gambadilegno.
 Facendo irruzione nel covo, Basettoni trova una serie di foglietti (detti
 "pizzini") che riportano, cifrati, i codici di accesso ai conti correnti
 del gruppo di malavitosi capeggiato da Gambadilegno.
\end_layout

\begin_layout Plain Layout
Il Commissario Basettoni chiede aiuto a Topolino per interpretare questi
 pizzini.
 Dopo approfondite analisi, Topolino scopre le seguenti cose:
\end_layout

\begin_layout Itemize
ogni pizzino contiene N righe e ciascuna riga è una sequenza di cifre decimali
 ('0', '1', ..., '9') concatenate senza spazi intermedi (quindi la sequenza
 0991, come tale, non va interpretata come il numero 991); 
\end_layout

\begin_layout Itemize
ogni pizzino riporta, cifrato, un codice di accesso a N cifre; 
\end_layout

\begin_layout Itemize
tale codice si ottiene concatenando una dopo l'altra, senza spazi intermedi,
 le cifre estratte dalle N sequenze scritte nel pizzino, più precisamente,
 una cifra per ogni sequenza; 
\end_layout

\begin_layout Itemize
la cifra da estrarre per ciascuna sequenza è quella in posizione p, dove
 p è il numero di anagrammi che, per tale sequenza, appaiono nel pizzino.
\end_layout

\begin_layout Plain Layout
Un anagramma di una sequenza S è ottenuto permutando le sue cifre (per esempio,
 1949 e 9419 sono anagrammi); inoltre, S è anagramma di se stessa.
 Quindi Topolino deduce che, per calcolare il numero p di anagrammi di S,
 deve includere S tra i suoi anagrammi contenuti nel pizzino.
 In questo modo, p = 1 indica che una sequenza non ha altri anagrammi, a
 parte se stessa, per cui va estratta la sua prima cifra.
\end_layout

\begin_layout Plain Layout
Per illustrare quanto descritto sopra a Basettoni, Topolino prende un pizzino
 che contiene i tre anagrammi 1949, 9419 e 9149 (e non ce ne sono altri)
 e ne estrae la loro terza cifra, ossia 4, 1 e 4, poiché p = 3; poi, prende
 un altro pizzino con due soli anagrammi 1949 e 9419, estraendone la seconda
 cifra, ossia 9 e 4, poiché p = 2.
 Utilizzando questo meccanismo di estrazione delle cifre, aiutate Topolino
 a decifrare i pizzini di Gambadilegno trovati da Basettoni.
 
\end_layout

\begin_layout Subsubsection*
Dati di input
\end_layout

\begin_layout Plain Layout
Il file input.txt è composto da N+1 righe.
\end_layout

\begin_layout Plain Layout
La prima riga contiene un intero positivo che rappresenta il numero N di
 sequenze contenute nel pizzino.
\end_layout

\begin_layout Plain Layout
Ciascuna delle successive N righe contiene una sequenza di cifre decimali
 ('0', '1', ..., '9') senza spazi intermedi.
 
\end_layout

\begin_layout Subsubsection*
Dati di output
\end_layout

\begin_layout Plain Layout
Il file output.txt è composto da una sola riga contenente una sequenza di
 N cifre decimali, senza spazi intermedi, ossia il codice di accesso cifrato
 nel pizzino.
\end_layout

\begin_layout Subsubsection*
Assunzioni
\end_layout

\begin_layout Itemize
1 ≤ N ≤ 100.
 
\end_layout

\begin_layout Itemize
Ogni sequenza contiene al massimo 80 cifre decimali.
 
\end_layout

\begin_layout Itemize
Le sequenze contenute in uno stesso pizzino sono tutte diverse tra di loro.
\end_layout

\begin_layout Itemize
Una sequenza di K cifre decimali presenta al massimo K anagrammi in uno
 stesso pizzino.
 Inoltre, tali anagrammi non necessariamente appaiono in righe consecutive
 del pizzino.
\end_layout

\begin_layout Subsubsection*
Esempi di input/output
\end_layout

\begin_layout Plain Layout
\begin_inset Tabular
<lyxtabular version="3" rows="2" columns="2">
<features tabularvalignment="middle">
<column alignment="left" valignment="top" width="1in">
<column alignment="left" valignment="top">
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
File input.txt
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
File output.txt
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
6 
\end_layout

\begin_layout Plain Layout
1949 
\end_layout

\begin_layout Plain Layout
21 
\end_layout

\begin_layout Plain Layout
9419 
\end_layout

\begin_layout Plain Layout
12 
\end_layout

\begin_layout Plain Layout
4356373
\end_layout

\begin_layout Plain Layout
9149
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
411244
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Suggerimenti
\end_layout

\begin_layout Standard
Il problema chiede di estrarre da una serie di stringhe una cifra secondo
 le regole spiegate nel testo.
\end_layout

\begin_layout Standard
Leggendo il testo ti è subito chiara qual è la regola da applicare per estrarre
 il messaggio dai pizzini? 
\end_layout

\begin_layout Standard
Qual è la struttura dati più adatta per contenere le singole cifre che compongon
o i pizzini (attenzione che ogni riga, pur contenendo cifre decimali, non
 rappresenta un numero decimale)? Se volessi usare una variabile intera
 per memorizzare una singola cifra, quali problemi avresti (leggere bene
 le assunzioni)?
\end_layout

\begin_layout Standard
Sei in grado di leggere le singole righe come stringhe?
\end_layout

\begin_layout Standard
Come faccio a controllare se due stringhe sono l'una l'anagramma dell'altra?
 Devo scorrere la prima stringa e per ogni lettera vedere se esiste nella
 seconda?
\end_layout

\begin_layout Standard
Esiste un modo più rapido e efficace di quello proposto sopra?
\end_layout

\begin_layout Subsection
Soluzione
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "basicstyle={\small\ttfamily},breaklines=true,frame=lr,language={C++},numbers=left,showstringspaces=false,tabsize=4"
inline false
status open

\begin_layout Plain Layout

struct riga{ 	
\end_layout

\begin_layout Plain Layout

	int numero_anagrammi; 	
\end_layout

\begin_layout Plain Layout

	string valore; 	
\end_layout

\begin_layout Plain Layout

	Riga():numero_anagrammi(0){} 
\end_layout

\begin_layout Plain Layout

};
\end_layout

\begin_layout Plain Layout

riga righe[100]; 
\end_layout

\begin_layout Plain Layout

string ordinate[100];
\end_layout

\begin_layout Plain Layout

int main() 
\end_layout

\begin_layout Plain Layout

{ 	
\end_layout

\begin_layout Plain Layout

	fstream in, out; 	
\end_layout

\begin_layout Plain Layout

	in.open("input.txt",ios::in); 	out.open("output.txt",ios::out); 	
\end_layout

\begin_layout Plain Layout

	in >> N; 	
\end_layout

\begin_layout Plain Layout

	for (int i=0;i< N;i++) 	
\end_layout

\begin_layout Plain Layout

	{ 		
\end_layout

\begin_layout Plain Layout

		in >> righe[i].valore; 		
\end_layout

\begin_layout Plain Layout

		ordinate[i] = righe[i].valore;
\end_layout

\begin_layout Plain Layout

		sort(ordinate[i].begin(), ordinate[i].end()); 	
\end_layout

\begin_layout Plain Layout

	} 	
\end_layout

\begin_layout Plain Layout

	for (int i=0;i< N;i++) 		
\end_layout

\begin_layout Plain Layout

		for (int j=0;j< N;j++) 			 
\end_layout

\begin_layout Plain Layout

			if (ordinate[i]==ordinate[j])
\end_layout

\begin_layout Plain Layout

				 righe[j].numero_anagrammi++; 	
\end_layout

\begin_layout Plain Layout

	for (int i=0;i< N;i++) 		
\end_layout

\begin_layout Plain Layout

		out << righe[i].valore.at(righe[i].numero_anagrammi-1);
\end_layout

\begin_layout Plain Layout

	return 0; 
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
La parte fondamentale è quella che ci permette di verificare quando due
 stringhe sono una l'anagramma dell'altra.
 Per esperienza con gli studenti la prima idea in genere è quella di scorrere
 la prima stringa carattere per carattere e vedere se ogni carattere è anche
 presente nella seconda, eliminandoli di volta in volta in modo da non usare
 lo stesso carattere più volte.
 Quest'idea, non difficile ma nemmeno banale da implementare, richiede una
 certa attenzione per evitare piccoli errori che potrebbero invalidare il
 resto del programma.
 Un'idea decisamente migliore, simile a quella presente nella soluzione
 del problema 
\begin_inset Quotes eld
\end_inset

Teste di serie
\begin_inset Quotes erd
\end_inset

 (vedi paragrafo 
\begin_inset CommandInset ref
LatexCommand ref
reference "sec:Esempio:Serie"

\end_inset

), è quella di ordinare le stringhe: così facendo otteniamo per ogni stringa
 una 
\begin_inset Quotes eld
\end_inset

firma
\begin_inset Quotes erd
\end_inset

, che è composta dalle lettere ordinate e di conseguenza due stringhe sono
 anagrammi l'una dell'altra se presentano la stessa 
\begin_inset Quotes eld
\end_inset

firma
\begin_inset Quotes erd
\end_inset

.
 Questo approccio ha almeno due vantaggi:
\end_layout

\begin_layout Itemize
possiamo usare la funzione di libreria 
\emph on
sort
\emph default
 per ordinare scrivendo in questo modo una sola riga di codice, sicuramente
 corretto.
\end_layout

\begin_layout Itemize
l'ordinamento con la funzione 
\emph on
sort
\emph default
 è decisamente più veloce della prima idea sui confronti delle lettere (compless
ità 
\begin_inset Formula $NlogN$
\end_inset

 contro 
\begin_inset Formula $N^{2}$
\end_inset

)
\end_layout

\begin_layout Standard
Tutto quello che segue a questo punto risulta piuttosto ovvio: si procede
 a confrontare ogni stringa ordinata con ogni altra stringa (i due cicli
 
\emph on
for
\emph default
 alle righe 19-20) e ogni volta che si incontra una corrispondenza si incrementa
 il contatore degli anagrammi contenuto nella struttura riga, in modo che
 alla fine ogni riga contenga quante volte essa è l'anagramma di altre righe
 (se la riga non è anagramma di nessun altra comunque il contatore verrà
 incrementato una volta quando la riga viene confrontata con se stessa).
\end_layout

\begin_layout Standard
A questo punto basta scorrere tutte le righe ed estrarre la cifra nella
 posizione indicata dal numero di anagrammi, ricordandosi di sottrarre 1
 all'indice della stringa (riga 24), poichè l'indice di stringa parte da
 0 e il numero di anagrammi parte invece da 1.
\end_layout

\begin_layout Standard
In questo caso il problema della complessità computazionale non sembra determina
nte, in quanto le stringhe in input sono al massimo 100.
 Un calcolo approssimativo del costo indica che l'ordinamento iniziale ha
 un costo di tipo 
\begin_inset Formula $NLlogL$
\end_inset

, con L lunghezza della stringa da ordinare, poiché abbiamo N stringhe da
 ordinare e il costo dell'ordinamento abbiamo già detto essere quello del
 
\emph on
sort
\emph default
, mentre i cicli di confronto hanno un costo di tipo 
\begin_inset Formula $N^{2}L$
\end_inset

, dove la componente quadratica è dovuta ai due cicli e quella lineare in
 L al costo del confronto tra stringhe.
 Anche con i valori massimi di N e L si vede quindi che il costo totale
 non arriva al milione di operazioni e quindi abbondantemente entro i limiti.
\end_layout

\begin_layout Section
Essenza di profumi - territoriali 2009
\end_layout

\begin_layout Standard
\begin_inset Box Framed
position "t"
hor_pos "c"
has_inner_box 0
inner_pos "t"
use_parbox 0
use_makebox 0
width "100col%"
special "none"
height "1in"
height_special "totalheight"
thickness "0.4pt"
separation "3pt"
shadowsize "4pt"
framecolor "black"
backgroundcolor "none"
status collapsed

\begin_layout Subsection*
Essenza per profumi (essenza) 
\end_layout

\begin_layout Subsubsection*
Difficoltà D = 1.
 
\end_layout

\begin_layout Subsubsection*
Descrizione del problema
\end_layout

\begin_layout Plain Layout
L'essenza di un fiore raro è molto ricercata tra i profumieri.
 Il prezzo di mercato viene fissato giornalmente dal CGE, il Consorzio dei
 Grossisti di Essenze.
 Inoltre, essendo di natura organica, l'essenza acquistata da un profumiere
 deperisce dopo un certo periodo e quindi può essere rivenduta soltanto
 entro K giorni dall'acquisto (data di scadenza).
\end_layout

\begin_layout Plain Layout
Un profumiere è venuto a conoscenza del prezzo di mercato dell'essenza che
 il CGE prevede per i prossimi N giorni (N ≥ K), per semplicità numerati
 da 1 a N.
 Ritenendo molto affidabili le previsioni del CGE, il profumiere intende
 comprare una certa quantità di essenza il giorno i per rivenderla il giorno
 j, tenendo presente però che non può andare oltre la data di scadenza (quindi
 deve essere i ≤ j ≤ i+K).
 Il profumiere intende fare un solo acquisto e una sola vendita successiva
 all'acquisto.
\end_layout

\begin_layout Plain Layout
Aiutate il profumiere a calcolare il massimo guadagno che può ottenere,
 calcolato come la differenza tra il prezzo dell'essenza al giorno j e quello
 al giorno i.
 Notate che è permesso scegliere j=i: in questo modo, anche se il prezzo
 di mercato dell'essenza fosse in discesa per tutto il periodo considerato,
 sarebbe possibile evitare perdite.
 
\end_layout

\begin_layout Subsubsection*
Dati di input
\end_layout

\begin_layout Plain Layout
Il file input.txt è composto da due righe.
\end_layout

\begin_layout Plain Layout
La prima riga contiene due interi positivi separati da uno spazio, rispettivamen
te il numero K di giorni per la data di scadenza e il numero N di prossimi
 giorni.
\end_layout

\begin_layout Plain Layout
La seconda riga contiene N interi positivi separati da uno spazio, i quali
 rappresentano il prezzo di vendita dell'essenza nei prossimi N giorni.
 
\end_layout

\begin_layout Subsubsection*
Dati di output
\end_layout

\begin_layout Plain Layout
Il file output.txt è composto da una sola riga contenente un intero che rappresen
ta il massimo guadagno del profumiere, con le regole descritte sopra.
 
\end_layout

\begin_layout Subsubsection*
Assunzioni
\end_layout

\begin_layout Plain Layout
1 ≤ N ≤ 1000, 1 ≤ K ≤ N .
\end_layout

\begin_layout Subsubsection*
Esempi di input/output
\end_layout

\begin_layout Plain Layout
\begin_inset Tabular
<lyxtabular version="3" rows="2" columns="2">
<features tabularvalignment="middle">
<column alignment="left" valignment="top" width="1in">
<column alignment="left" valignment="top">
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
File input.txt
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
File output.txt
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
2 6 
\end_layout

\begin_layout Plain Layout
3 6 2 6 9 6
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
7
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Suggerimenti 
\end_layout

\begin_layout Standard
Il problema si riduce alla ricerca di un intervallo all'interno di un vettore
 la cui differenza dei valori agli estremi sia massima.
 
\end_layout

\begin_layout Itemize
Sai trovare la differenza tra due valori distanti una sola posizione all'interno
 di un vettore? 
\end_layout

\begin_layout Itemize
Puoi fare la stessa cosa per i tutti gli intervalli di distanza uno e trovare
 quale differenza tra gli estremi dell'intervallo è massima? 
\end_layout

\begin_layout Itemize
Se l'intervallo al posto di avere distanza 1 avesse distanza K come modificheres
ti il programma precedente? 
\end_layout

\begin_layout Itemize
Se vuoi controllare partendo dal primo elemento del vettore tutte le differenze
 da uno fino a K cosa devi usare? 
\end_layout

\begin_layout Itemize
Puoi riapplicare lo stesso principio a differenze "mobili", cioè in cui
 al posto di partire dal primo elemento del vettore parti da quello in posizione
 
\emph on
i
\emph default
? 
\end_layout

\begin_layout Itemize
Se hai seguito le idee presentate dovresti essere arrivato a una soluzione
 meccanica del problema, di complessità 
\begin_inset Formula $KN$
\end_inset

.
 Anche se in questo problema non è necessario, riusciresti a trovare un'altra
 idea completamente diversa che possa far diminuire il costo? 
\end_layout

\begin_layout Subsection
Soluzione 
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "basicstyle={\small\ttfamily},breaklines=true,frame=lr,language={C++},numbers=left,showstringspaces=false,tabsize=4"
inline false
status collapsed

\begin_layout Plain Layout

int K,N; 
\end_layout

\begin_layout Plain Layout

int vettore[1000];
\end_layout

\begin_layout Plain Layout

int main() 
\end_layout

\begin_layout Plain Layout

{ 	
\end_layout

\begin_layout Plain Layout

	ifstream in("input.txt"); 	
\end_layout

\begin_layout Plain Layout

	ofstream out("output.txt"); 	
\end_layout

\begin_layout Plain Layout

	in >> K >> N; 	
\end_layout

\begin_layout Plain Layout

	for (int i=0; i<N; i++) 		
\end_layout

\begin_layout Plain Layout

		in >> vettore[i]; 	
\end_layout

\begin_layout Plain Layout

	int max=0; 	
\end_layout

\begin_layout Plain Layout

	for (int i=0; i<N; i++) 		
\end_layout

\begin_layout Plain Layout

		for (int j=0; j<=K; j++) 			
\end_layout

\begin_layout Plain Layout

			if (i+j<N && vettore[i+j] - vettore[i] > max)
\end_layout

\begin_layout Plain Layout

				max = vettore[i+j] - vettore[i]; 	
\end_layout

\begin_layout Plain Layout

		out << max << endl; 	
\end_layout

\begin_layout Plain Layout

	return 0; 
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Standard

\end_layout

\begin_layout Standard
La soluzione più ovvia di questo problema è piuttosto banale: dopo aver
 letto tutte quotazioni delle essenze e averle messe in un vettore, si scorrono
 tutti i giorni in cui può essere acquistata l'essenza (ciclo esterno alla
 riga 11) e si prova a fare la differenza con i valori nei giorni successivi
 fino a un massimo di K giorni, stando anche attenti a non uscire dal vettore.
 É interessante notare che il controllo sulla non uscita dal vettore (
\begin_inset Formula $i+j<N$
\end_inset

) deve essere messo in  
\emph on
AND
\emph default
 come primo termine, in modo che se non fosse verificato non verrà eseguito
 il secondo controllo, che contenendo una lettura del vettore alla posizione
 
\begin_inset Formula $i+j$
\end_inset

, potrebbe far terminare il programma nel caso di lettura esterna ai limiti.
\end_layout

\begin_layout Standard
Essendo la ricerca di un massimo, ci sarà una variabile per contenere il
 nuovo massimo che viene trovato e che inizialmente vale 0 per indicare
 che, nel caso peggiore, sarà comunque possibile avere un guadagno 0.
 Come detto nei suggerimenti, questo approccio ha un costo 
\begin_inset Formula $KN$
\end_inset

 e se i due valori sono paragonabili diventa di tipo quadratico.
 
\end_layout

\begin_layout Section
Treno di container - territoriali 2009
\end_layout

\begin_layout Standard
\begin_inset Box Framed
position "t"
hor_pos "c"
has_inner_box 0
inner_pos "t"
use_parbox 0
use_makebox 0
width "100in"
special "width"
height "1in"
height_special "totalheight"
thickness "0.4pt"
separation "3pt"
shadowsize "4pt"
framecolor "black"
backgroundcolor "none"
status collapsed

\begin_layout Subsection*
Treno di container (treno) 
\end_layout

\begin_layout Subsubsection*
Difficoltà D = 2.
 
\end_layout

\begin_layout Subsubsection*
Descrizione del problema
\end_layout

\begin_layout Plain Layout
Al porto sono arrivati N container della sostanza chimica di tipo A e N
 container della sostanza chimica di tipo B.
 I container sono stati caricati, uno dietro l'altro, su di un treno che
 ne può contenere 2N+2.
 Le posizioni dei container sul treno sono numerate da 1 a 2N+2.
 Il carico è stato fatto in modo che gli N container di tipo A occupino
 le posizioni da 1 a N, mentre quelli di tipo B da N+1 a 2N; le rimanenti
 due posizioni 2N+1 e 2N+2 sono vuote.
\end_layout

\begin_layout Plain Layout
Per motivi connessi all'utilizzo delle sostanze chimiche nella fabbrica
 alla quale sono destinate, i container vanno distribuiti sul treno a coppie:
 ciascun container per la sostanza di tipo A deve essere seguito da uno
 di tipo B.
 Occorre quindi che nelle posizioni dispari (1, 3, 5, ..., 2N-1) vadano sistemati
 esclusivamente i container di tipo A mentre in quelle pari (2, 4, 6, ...,
 2N) quelli di tipo B, lasciando libere le ultime due posizioni 2N+1 e 2N+2.
\end_layout

\begin_layout Plain Layout
A tal fine, viene impiegata una grossa gru, che preleva due container alla
 volta, in posizioni consecutive i, i+1, e li sposta nelle uniche due posizioni
 consecutive j, j+1 libere nel treno (inizialmente, j = 2N+1).
 Tale operazione è univocamente identificata dalla coppia (i,j), dove entrambe
 le posizioni i e i+1 devono essere occupate da container mentre j e j+1
 devono essere entrambe vuote.
\end_layout

\begin_layout Plain Layout
Per esempio, con N = 4, abbiamo inizialmente la configurazione A A A A B
 B B B * *, dove le due posizioni vuote sono indicate da un asterisco *:
\end_layout

\begin_layout Itemize
Il primo spostamento della gru è (4,9) e porta alla configurazione:
\begin_inset Separator latexpar
\end_inset


\end_layout

\begin_deeper
\begin_layout Plain Layout

\family typewriter
A A A * * B B B A B
\end_layout

\begin_layout Plain Layout

\family typewriter
1 2 3 4 5 6 7 8 9 10 
\end_layout

\end_deeper
\begin_layout Itemize
Il secondo spostamento è (6, 4) e porta alla configurazione:
\begin_inset Separator latexpar
\end_inset


\end_layout

\begin_deeper
\begin_layout Plain Layout

\family typewriter
A A A B B * * B A B
\end_layout

\begin_layout Plain Layout

\family typewriter
1 2 3 4 5 6 7 8 9 10 
\end_layout

\end_deeper
\begin_layout Itemize
Il terzo spostamento è (2, 6) e porta alla configurazione:
\begin_inset Separator latexpar
\end_inset


\end_layout

\begin_deeper
\begin_layout Plain Layout

\family typewriter
A * * B B A A B A B
\end_layout

\begin_layout Plain Layout

\family typewriter
1 2 3 4 5 6 7 8 9 10 
\end_layout

\end_deeper
\begin_layout Itemize
Il quarto spostamento è (5,2) e porta alla configurazione:
\begin_inset Separator latexpar
\end_inset


\end_layout

\begin_deeper
\begin_layout Plain Layout

\family typewriter
A B A B * * A B A B
\end_layout

\begin_layout Plain Layout

\family typewriter
1 2 3 4 5 6 7 8 9 10
\family default
 
\end_layout

\end_deeper
\begin_layout Itemize
Il quinto e ultimo spostamento è (9,5) e porta alla configurazione desiderata:
\begin_inset Separator latexpar
\end_inset


\end_layout

\begin_deeper
\begin_layout Plain Layout

\family typewriter
A B A B A B A B * *
\end_layout

\begin_layout Plain Layout

\family typewriter
1 2 3 4 5 6 7 8 9 10
\end_layout

\end_deeper
\begin_layout Plain Layout
Notare che per N=4 è possibile, con cinque spostamenti, sistemare i 2N container
 nell'ordine giusto.
 Scrivere quindi un programma che determini la successione degli spostamenti
 eseguiti dalla gru per ottenere un analogo risultato nel caso in cui 3
 ≤ N ≤ 1000.
 Si richiede inoltre che il numero K di tali spostamenti non superi il valore
 3N.
 
\end_layout

\begin_layout Subsubsection*
Dati di input
\end_layout

\begin_layout Plain Layout
Il file input.txt è composto da una sola riga, contenente l'intero N che
 rappresenta il numero di container per ciascuna delle due sostanze.
 
\end_layout

\begin_layout Subsubsection*
Dati di output
\end_layout

\begin_layout Plain Layout
Il file output.txt è composto da K+1 righe.
\end_layout

\begin_layout Plain Layout
La prima riga contiene due interi positivi separati da uno spazio, rispettivamen
te il numero K di spostamenti operati dalla gru e il numero N di container
 per ciascuna delle due sostanze
\end_layout

\begin_layout Plain Layout
Le righe successive contengono la sequenza di K spostamenti del tipo (i,j),
 tali che partendo dalla sequenza AAA...ABBB...B**, si arrivi alla sequenza ABABAB...AB**
 con le regole descritte sopra.
 Ciascuna delle righe contiene una coppia di interi positivi i e j separati
 da uno spazio a rappresentare lo spostamento (i,j).
 
\end_layout

\begin_layout Subsubsection*
Assunzioni
\end_layout

\begin_layout Plain Layout
3 ≤ N ≤ 1000, 1 ≤ i,j ≤ 2N+1, K ≤ 3 N.
\end_layout

\begin_layout Subsubsection*
Esempi di input/output
\end_layout

\begin_layout Plain Layout
\begin_inset Tabular
<lyxtabular version="3" rows="2" columns="2">
<features tabularvalignment="middle">
<column alignment="left" valignment="top">
<column alignment="left" valignment="top" width="1in">
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
File input.txt
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
File output.txt
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
3
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
4 3 
\end_layout

\begin_layout Plain Layout
2 7 
\end_layout

\begin_layout Plain Layout
6 2 
\end_layout

\begin_layout Plain Layout
4 6 
\end_layout

\begin_layout Plain Layout
7 4 
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Suggerimenti
\end_layout

\begin_layout Standard
Si tratta di modificare le posizioni degli elementi in un vettore per raggiunger
e una particolare configurazione finale utilizzando regole prestabilite.
\end_layout

\begin_layout Itemize
Qual è la struttura dati adatta (attenzione perchè la risposta più ovvia
 è sbagliata)?
\end_layout

\begin_layout Itemize
Hai realmente bisogno di un vettore?
\end_layout

\begin_layout Itemize
Se usi un vettore, sei capace di spostare coppie di elementi da un punto
 all'altro?
\end_layout

\begin_layout Itemize
Se non usi un vettore, cosa ti interessa realmente?
\end_layout

\begin_layout Itemize
Riesci a ridurre il problema in un problema uguale a quello di partenza,
 solo di dimensione inferiore?
\end_layout

\begin_layout Subsection
Soluzione
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "basicstyle={\small\ttfamily},breaklines=true,frame=lr,language={C++},numbers=left,showstringspaces=false,tabsize=4"
inline false
status collapsed

\begin_layout Plain Layout

int K,N; 
\end_layout

\begin_layout Plain Layout

ifstream in("input.txt"); 
\end_layout

\begin_layout Plain Layout

ofstream out("output.txt");
\end_layout

\begin_layout Plain Layout

void calcola(int j) {     
\end_layout

\begin_layout Plain Layout

	if (j==10){ 	
\end_layout

\begin_layout Plain Layout

		out << (j-2)/2 << " " << j-1 << endl; 		
\end_layout

\begin_layout Plain Layout

		return; 	
\end_layout

\begin_layout Plain Layout

	}     
\end_layout

\begin_layout Plain Layout

	out << (j-2)/2 << " " << j-1 << endl;     
\end_layout

\begin_layout Plain Layout

	out << j-3 << " " << (j-2)/2 << endl; 	
\end_layout

\begin_layout Plain Layout

	calcola(j-2); 
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

int main() 
\end_layout

\begin_layout Plain Layout

{ 	
\end_layout

\begin_layout Plain Layout

	in >> N; 	
\end_layout

\begin_layout Plain Layout

	K = 2*N-3; 	
\end_layout

\begin_layout Plain Layout

	out << K << " " << N << endl; 	
\end_layout

\begin_layout Plain Layout

	calcola(2*N+2); 	
\end_layout

\begin_layout Plain Layout

	out << 6 << " " << 4 << endl; 	
\end_layout

\begin_layout Plain Layout

	out << 2 << " " << 6 << endl; 	
\end_layout

\begin_layout Plain Layout

	out << 5 << " " << 2 << endl; 	
\end_layout

\begin_layout Plain Layout

	out << 2*N+1 << " " << 5 << endl; 	
\end_layout

\begin_layout Plain Layout

	return 0; 
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Siccome non è così evidente quale sia il punto d'attacco del problema e
 l'esempio che viene mostrato penso sia di proposito elusivo, bisogna cercare
 di vedere se sono presenti delle regolarità e nel caso sfruttarle per arrivare
 alla soluzione.
 Guardando l'esempio
\begin_inset Foot
status collapsed

\begin_layout Plain Layout
Personalmente ho utilizzato dei bigliettini contrassegnati con le lettere
 A e B e gli asterischi, per poter visualizzare meglio gli spostamenti e
 verificare la correttezza di quanto pensato.
\end_layout

\end_inset

 si può vedere che esiste già una coppia di vagoni di tipo AB che si trova
 al centro del treno, quindi senza scombinare questa configurazione già
 corretta posso spostarla nei posti vuoti, creando due vuoti al suo posto.
 Ciò che si presenta a questo punto dovrebbe suggerire il modo di procedere:
 se nei buchi che si sono creati vado a sostituire due vagoni di tipo BB
 presi dal fondo, escludendo gli ultimi due che sono già corretti, mi ritrovo
 nella stessa situazione di partenza, solo che il problema adesso ha una
 dimensione inferiore di 2, come si può vedere in figura 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:Treno-ricorsiva"

\end_inset

.
 
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement h
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename ../materiali/problemi territoriali/2009_treno/treno.eps
	scale 50

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:Treno-ricorsiva"

\end_inset

Idea ricorsiva
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Quando da un problema riusciamo a riportarci allo stesso problema, ma con
 una dimensione inferiore, dovrebbe subito venirci in mente la possibilità
 di poter applicare un approccio ricorsivo.
 Come da figura 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:Treno-ricorsiva"

\end_inset

 infatti posso applicare lo stesso ragionamento al secondo livello e ridurre
 ancora il problema di 2 unità, passando dal problema di dimensione 10 a
 quello di dimensione 8 (quando parlo di dimensione 10 intendo dire la dimension
e del treno, che in funzione di N risulta 
\begin_inset Formula $2N+2$
\end_inset

).
 Tutto molto bello, c'è solo un problema: quando si arriva al problema di
 dimensione 8 (cioè N=3), il procedimento così come applicato a tutti i
 livelli precedenti, non funziona più a causa delle dimensioni ridotte.
 Per risolverlo però basta osservare che nell'esempio ci veniva già data
 la soluzione del problema con N=4, quindi quando la ricorsione arriva alla
 dimensione 10 basta fermarsi e proseguire con le mosse già note.
\end_layout

\begin_layout Standard
Alla fine si arriverà a una situazione con tutte le coppie AB e basterà
 spostare l'ultima coppia in posizione 5-6 al posto dei buchi creati dal
 procedimento applicato e il problema sarà risolto.
\end_layout

\begin_layout Standard
É necessario usare un vettore per memorizzare il contenuto dei vagoni? No,
 poichè quello che interessa è solo di stampare gli spostamenti e quelli
 sono individuati a partire dagli estremi dell'intervallo da modificare,
 come si vede in figura 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:Treno-ricorsiva"

\end_inset

.
 Se chiamiamo gli estremi 
\emph on
i
\emph default
 e 
\emph on
j
\emph default
 (tra l'altro 
\emph on
i
\emph default
 in questo tipo di impostazione non interessa), si vede che a ogni spostamento
 devo spostare la coppia di vagoni all'indice 
\begin_inset Formula $(j-2)/2$
\end_inset

 in posizione 
\begin_inset Formula $j-1$
\end_inset

 e successivamente la coppia di vagoni all'indice 
\begin_inset Formula $j-3$
\end_inset

 in posizione 
\begin_inset Formula $(j-2)/2$
\end_inset

.
 Abbiamo quindi solo la necessità di stampare man mano gli spostamenti effettuat
i: l'unico problema potrebbe essere che il testo chiede di stampare prima
 il numero degli spostamenti che gli spostamenti stessi, ma anche questo
 può essere risolto facilmente sapendo che, dato questo procedimento, il
 numero di spostamenti è sempre 
\begin_inset Formula $2N-3$
\end_inset

, dove il 2N deriva dal fatto che per ogni livello facciamo 2 spostamenti
 e il -3 deriva dal fatto che quando arriviamo al caso N=4 gli spostamenti
 da fare sono solo 5 al posto di 8.
\end_layout

\begin_layout Standard
Questo ci garantisce inoltre di arrivare alla soluzione in meno di 3N mosse,
 come richiede il testo.
 Ci sono altre possibilità di effettuare gli spostamenti per ridurre il
 problema oltre a quella proposta, in ogni caso è possibile stare sotto
 a 3N.
\end_layout

\begin_layout Section
Quasi-palindromi - territoriali 2010
\end_layout

\begin_layout Standard
\begin_inset Box Framed
position "t"
hor_pos "c"
has_inner_box 0
inner_pos "t"
use_parbox 0
use_makebox 0
width "100in"
special "width"
height "1in"
height_special "totalheight"
thickness "0.4pt"
separation "3pt"
shadowsize "4pt"
framecolor "black"
backgroundcolor "none"
status collapsed

\begin_layout Subsection*
Quasi-palindromi (quasipal) 
\end_layout

\begin_layout Subsubsection*
Difficoltà D = 1.
 
\end_layout

\begin_layout Subsubsection*
Descrizione del problema
\end_layout

\begin_layout Plain Layout
Un numero palindromo è un numero che letto da destra a sinistra o da sinistra
 a destra produce la stessa sequenza di cifre.
 Un numero N è quasi-palindromo se è palindromo oppure è tale che sostituendo
 alcune delle cifre 0 presenti in N con altre cifre diverse da 0 si ottiene
 un numero N' che è palindromo.
 Ad esempio N = 4504 è quasi-palindromo perché sostituendo 0 con 5 si ottiene
 il numero N’ = 4554 che è palindromo.
\end_layout

\begin_layout Plain Layout
Un insieme di M numeri con lo stesso numero di cifre forma un rettangolo
 quasi-palindromo (le cui righe sono i numeri) se le cifre nella stessa
 colonna formano sempre un numero quasi-palindromo.
 Ad esempio 120, 046 e 123 formano un rettangolo quasi-palindromo (notare
 che alcuni numeri possono iniziare con lo zero).
 È sufficiente porli nelle righe come segue, per verificarlo colonna per
 colonna:
\end_layout

\begin_layout Plain Layout
120
\end_layout

\begin_layout Plain Layout
046
\end_layout

\begin_layout Plain Layout
123
\end_layout

\begin_layout Plain Layout
Infatti, la cifra 0 in 120 va sostituita con 3 per ottenere un palindromo
 sulla terza colonna.
\end_layout

\begin_layout Plain Layout
Scrivere un programma che dati M numeri di N cifre ciascuno, li stampi in
 ordine (uno per riga) in modo tale che formino un rettangolo quasi-palindromo.
 
\end_layout

\begin_layout Subsubsection*
Dati di input
\end_layout

\begin_layout Plain Layout
Il file input.txt è composto da M+1 righe.
 La prima riga contiene due interi positivi M e N separati da uno spazio.
 Ciascuna delle successive M righe contiene una sequenza di N cifre decimali
 consecutive (senza separazione di spazi), che rappresenta uno degli M numeri.
 
\end_layout

\begin_layout Subsubsection*
Dati di output
\end_layout

\begin_layout Plain Layout
Il file output.txt è composto da M righe contenenti gli M numeri in ingresso
 ordinati in modo da formare un rettangolo quasi-palindromo.
 
\end_layout

\begin_layout Subsubsection*
Assunzioni
\end_layout

\begin_layout Plain Layout
2 ≤ N, M ≤ 8.
 Viene garantito che esiste sempre una soluzione.
 Alcuni numeri possono iniziare con una o più cifre 0.
\end_layout

\begin_layout Subsubsection*
Esempi di input/output
\end_layout

\begin_layout Plain Layout
\begin_inset Tabular
<lyxtabular version="3" rows="2" columns="2">
<features tabularvalignment="middle">
<column alignment="left" valignment="top" width="1in">
<column alignment="left" valignment="top" width="1in">
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
File input.txt
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
File output.txt
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
3 3 
\end_layout

\begin_layout Plain Layout
046 
\end_layout

\begin_layout Plain Layout
120 
\end_layout

\begin_layout Plain Layout
123
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
120 
\end_layout

\begin_layout Plain Layout
046 
\end_layout

\begin_layout Plain Layout
123 
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Suggerimenti
\end_layout

\begin_layout Standard
Il problema richiede di trovare delle permutazioni di un insieme di cifre
 che rispondano a un certo criterio, chiamato 
\emph on
quasi palindromia
\emph default
.
\end_layout

\begin_layout Itemize
Data una stringa di caratteri sei in grado di verificare se è palindroma
 o no?
\end_layout

\begin_layout Itemize
Su una stringa lunga N quanti controlli devono essere fatti per verificarne
 la palindromia o meno?
\end_layout

\begin_layout Itemize
Cosa cambia al controllo di palindromia se il carattere 0 può essere usato
 come 
\begin_inset Quotes eld
\end_inset

jolly
\begin_inset Quotes erd
\end_inset

?
\end_layout

\begin_layout Itemize
Una volta stabilito come verificare la 
\emph on
quasi palindromia
\emph default
, verificare se un rettangolo di caratteri è 
\emph on
quasi palindromo
\emph default
 non è altro che la ripetizione dello stesso controllo fatto su ogni colonna.
 Cambia qualcosa il fatto che il controllo debba essere fatto sulle colonne
 e non sulle righe?
\end_layout

\begin_layout Itemize
Come è possibile ottenere tutte le permutazioni di N interi? (se non lo
 ricordi vedi esempio 
\begin_inset CommandInset ref
LatexCommand ref
reference "sec:Esempio:-Domino-massimale"

\end_inset

)
\end_layout

\begin_layout Itemize
É necessario permutare realmente le righe del rettangolo, spostando ogni
 riga nella sua nuova posizione, con i costi computazionali che questo comporta?
 Oppure è possibile ottenere lo stesso risultato senza muovere righe di
 caratteri?
\end_layout

\begin_layout Itemize
Riesci a scomporre questo problema in una serie di funzionalità, in modo
 da non avere un unico grosso programma soggetto a errori, ma una serie
 di funzioni specializzate nel risolvere un solo compito?
\end_layout

\begin_layout Subsection
Soluzione
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "basicstyle={\small\ttfamily},breaklines=true,frame=lr,language={C++},numbers=left,showstringspaces=false,tabsize=4"
inline false
status collapsed

\begin_layout Plain Layout

int M, N;
\end_layout

\begin_layout Plain Layout

int cifre[8], presente[8]; 
\end_layout

\begin_layout Plain Layout

char rettangolo[8][8]; 
\end_layout

\begin_layout Plain Layout

FILE *in,*out;
\end_layout

\begin_layout Plain Layout

bool verifica_rettangolo() { 	
\end_layout

\begin_layout Plain Layout

	int i,j; 	
\end_layout

\begin_layout Plain Layout

	for (i=0;i<N;i++) 		 		
\end_layout

\begin_layout Plain Layout

		for (j=0;j<M/2;j++){ 			
\end_layout

\begin_layout Plain Layout

			int is = cifre[j]; 			
\end_layout

\begin_layout Plain Layout

			int id = cifre[M-j-1]; 			
\end_layout

\begin_layout Plain Layout

			if ((rettangolo[is][i] != rettangolo[id][i]) && (rettangolo[is][i] !=
 '0' && rettangolo[id][i]!='0'))
\end_layout

\begin_layout Plain Layout

	 		return false; 		
\end_layout

\begin_layout Plain Layout

		} 	
\end_layout

\begin_layout Plain Layout

	return true; 
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

void stampa() {	 	
\end_layout

\begin_layout Plain Layout

	int i,j; 	
\end_layout

\begin_layout Plain Layout

	for (i=0;i<M;i++) 	
\end_layout

\begin_layout Plain Layout

	{ 		
\end_layout

\begin_layout Plain Layout

		int riga = cifre[i]; 		
\end_layout

\begin_layout Plain Layout

		for (j=0;j<N;j++)
\end_layout

\begin_layout Plain Layout

			fprintf(out,"%c",rettangolo[riga][j]); 		fprintf(out,"
\backslash
n"); 	
\end_layout

\begin_layout Plain Layout

	} 
\end_layout

\begin_layout Plain Layout

} 
\end_layout

\begin_layout Plain Layout

void calcola_permutazioni(int inizio, int fine) { 	
\end_layout

\begin_layout Plain Layout

	int i; 	
\end_layout

\begin_layout Plain Layout

	if (inizio >= fine){ 		
\end_layout

\begin_layout Plain Layout

		if (verifica_rettangolo()){ 			
\end_layout

\begin_layout Plain Layout

			stampa(); 			
\end_layout

\begin_layout Plain Layout

			exit(0); 		
\end_layout

\begin_layout Plain Layout

		} 		
\end_layout

\begin_layout Plain Layout

	return; 	
\end_layout

\begin_layout Plain Layout

	} 	
\end_layout

\begin_layout Plain Layout

	for (i = 0; i < fine; i++){ 		
\end_layout

\begin_layout Plain Layout

		if (presente[i]){
\end_layout

\begin_layout Plain Layout

			cifre[inizio] = i; 
\end_layout

\begin_layout Plain Layout

			presente[i] = 0; 
\end_layout

\begin_layout Plain Layout

			calcola_permutazioni(inizio+1,fine);
\end_layout

\begin_layout Plain Layout

			presente[i]=1;  		
\end_layout

\begin_layout Plain Layout

		} 	
\end_layout

\begin_layout Plain Layout

	} 
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

int main() 
\end_layout

\begin_layout Plain Layout

{ 	
\end_layout

\begin_layout Plain Layout

	int i,j; 	
\end_layout

\begin_layout Plain Layout

	in = fopen("input.txt","r"); 	
\end_layout

\begin_layout Plain Layout

	out = fopen("output.txt","w"); 	
\end_layout

\begin_layout Plain Layout

	fscanf(in,"%d %d",&M,&N); 	
\end_layout

\begin_layout Plain Layout

	for (i=0;i<M;i++){
\end_layout

\begin_layout Plain Layout

		char temp[10]; 		
\end_layout

\begin_layout Plain Layout

		fscanf(in,"%s",temp); 		
\end_layout

\begin_layout Plain Layout

		for (j=0;j<N;j++) 			
\end_layout

\begin_layout Plain Layout

			rettangolo[i][j] = temp[j];
\end_layout

\begin_layout Plain Layout

	}     
\end_layout

\begin_layout Plain Layout

	for (i = 0; i < M; i++){ 		
\end_layout

\begin_layout Plain Layout

		presente[i]=1; 		
\end_layout

\begin_layout Plain Layout

		cifre[i]=i; 	
\end_layout

\begin_layout Plain Layout

	} 	
\end_layout

\begin_layout Plain Layout

	calcola_permutazioni(0,M);     
\end_layout

\begin_layout Plain Layout

	return 0; 
\end_layout

\begin_layout Plain Layout

} 
\end_layout

\end_inset


\end_layout

\begin_layout Standard
La soluzione utilizza un approccio a 
\begin_inset Quotes eld
\end_inset

forza bruta
\begin_inset Quotes erd
\end_inset

, come già visto nell'esempio 
\begin_inset CommandInset ref
LatexCommand ref
reference "sec:Esempio:-Domino-massimale"

\end_inset

, che risulta fattibile poichè l'input presenta al massimo 8 righe e le
 permutazioni possibil di 8 righe risultano essere 8!, quindi ampiamente
 esplorabili nei tempi richiesti.
\end_layout

\begin_layout Standard
La strategia risolutiva essenzialmente consiste nel generare tutte le possibili
 permutazioni e per ognuna verificare se ci si trova in presenza di un rettangol
o quasi-palindromo, nel qual caso stamparlo e terminare il programma.
\end_layout

\begin_layout Standard
La generazione delle permutazioni (righe 34-41) è del tutto uguale a quella
 già vista nell'esempio 
\begin_inset CommandInset ref
LatexCommand ref
reference "sec:Esempio:-Domino-massimale"

\end_inset

, dove viene utilizzato il vettore 
\emph on
cifre
\emph default
 per contenere la permutazione da costruire e il vettore 
\emph on
presente
\emph default
 per tenere traccia delle righe già usate e poter fare backtracking su tutte
 le permutazioni.
\end_layout

\begin_layout Standard
Vengono poi definite una serie di funzioni ausiliare il cui compito è piuttosto
 ovvio, ma che risultano comode per strutturare meglio il codice:
\end_layout

\begin_layout Itemize

\emph on
verifica_rettangolo
\emph default
: data una permutazione di righe controlla se il rettangolo corrispondente
 è 
\emph on
quasi palindromo
\emph default
.
 Per farlo la funzione parte dalla prima colonna e, a cominciare dagli estremi,
 confronta le coppie di cifre in posizione opposta per vedere se sono uguali
 o almeno una delle due è 0, nel qual caso passa alla colonna successiva.
 Dopo aver controllato tutte le colonne, se ognuna è risultata essere palindroma
, ritorna 
\emph on
true
\emph default
, altrimenti appena si accorge della presenza di una colonna non palindroma
 ritorna immediatamente 
\emph on
false
\emph default
.
\end_layout

\begin_layout Itemize

\emph on
stampa
\emph default
: si occupa semplicemente di stampare il rettangolo secondo quanto richiesto
 dal testo del problema
\end_layout

\begin_layout Itemize

\emph on
calcola_permutazioni
\emph default
: è la funzione ricorsiva che genera tutte le permutazioni possibili delle
 righe, ognuna delle quali verrà usata da 
\emph on
verifica_rettangolo
\emph default
 per controllare la 
\emph on
quasi palindromia
\emph default
.
\end_layout

\begin_layout Standard
Il costo dell'algoritmo sarà, nel caso pessimo, di tipo 
\begin_inset Formula $N!$
\end_inset

 moltiplicato per il costo del controllo della palindromia, che risulta
 lineare in N, ma come già detto essendo N molto piccolo non avrà problemi
 a risolvere il problema nei tempi stabiliti.
\end_layout

\begin_layout Section
Sbarramento tattico - territoriali 2010
\end_layout

\begin_layout Standard
\begin_inset Box Framed
position "t"
hor_pos "c"
has_inner_box 0
inner_pos "t"
use_parbox 0
use_makebox 0
width "100col%"
special "none"
height "1in"
height_special "totalheight"
thickness "0.4pt"
separation "3pt"
shadowsize "4pt"
framecolor "black"
backgroundcolor "none"
status collapsed

\begin_layout Subsection*
Sbarramento tattico (sbarramento) 
\end_layout

\begin_layout Subsubsection*
Difficoltà D = 2.
 
\end_layout

\begin_layout Subsubsection*
Descrizione del problema
\end_layout

\begin_layout Plain Layout
L'esercito di Orchi dell'Oscuro Signore degli Anelli marcia a ranghi serrati
 verso il Fosso di Helm.
 Per contrastarne la marcia, Re Theoden decide di richiamare tutte le sue
 N armate per creare uno sbarramento unico, con le seguenti regole.
\end_layout

\begin_layout Plain Layout
Campo di battaglia: è rappresentato da una tabella di dimensione NxN, le
 cui righe e colonne sono numerate da 1 a N.
 Posizione: ognuna delle N armate occupa una posizione distinta [i,j] nella
 tabella, all'incrocio tra la riga i e la colonna j.
 Movimento: permette di passare dalla posizione corrente [i,j] a una vicina
 con un giorno di marcia: nord [i-1,j] (se i > 1), sud [i+1,j] (se i < N),
 est [i,j+1] (se j < N) e ovest [i,j-1] (se j > 1).
 Una sola armata alla volta si sposta con un movimento.
 Sbarramento: si crea ponendo tutte le armate su un'unica riga R della tabella,
 attraverso una serie di movimenti.
\end_layout

\begin_layout Plain Layout
Theoden vuole calcolare il numero minimo di movimenti necessari per spostare
 tutte le armate in un unico sbarramento sulla riga R.
 Aiutate Theoden a calcolare tale numero minimo.
 
\end_layout

\begin_layout Subsubsection*
Dati di input
\end_layout

\begin_layout Plain Layout
Il file input.txt è composto da N+1 righe.
 La prima riga contiene due interi positivi N e R, separati da uno spazio:
 il numero N di righe e di colonne nella tabella (nonché il numero di armate)
 e l'indice R della riga su cui far convergere lo sbarramento delle armate.
 Ciascuna delle successive N righe contiene una coppia di interi i e j,
 separati da uno spazio, a indicare che un'armata è presente nella posizione
 [i,j] della tabella.
 
\end_layout

\begin_layout Subsubsection*
Dati di output
\end_layout

\begin_layout Plain Layout
Il file output.txt è composto da una sola riga contenente un intero non negativo,
 il minimo numero di movimenti per posizionare tutte le armate sulla riga
 R della tabella, in posizioni distinte all'interno di tale riga.
 
\end_layout

\begin_layout Subsubsection*
Assunzioni
\end_layout

\begin_layout Itemize
2 ≤ N ≤ 500.
 
\end_layout

\begin_layout Itemize
Durante un movimento, due o più armate non possono mai occupare la stessa
 posizione intermedia.
\end_layout

\begin_layout Subsubsection*
Esempi di input/output
\end_layout

\begin_layout Plain Layout
\begin_inset Tabular
<lyxtabular version="3" rows="2" columns="2">
<features tabularvalignment="middle">
<column alignment="left" valignment="top" width="1in">
<column alignment="left" valignment="top">
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
File input.txt
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
File output.txt
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
8 3 
\end_layout

\begin_layout Plain Layout
5 5 
\end_layout

\begin_layout Plain Layout
1 6 
\end_layout

\begin_layout Plain Layout
2 2 
\end_layout

\begin_layout Plain Layout
6 5 
\end_layout

\begin_layout Plain Layout
3 2 
\end_layout

\begin_layout Plain Layout
7 1 
\end_layout

\begin_layout Plain Layout
1 2 
\end_layout

\begin_layout Plain Layout
8 1
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
31
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Suggerimenti
\end_layout

\begin_layout Standard
Il problema richiede di minimizzare la somma dei costi di una serie di spostamen
ti che portano degli elementi da una configurazione iniziale verso una configura
zione finale.
\end_layout

\begin_layout Itemize
Qual è la struttura dati da utilizzare?
\end_layout

\begin_layout Itemize
Se hai pensato a una matrice, sei sicuro che sia realmente necessaria?
\end_layout

\begin_layout Itemize
Sai calcolare il costo minimo di spostamento di un'armata dalla posizione
 
\emph on
i, j
\emph default
 alla posizione 
\emph on
r,s
\emph default
, con 
\emph on
i,j,r
\emph default
 e 
\emph on
s
\emph default
 qualsiasi?
\end_layout

\begin_layout Itemize
Gli spostamenti delle armate sono indipendenti tra di loro oppure per muovere
 un'armata ho bisogno di sapere dove si trovano tutte le altre per evitare
 di sovrapporle, come sembra indicare l'assunzione 2?
\end_layout

\begin_layout Itemize
Se hai risposto positivamente alla domanda precedente, pensaci meglio: siccome
 non viene richiesto di scrivere la sequenza di spostamenti ma solo il loro
 costo, è sempre possibile determinare una sequenza di mosse che permetta
 di spostare due armate qualsiasi in due punti qualsiasi, evitando che si
 sovrappongano? (ai fini della soluzione, non è necessario sapere quale
 sia la sequenza, basta stabilire che esista sempre)
\end_layout

\begin_layout Itemize
Presa un'armata qualsiasi, qual è il costo per spostarla in 
\begin_inset Quotes eld
\end_inset

verticale
\begin_inset Quotes erd
\end_inset

 dalla riga in cui si trova fino alla riga R, mantenendo la stessa colonna?
 
\end_layout

\begin_layout Itemize
Se tutte le armate fossero su colonne diverse il problema sarebbe di semplice
 soluzione, cosa succede invece quando due o più armate si trovano sulla
 stessa colonna? 
\end_layout

\begin_layout Itemize
Che strategia devo usare per poter minimizzare il costo dello spostamento
 di più armate che si trovano sulla stessa colonna? Ho necessità di tenere
 memoria delle posizioni sulla colonna R che sono già occupate da un'armata?
 Da che armata parto e che ordine seguo per spostarle tutte?
\end_layout

\begin_layout Itemize
Posso arrivare alla soluzione del problema senza necessità di mantenere
 un vettore che mi indichi quali sono le posizioni della riga R che sono
 già occupate?
\end_layout

\begin_layout Subsection
Soluzione
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "basicstyle={\small\ttfamily},breaklines=true,frame=lr,language={C++},numbers=left,showstringspaces=false,tabsize=4"
inline false
status collapsed

\begin_layout Plain Layout

struct armata{ 	
\end_layout

\begin_layout Plain Layout

int r,c; 
\end_layout

\begin_layout Plain Layout

};
\end_layout

\begin_layout Plain Layout

int N, R;
\end_layout

\begin_layout Plain Layout

armata armate[500]; 
\end_layout

\begin_layout Plain Layout

FILE *in,*out;
\end_layout

\begin_layout Plain Layout

int cmp(const void *a, const void *b) { 	
\end_layout

\begin_layout Plain Layout

	armata uno = *(armata *)a; 	
\end_layout

\begin_layout Plain Layout

	armata due = *(armata *)b; 	
\end_layout

\begin_layout Plain Layout

	if (uno.c > due.c) return 1; 	
\end_layout

\begin_layout Plain Layout

	if (uno.c < due.c) return -1; 	
\end_layout

\begin_layout Plain Layout

	return 0; 
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

int main() 
\end_layout

\begin_layout Plain Layout

{ 	
\end_layout

\begin_layout Plain Layout

	int i,j; 	
\end_layout

\begin_layout Plain Layout

	int mosse = 0; 	
\end_layout

\begin_layout Plain Layout

	in = fopen("input.txt","r"); 	
\end_layout

\begin_layout Plain Layout

	out = fopen("output.txt","w"); 	
\end_layout

\begin_layout Plain Layout

	fscanf(in,"%d %d",&N,&R); 	
\end_layout

\begin_layout Plain Layout

	for (i=0;i<N;i++) 		
\end_layout

\begin_layout Plain Layout

		fscanf(in,"%d %d",&armate[i].r,&armate[i].c);
\end_layout

\begin_layout Plain Layout

	qsort(armate,N,sizeof(armata),cmp); 	
\end_layout

\begin_layout Plain Layout

	for (i=0;i<N;i++) 		
\end_layout

\begin_layout Plain Layout

		mosse+=abs(armate[i].r-R) + abs(armate[i].c - (i+1));
\end_layout

\begin_layout Plain Layout

	fprintf(out,"%d
\backslash
n",mosse);     
\end_layout

\begin_layout Plain Layout

	return 0; 
\end_layout

\begin_layout Plain Layout

} 
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Questo problema in prima lettura può sembrare molto più complesso di quanto
 in realtà sia, soprattutto in considerazione della seconda assunzione,
 che porta a pensare che in qualche modo debba calcolarmi una precisa sequenza
 di mosse di cui successivamente calcolare il costo.
 In realtà, proprio perchè viene chiesto solo il costo e non le mosse necessarie
 a raggiungerlo, non bisogna preoccuparsi di quali mosse debbano fare le
 armate, ma calcolare il costo in maniera indipendente per ciascuna, come
 se fosse l'unica presente sul campo di battaglia, stando solo attenti a
 non metterle nella stessa posizione finale sulla riga R, poichè quello
 non è possibile.
\end_layout

\begin_layout Standard
Fatta questa osservazione il problema risulta molto semplice da affrontare
 e può essere risolto in due modi.
\end_layout

\begin_layout Standard
Nel primo modo possiamo osservare che il costo minimo di spostamento si
 ha se l'armata si sposta dalla riga in cui si trova fino alla riga R mantenendo
si sulla stessa colonna (possiamo dire che si sposta 
\begin_inset Quotes eld
\end_inset

ortogonalmente
\begin_inset Quotes erd
\end_inset

 alla riga).
 Poichè possono esserci più armate sulla stessa colonna e nella configurazione
 finale ogni armata dovrà essere in una colonna diversa da quella di tutte
 le altre, non è possibile spostare semplicemente ogni armata in modo ortogonale
, poichè potrebbe finire su una casella già occupata.
 Se però si tiene traccia delle caselle già occupate e ci si sposta nella
 prima casella libera della riga R a destra o a sinistra della colonna di
 partenza dell'armata, si ottiene il costo minimo complessivo.
 Da che armata si parte e in che ordine? Anche se potrebbe non sembrare
 così ovvio, l'ordine con cui si vanno a inserire le armate è indifferente,
 a patto di seguire esattamente quanto specificato sopra, poichè a ordini
 diversi corrispondono mosse diverse, ma ogni eventuale costo aggiuntivo
 per ogni armata che si deve spostare di colonna viene compensato dal guadagno
 fatto da altre armate e alla fine il costo è il medesimo.
\end_layout

\begin_layout Standard
Il secondo modo, quello proposto nel codice, sfrutta una specie di approccio
 
\emph on
greedy
\emph default
, partendo da questa osservazione: se ordino le armate per colonne crescenti,
 posso partire dalla prima e inserirla nella prima posizione della riga
 R, la seconda nella seconda posizione, fino ad arrivare all'ultima.
 Questo modo di procedere mi garantisce di avere il costo minimo per motivi
 analoghi a quelli visti nell'approccio precedente: ogni volta che inserisco
 un'armata, se anche il suo costo non sarà il minimo assoluto, verrà compensato
 dai vantaggi che avranno altre armate nei posizionamenti successivi.
 Perché ciò funzioni è necessario che si proceda prima all'ordinamento,
 altrimenti non è detto che gli svantaggi pagati da alcune armate vengano
 compensati con i vantaggi ricevuti da altre.
\end_layout

\begin_layout Standard
Rispetto al primo modo non serve aggiungere una struttura dati supplementare,
 un vettore, per tenere traccia dei posti che vengono via via occupati e
 questo rende il codice più semplice e veloce da implementare.
 Come infatti si vede bisogna solo definire la funzione per il confronto
 (righe 7-13) necessaria al 
\emph on
qsort
\emph default
, che servirà per ordinare gli elementi di tipo 
\emph on
armata
\emph default
 (righe 1-3).
 Una volta che il vettore di armate risulta ordinato per colonne crescenti
 è sufficiente scandirlo e calcolare la distanza di ogni armata dalla posizione
 i-esima della riga R (righe 24-25).
\end_layout

\begin_layout Standard
Volendo confrontare i due metodi in termini di complessità computazionale
 si pùò vedere che il primo metodo ha un costo N moltiplicato per il numero
 di confronti che devono essere fatti per stabilire in quale casella inserire
 l'armata e nel caso pessimo (tutte le armate nella prima colonna) il costo
 complessivo diventa di tipo quadratico.
 Nel secondo caso invece abbiamo il costo dell'ordinamento (
\begin_inset Formula $NlogN)$
\end_inset

 più il costo del calcolo che invece è di tipo lineare, che rimane tale
 anche nel caso pessimo.
 In ogni caso sono ambedue compatibili con la dimensione dell'input del
 problema.
\end_layout

\begin_layout Section
Sequenza per tamburello - territoriali 2010
\end_layout

\begin_layout Standard
\begin_inset Box Framed
position "t"
hor_pos "c"
has_inner_box 0
inner_pos "t"
use_parbox 0
use_makebox 0
width "100col%"
special "none"
height "1in"
height_special "totalheight"
thickness "0.4pt"
separation "3pt"
shadowsize "4pt"
framecolor "black"
backgroundcolor "none"
status collapsed

\begin_layout Subsection*
Sequenza per tamburello (tamburello) 
\end_layout

\begin_layout Subsubsection*
Difficoltà D = 1.
 
\end_layout

\begin_layout Subsubsection*
Descrizione del problema
\end_layout

\begin_layout Plain Layout
Marco ha trovato alcune antiche sequenze in un manoscritto.
 Ogni sequenza è composta da N pallini pieni o vuoti e rappresenta un brano
 da suonare al tamburello in N istanti consecutivi di tempo: all'i-esimo
 istante, il tamburello viene percosso se l'i-esimo pallino è pieno e, invece,
 non viene percosso se tale pallino è vuoto (1 <= i <= N).
\end_layout

\begin_layout Plain Layout
Marco vuole capire se una data sequenza è periodica: in tal caso, vuole
 estrarne il periodo, ossia il più piccolo segmento iniziale che si ripete
 nel resto della sequenza.
 In altre parole, se P è la sequenza di pallini pieni e vuoti che rappresenta
 il periodo, allora la sequenza in input è periodica se può essere ottenuta
 concatenando P per due o più volte e tale P deve essere di lunghezza minima.
\end_layout

\begin_layout Plain Layout
Per esempio, rappresentando con 1 ogni pallino pieno e con 0 ogni pallino
 vuoto, la sequenza periodica 101010101010 ha 10 come periodo e la sequenza
 1010010100010100101000 ha 10100101000 come periodo.
 Invece, la sequenza 11011011 non è periodica.
 Aiutate Marco in questo compito, in modo che possa imparare a suonare velocemen
te tali brani per tamburello.
 
\end_layout

\begin_layout Subsubsection*
Dati di input
\end_layout

\begin_layout Plain Layout
Il file input.txt è composto da due righe.
 La prima riga contiene un intero positivo N, che indica il numero di pallini
 nella sequenza.
 La seconda riga contiene una sequenza di interi 0 e 1, separati da uno
 spazio, dove 1 rappresenta un pallino pieno e 0 un pallino vuoto.
 
\end_layout

\begin_layout Subsubsection*
Dati di output
\end_layout

\begin_layout Plain Layout
Il file output.txt è composto da una sola riga contenente l'intero 2 se la
 sequenza in input non è periodica.
 Altrimenti, se è periodica, la riga contiene la sequenza di 0 e 1, separati
 da uno spazio, che rappresenta il periodo P della sequenza fornita in input.
 
\end_layout

\begin_layout Subsubsection*
Assunzioni
\end_layout

\begin_layout Plain Layout
2 ≤ N ≤ 100000.
\end_layout

\begin_layout Subsubsection*
Esempi di input/output
\end_layout

\begin_layout Plain Layout
\begin_inset Tabular
<lyxtabular version="3" rows="2" columns="2">
<features tabularvalignment="middle">
<column alignment="left" valignment="top" width="1in">
<column alignment="left" valignment="top">
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
File input.txt
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
File output.txt
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
12 
\end_layout

\begin_layout Plain Layout
1 0 1 0 1 0 1 0 1 0 1 0
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
1 0 
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Suggerimenti per la soluzione
\end_layout

\begin_layout Standard
Il problema chiede di cercare la più piccola sottosequenza che si ripete
 integralmente su tutta la sequenza iniziale, che in altre parole può essere
 definito come il problema di trovare il periodo di un vettore.
\end_layout

\begin_layout Itemize
Qual è la struttura dati che bisogna utilizzare (piuttosto ovvio)?
\end_layout

\begin_layout Itemize
Prova a risolvere il problema per un caso più piccolo, in particolare il
 più piccolo possibile è quello in cui il periodo è lungo 
\begin_inset Formula $N/2$
\end_inset

 e si ripete due volte.
 Cosa bisogna utilizzare per risolvere questo problema (un ciclo 
\emph on
for
\emph default
, un 
\emph on
while
\emph default
, ecc.)?
\end_layout

\begin_layout Itemize
Sei in grado di riscrivere il problema per un periodo di lunghezza 
\begin_inset Formula $N/3$
\end_inset

?
\end_layout

\begin_layout Itemize
Confronta le soluzioni dei due problemi precedenti per 
\begin_inset Formula $N/2$
\end_inset

 e 
\begin_inset Formula $N/3$
\end_inset

: sei in grado di generalizzare la soluzione per un periodo 
\begin_inset Formula $N/k$
\end_inset

, con 
\begin_inset Formula $k$
\end_inset

 un valore intero qualsiasi?
\end_layout

\begin_layout Itemize
Se dai punti precedenti sei stato in grado di generalizzazione la soluzione
 al periodo 
\begin_inset Formula $N/k$
\end_inset

 puoi provare tutti i periodi per trovare il più piccolo?
\end_layout

\begin_layout Itemize
Conviene partire da 
\begin_inset Formula $k=2$
\end_inset

 e procedere con periodi decrescenti 
\begin_inset Formula $N/2,N/3,...,3,2,1$
\end_inset

 oppure conviene partire dal periodo più piccolo e aumentarne la grandezza
 per fermarsi al primo trovato?
\end_layout

\begin_layout Itemize
Ma 
\begin_inset Formula $k$
\end_inset

 può assumere qualsiasi valore o alcuni possono essere scartati a priori?
 In altri termini il periodo di una sequenza di lunghezza N può avere qualsiasi
 valore o è vincolato solo ad alcuni possibili?
\end_layout

\begin_layout Itemize
Ha senso escludere a priori le sequenze di lunghezza pari a un numero primo,
 provando solo se hanno periodo 1, oppure questo implicitamente è un controllo
 che si fa già se abbiamo risposto alla domanda precedente?
\end_layout

\begin_layout Subsection
Soluzione
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "basicstyle={\small\ttfamily},breaklines=true,frame=lr,language={C++},numbers=left,showstringspaces=false,tabsize=4"
inline false
status collapsed

\begin_layout Plain Layout

int sequenza[100000]; 
\end_layout

\begin_layout Plain Layout

int N;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

bool corrispondenza(int inizio, int periodo) { 	
\end_layout

\begin_layout Plain Layout

	int i; 	
\end_layout

\begin_layout Plain Layout

	for(i=0;i<periodo;i++) 		
\end_layout

\begin_layout Plain Layout

		if (sequenza[i]!=sequenza[i+inizio]) 			
\end_layout

\begin_layout Plain Layout

			return false; 	
\end_layout

\begin_layout Plain Layout

	return true; 
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

bool trova_periodo(int periodo) { 	
\end_layout

\begin_layout Plain Layout

	int i; 	
\end_layout

\begin_layout Plain Layout

	for (i=periodo;i<N;i+=periodo) 		
\end_layout

\begin_layout Plain Layout

		if (!corrispondenza(i,periodo)) 			
\end_layout

\begin_layout Plain Layout

			return false; 	
\end_layout

\begin_layout Plain Layout

	return true; 
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

int main() 
\end_layout

\begin_layout Plain Layout

{ 	
\end_layout

\begin_layout Plain Layout

	int i,j; 	
\end_layout

\begin_layout Plain Layout

	FILE *in = fopen("input.txt","r"); 	
\end_layout

\begin_layout Plain Layout

	FILE *out = fopen("output.txt","w"); 	
\end_layout

\begin_layout Plain Layout

	fscanf(in,"%d",&N); 	
\end_layout

\begin_layout Plain Layout

	for (i=0;i<N;i++) 		
\end_layout

\begin_layout Plain Layout

		fscanf(in,"%d",&sequenza[i]); 	
\end_layout

\begin_layout Plain Layout

	for (i=1;i<=N/2;i++) 		
\end_layout

\begin_layout Plain Layout

		if(N%i == 0) 
\end_layout

\begin_layout Plain Layout

			if (trova_periodo(i))
\end_layout

\begin_layout Plain Layout

			{ 				
\end_layout

\begin_layout Plain Layout

				for (j=0;j<i;j++) 					
\end_layout

\begin_layout Plain Layout

					fprintf(out,"%d ",sequenza[j]); 				
\end_layout

\begin_layout Plain Layout

				exit(0); 			
\end_layout

\begin_layout Plain Layout

			}	 	
\end_layout

\begin_layout Plain Layout

	fprintf(out,"2");     
\end_layout

\begin_layout Plain Layout

	return 0; 
\end_layout

\begin_layout Plain Layout

} 
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Dopo aver letto l'input (righe 23-27), il ciclo 
\emph on
for
\emph default
 di riga 28 scorre tutti i periodi possibili, a partire da quello di lunghezza
 1 fino a quello di lunghezza 
\begin_inset Formula $N/2$
\end_inset

, fermandosi (riga 34) e stampando direttamente il risultato al primo periodo
 incontrato, che quindi è sicuramente il più piccolo.
 Per verificare se esiste un periodo vengono utilizzate due funzioni: la
 funzione 
\emph on
trova_periodo
\emph default
 riceve come input il periodo da testare (riga 30), restituendo 
\emph on
true
\emph default
 o 
\emph on
false
\emph default
 se il periodo viene trovato o meno; questa funzione usa poi 
\emph on
corrispondenza
\emph default
 che verifica se i primi 
\emph on
periodo
\emph default
 elementi del vettore sono uguali a quelli spostati in avanti di una quantità
 
\emph on
inizio
\emph default
, multipla del periodo che si sta testando (righe 6-7).
 Dalla figura 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:Esempio-Tamburello"

\end_inset

 si può vedere l'idea sul test del periodo 4: 
\emph on
trova_periodo
\emph default
 verifica prima se i primi quattro elementi sono uno a uno uguali ai quattro
 elementi che partono dall'indice 4, poi ripete la stessa cosa confrontando
 i primi quattro elementi con i quattro che partono dall'indice 8.
 
\end_layout

\begin_layout Standard
Si può infine notare come alla riga 29 venga controllato se il periodo che
 si vuole testare è un sottomultiplo della lunghezza del vettore, poichè,
 se non lo è, si passa direttamente al candidato successivo, non essendo
 possibile che quello sia un periodo esatto del vettore.
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement h
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename ../materiali/problemi territoriali/2010_tamburello/tamburello.eps
	display false
	scale 55

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:Esempio-Tamburello"

\end_inset

Esempio di esecuzione
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Questa soluzione ha un costo computazionale che può essere approssimativamente
 calcolato in questo modo:
\end_layout

\begin_layout Itemize
ogni volta che testiamo un periodo vengono controllati tutti gli elementi
 del vettore, quindi questo passaggio richiede circa N confronti (nel caso
 vengano fatti tutti, altrimenti meno)
\end_layout

\begin_layout Itemize
quanti periodi vengono testati? Nel caso peggiore in cui la sequenza non
 è periodica e quindi devo testarli tutti primi di accorgemene, i periodi
 possibili sono solo quelli che dividono esattamente la lunghezza del vettore,
 quindi il numero dei suoi divisori.
 Sicuramente questo numero è minore di 
\begin_inset Formula $N/2$
\end_inset

, bisognerebbe poi vedere di quanto, il che è un problema di teoria dei
 numeri che esula dalla presente trattazione.
 Se il numero N fosse una potenza del 2 avremmo un numero di periodi possibili
 pari a 
\begin_inset Formula $log_{2}N$
\end_inset

, per situazioni diverse è molto più difficile da stimare, ma si può presumere
 che non cresca in modo lineare e quindi l'algoritmo nel complesso sia subquadra
tico.
\end_layout

\begin_layout Section
\begin_inset CommandInset label
LatexCommand label
name "sec:Eserciti-galattici"

\end_inset

Eserciti galattici - territoriali 2011
\end_layout

\begin_layout Standard
\begin_inset Box Framed
position "t"
hor_pos "c"
has_inner_box 0
inner_pos "t"
use_parbox 0
use_makebox 0
width "100col%"
special "none"
height "1in"
height_special "totalheight"
thickness "0.4pt"
separation "3pt"
shadowsize "4pt"
framecolor "black"
backgroundcolor "none"
status collapsed

\begin_layout Subsection*
Eserciti Galattici (galattici) 
\end_layout

\begin_layout Subsubsection*
Difficoltà D = 2 
\end_layout

\begin_layout Subsubsection*
Descrizione del problema 
\end_layout

\begin_layout Plain Layout
L'esercito della Signoria è riuscito a costruire un'arma segreta: il temibile
 Sarcofago Nero.
 Esso legge una parola segreta S costituita da lettere minuscole dell'alfabeto:
 a, b, c, ..., z (ogni lettera può comparire zero, una o più volte).
 Il Sarcofago Nero può assumere N configurazioni al suo interno, numerate
 da 1 a N.
 La parola segreta S viene accettata se raggiunge la configurazione finale
 (avente numero N) a partire dalla configurazione iniziale (avente numero
 1) dopo aver letto tutte le lettere in S una alla volta.
 Per ogni configurazione I del Sarcofago Nero, la tripletta (I,J,c) indica
 che la lettera c lo fa transitare dalla configurazione I alla configurazione
 J.
 L'esercito rivale ha carpito una parola segreta S, ma non sa se è quella
 del Sarcofago Nero.
 Il tuo compito è quello di trovare la configurazione interna Q che esso
 raggiunge, dopo aver letto S, a partire dalla configurazione iniziale.
 
\end_layout

\begin_layout Subsubsection*
Dati di input 
\end_layout

\begin_layout Plain Layout
Il file input.txt è composto da M+2 righe.
 La prima riga contiene tre interi positivi separati da uno spazio, che
 rappresentano il numero M delle triplette, il numero N di configurazioni
 e il numero K di lettere nella sequenza S.
 La seconda riga contiene K lettere separate da uno spazio, le quali formano
 la sequenza S.
 Ciascuna delle rimanenti M righe contiene due interi positivi I e J e una
 lettera c, separati da una spazio, che rappresentano la tripletta (I,J,c)
 per la transizione del Sarcofago Nero.
 
\end_layout

\begin_layout Subsubsection*
Dati di output 
\end_layout

\begin_layout Plain Layout
Il file output.txt è composto da una sola riga contenente il numero Q della
 configurazione raggiunta dal Sarcofago Nero a partire dalla sua configurazione
 iniziale (avente numero 1), dopo aver letto tutta la sequenza S.
 
\end_layout

\begin_layout Subsubsection*
Assunzioni 
\end_layout

\begin_layout Itemize
2 ≤ M ≤ 100.
 
\end_layout

\begin_layout Itemize
2 ≤ N ≤ 100.
 
\end_layout

\begin_layout Itemize
2 ≤ K ≤ 10.
 
\end_layout

\begin_layout Itemize
1 ≤ Q ≤ N.
 
\end_layout

\begin_layout Subsubsection*
Esempi di input/output 
\end_layout

\begin_layout Plain Layout
\begin_inset Tabular
<lyxtabular version="3" rows="2" columns="2">
<features tabularvalignment="middle">
<column alignment="left" valignment="top" width="1in">
<column alignment="left" valignment="top">
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
File input.txt 
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
File output.txt
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
5 3 6 
\end_layout

\begin_layout Plain Layout
a a a b a b 
\end_layout

\begin_layout Plain Layout
1 3 a 
\end_layout

\begin_layout Plain Layout
1 2 b 
\end_layout

\begin_layout Plain Layout
2 1 a 
\end_layout

\begin_layout Plain Layout
3 2 b 
\end_layout

\begin_layout Plain Layout
3 3 a
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
2
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Suggerimenti
\end_layout

\begin_layout Standard
Il problema richiede di applicare una serie di regole per spostarsi da uno
 stato iniziale conosciuto ad uno finale sconosciuto.
\end_layout

\begin_layout Itemize
Data una regola composta da uno stato iniziale e un input (la lettera della
 parola segreta) posso stabilire a che lettera andrò a finire tramite un
 
\emph on
if
\emph default
?
\end_layout

\begin_layout Itemize
Ma non sapendo al momento della stesura del codice quali saranno le regole
 che dovrò applicare posso rappresentarle tramite una serie di 
\emph on
if
\emph default
?
\end_layout

\begin_layout Itemize
Allora se l'approcio precedente non è possibile, come può essere rappresentata
 una regola?
\end_layout

\begin_layout Itemize
E un insieme di regole?
\end_layout

\begin_layout Itemize
Se riesco a rappresentare correttamente un insieme di regole posso iterare
 il procedimento su ogni singola lettera per arrivare alla lettera finale?
\end_layout

\begin_layout Subsection
Soluzione
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "basicstyle={\small\ttfamily},breaklines=true,frame=lr,language={C++},numbers=left,showstringspaces=false,tabsize=4"
inline false
status collapsed

\begin_layout Plain Layout

int M,N,K; 
\end_layout

\begin_layout Plain Layout

char parola[11]; 
\end_layout

\begin_layout Plain Layout

int I,J; 
\end_layout

\begin_layout Plain Layout

char c;
\end_layout

\begin_layout Plain Layout

struct transizione{ 	
\end_layout

\begin_layout Plain Layout

	int I,J; 	
\end_layout

\begin_layout Plain Layout

	char c; 
\end_layout

\begin_layout Plain Layout

};
\end_layout

\begin_layout Plain Layout

transizione t[100];
\end_layout

\begin_layout Plain Layout

int main() 
\end_layout

\begin_layout Plain Layout

{ 	
\end_layout

\begin_layout Plain Layout

	ifstream in("input.txt"); 	
\end_layout

\begin_layout Plain Layout

	ofstream out("output.txt"); 	
\end_layout

\begin_layout Plain Layout

	in >> M >> N >> K; 	
\end_layout

\begin_layout Plain Layout

	for(int i = 0; i < K; i++)
\end_layout

\begin_layout Plain Layout

		in >> parola[i]; 	
\end_layout

\begin_layout Plain Layout

	for(int i = 0; i < M; i++) 		
\end_layout

\begin_layout Plain Layout

		in >> t[i].I >> t[i].J >> t[i].c; 	 	
\end_layout

\begin_layout Plain Layout

	int stato_attuale = 1; 	
\end_layout

\begin_layout Plain Layout

	for(int i = 0; i < K; i++){ 		
\end_layout

\begin_layout Plain Layout

		int j = 0; 		
\end_layout

\begin_layout Plain Layout

		while (t[j].c != parola[i] || t[j].I != stato_attuale) 
\end_layout

\begin_layout Plain Layout

			j++; 		
\end_layout

\begin_layout Plain Layout

		stato_attuale = t[j].J; 	
\end_layout

\begin_layout Plain Layout

	}  	
\end_layout

\begin_layout Plain Layout

	out << stato_attuale; 	
\end_layout

\begin_layout Plain Layout

	return 0; 
\end_layout

\begin_layout Plain Layout

} 
\end_layout

\end_inset


\end_layout

\begin_layout Standard
La parte più difficile di questo problema è, a detta di molti tra cui io,
 la comprensione del testo, che risulta in alcuni punti disorientante.
 Se comunque, anche grazie all'esempio, si riesce a penetrarne il significato,
 ci si accorge di trovarsi di fronte all'implementazione di una semplice
 macchina a stati finiti, dove le regole descrivono le transizioni tra stati.
 Per capire meglio il funzionamento si può vedere la figura 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:Macchina-a-stati"

\end_inset

, dove è stata rappresentata la macchina che risulta dalle regole date nel
 caso di esempio.
 Gli stati della macchina sono rappresentati dai nodi del grafo, mentre
 ogni regola è un arco orientato: ad esempio la regola rappresentata dalla
 tripletta (1, 3, a) nel disegno è l'arco che esce dal nodo 1 e entra nel
 nodo 3 con segnata la 
\emph on
a
\emph default
.
 Partendo dal nodo 1 e seguendo il flusso delle regole come mostrato nella
 tabella in figura è evidente come si possa arrivare alla soluzione richiesta.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename ../materiali/problemi territoriali/2011_galattici/galattici.eps
	display false
	scale 50

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:Macchina-a-stati"

\end_inset

Macchina a stati finiti
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Ogni regola può essere rappresentata come una struttura contenente le informazio
ni su stato iniziale, stato finale e lettera (righe 5-8), in modo da poter
 creare poi il vettore contenente le regole (riga 9).
 Basterà a questo punto scandire tutte le lettere della parola segreta (riga
 20), che agiscono da input sulla macchina a stati e, scorrendo tutte le
 regole (riga 22), trovare quella corretta da applicare, in modo da avere
 una transizione di stato e poter reiterare il procedimento.
 Lo stato in cui si troverà la macchina alla fine della lettura della parola
 segreta sarà quindi il risultato cercato.
\end_layout

\begin_layout Section
Nanga Parbat - territoriali 2011
\end_layout

\begin_layout Standard
\begin_inset Box Framed
position "t"
hor_pos "c"
has_inner_box 0
inner_pos "t"
use_parbox 0
use_makebox 0
width "100col%"
special "none"
height "1in"
height_special "totalheight"
thickness "0.4pt"
separation "3pt"
shadowsize "4pt"
framecolor "black"
backgroundcolor "none"
status collapsed

\begin_layout Subsection*
Nanga Parbat (nanga) 
\end_layout

\begin_layout Subsubsection*
Difficoltà D = 1 
\end_layout

\begin_layout Subsubsection*
Descrizione del problema 
\end_layout

\begin_layout Plain Layout
Durante la lunga scalata delle cime attorno al Nanga Parbat, Reinhold Messner
 riesce a trasmettere al campo base, a intervalli regolari, solo il dislivello
 percorso rispetto all'ultima trasmissione.
 Se invia un numero positivo P, allora è salito di P metri rispetto alla
 precedente trasmissione; se invia un numero negativo -P, allora è sceso
 di P metri rispetto alla precedente trasmissione; se infine invia P=0,
 non ha cambiato altitudine.
 Messner parte dal campo base a 5000 metri.
 I suoi collaboratori al campo base ricevono tali rilevamenti: aiutali a
 identificare l'altitudine che risulta più frequentemente rilevata in questo
 modo.
 
\end_layout

\begin_layout Plain Layout
Dati di input 
\end_layout

\begin_layout Plain Layout
Il file input.txt è composto da N+1 righe.
 La prima riga contiene l'intero positivo N, il numero dei rilevamenti trasmessi
 da Messner.
 Ciascuna delle successive N righe contiene un intero che rappresenta il
 dislivello percorso rispetto alla precedente trasmissione.
 
\end_layout

\begin_layout Subsubsection*
Dati di output 
\end_layout

\begin_layout Plain Layout
Il file output.txt è composto da una sola riga contenente l'altitudine che
 risulta più frequentemente rilevata in questo modo dal campo base.
 
\end_layout

\begin_layout Subsubsection*
Assunzioni 
\end_layout

\begin_layout Itemize
2 ≤ N ≤ 1000.
 
\end_layout

\begin_layout Itemize
-100 ≤ P ≤ 100.
 
\end_layout

\begin_layout Subsubsection*
Esempi di input/output 
\end_layout

\begin_layout Plain Layout
\begin_inset Tabular
<lyxtabular version="3" rows="2" columns="2">
<features tabularvalignment="middle">
<column alignment="left" valignment="top" width="1in">
<column alignment="left" valignment="top">
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
File input.txt
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
File output.txt
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
8 
\end_layout

\begin_layout Plain Layout
3 
\end_layout

\begin_layout Plain Layout
-1 
\end_layout

\begin_layout Plain Layout
6 
\end_layout

\begin_layout Plain Layout
-7 
\end_layout

\begin_layout Plain Layout
1 
\end_layout

\begin_layout Plain Layout
4 
\end_layout

\begin_layout Plain Layout
0 
\end_layout

\begin_layout Plain Layout
-4 
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
5002
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Subsubsection*
Nota/e 
\end_layout

\begin_layout Itemize
L'altitudine iniziale viene rilevata ai fini della risposta.
 
\end_layout

\begin_layout Itemize
Viene garantito nei dati di input che l'altitudine più frequentemente rilevata
 è unica.
 
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Suggerimenti
\end_layout

\begin_layout Standard
Il problema richiede di contare quante volte ogni numero è presente all'interno
 di un insieme e trovare il massimo numero di occorrenze.
\end_layout

\begin_layout Itemize
Dato un insieme di N numeri, che struttura useresti per memorizzare il numero
 di volte che compare ognuno di essi?
\end_layout

\begin_layout Itemize
Sapendo che i numeri sono interi, è possibile migliorare il modo in cui
 vengono memorizzati? 
\end_layout

\begin_layout Itemize
Se non fossero interi potresti fare le stesse cose?
\end_layout

\begin_layout Itemize
Usando il numero come indice del vettore e il valore come contatore del
 numero di volte che quel numero compare, lo spazio occupato dal vettore
 verrebbe sfruttato bene? In quali condizioni questo approcio non sarebbe
 più possibile?
\end_layout

\begin_layout Subsection
Soluzione
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "basicstyle={\small\ttfamily},breaklines=true,frame=lr,language={C++},numbers=left,showstringspaces=false,tabsize=4"
inline false
status collapsed

\begin_layout Plain Layout

int N; 
\end_layout

\begin_layout Plain Layout

int alt = 100000; 
\end_layout

\begin_layout Plain Layout

int quote[200001]; 
\end_layout

\begin_layout Plain Layout

int main() 
\end_layout

\begin_layout Plain Layout

{ 	
\end_layout

\begin_layout Plain Layout

	int temp; 	
\end_layout

\begin_layout Plain Layout

	ifstream in("input.txt"); 	
\end_layout

\begin_layout Plain Layout

	ofstream out("output.txt"); 	
\end_layout

\begin_layout Plain Layout

	in >> N; 	
\end_layout

\begin_layout Plain Layout

	for (int i = 0; i < N; i++){ 		
\end_layout

\begin_layout Plain Layout

		in >> temp; 		
\end_layout

\begin_layout Plain Layout

		alt += temp; 		
\end_layout

\begin_layout Plain Layout

		quote[alt]++; 
\end_layout

\begin_layout Plain Layout

	} 	
\end_layout

\begin_layout Plain Layout

	int max = 0, quanti = quote[0]; 	
\end_layout

\begin_layout Plain Layout

	for (int i = 0; i<200001 ; i++) 		
\end_layout

\begin_layout Plain Layout

		if (quote[i]>quanti){
\end_layout

\begin_layout Plain Layout

			max = i; 			
\end_layout

\begin_layout Plain Layout

			quanti = quote[i]; 		
\end_layout

\begin_layout Plain Layout

	} 	
\end_layout

\begin_layout Plain Layout

	out << max - 95000; 	
\end_layout

\begin_layout Plain Layout

	return 0; 
\end_layout

\begin_layout Plain Layout

} 
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Questa prima soluzione utilizza un vettore in maniera 
\begin_inset Quotes eld
\end_inset

non standard
\begin_inset Quotes erd
\end_inset

, nel senso che al posto di memorizzare i dati in certe posizioni come avviene
 solitamente, usa gli indici del vettore come valore delle quote e i valori
 corrispondenti come numero delle volte che quella quota è stata raggiunta.
 In questo modo per ogni nuova lettura del dislivello è immediato calcolare
 la quota raggiunta e usare questo dato come indice nel vettore, incrementando
 di uno il valore corrispondente, per indicare che quella quota è stata
 raggiunta un'altra volta (righe 10-14).
\end_layout

\begin_layout Standard
Alla fine della lettura di tutti i dislivelli nel vettore delle quote si
 avranno una serie di valori ed è sufficiente trovare l'indice corrispondente
 al valore massimo per avere la soluzione del problema (righe 15-20).
\end_layout

\begin_layout Standard
Gli unici due aspetti a cui prestare attenzione sono i seguenti:
\end_layout

\begin_layout Itemize
per come sono le assunzioni, cioè massimo 1000 rilevazioni e ogni dislivello
 limitato a 100 in valore assoluto, la massima altezza che sarebbe possibile
 raggiungere è di 105000 e la minima di -95000 (poichè la quota di partenza
 è di 5000 metri).
 Quindi il vettore deve avere 200001 elementi per poter contenere tutti
 i casi possibili, anche se ovviamente la maggior parte dello spazio risulterà
 sprecata
\end_layout

\begin_layout Itemize
siccome gli indici del vettore sono solo positivi mentre le quote potrebbero
 anche essere negative, si suppone di partire da metà vettore, cioè a quota
 100000, si fanno tutti i calcoli e solo alla fine si va a rimettere a posto
 il risultato sottraendo 95000 (riga 21), che è l'
\emph on
offset
\emph default
 che è stato aggiunto all'inizio per evitare quote negative.
\end_layout

\begin_layout Standard
Sebbene questa soluzione sia molto efficiente, avrebbe dei problemi nel
 caso che le assunzioni fossero diverse e costringessero ad avere vettori
 più grandi per memorizzare le quote visitate.
 Se ad esempio il dislivello massimo tra una trasmissione e la successiva
 fosse di 100000 al posto che di 100, avremmo bisogno di un vettore di 
\begin_inset Formula $100000\times1000\times2$
\end_inset

 elementi, cioè 200.000.000 di elementi, che è una dimensione enorme, in genere
 oltre il limite che viene posto nelle gare e questo nonostante i posti
 che poi verrebbero utilizzati sarebbero al massimo 999 (poichè per le ipotesi
 del problema almeno una quota doppia è presente).
\end_layout

\begin_layout Standard
Per risolvere il problema si potrebbe utilizzare una 
\emph on
map
\emph default
, uno dei contenitori standard del C++, chiamato anche 
\emph on
array associativo
\emph default
, che come un normale array serve a contenere una sequenza di valori omogenei,
 solo che al posto di poterli indirizzare solo tramite un indice numerico,
 permette di usare qualsiasi tipo di 
\begin_inset Quotes eld
\end_inset

etichetta
\begin_inset Quotes erd
\end_inset

 per contrassegnare una posizione nel vettore.
 
\end_layout

\begin_layout Standard
In questo caso verrebbe ancora utilizzato un indice numerico, solo che a
 differenza di un vettore normale, solo le caselle corrispondenti a una
 quota raggiunta verrebbero create e quindi la quantità di spazio utilizzata
 sarebbe sembre al massimo proporzionale a 999, indipendentemente dalla
 grandezza dei dislivelli massimi, come si può vedere nell'esempio di figura
 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:Vettore-mappa"

\end_inset

.
\end_layout

\begin_layout Standard
Le uniche difficoltà in questo tipo di soluzione risiedono nell'utilizzo
 della 
\emph on
map
\emph default
, che può risultare poco chiaro per chi non l'ha mai utilizzata.
 
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "basicstyle={\small\ttfamily},breaklines=true,frame=lr,language={C++},numbers=left,showstringspaces=false,tabsize=4"
inline false
status collapsed

\begin_layout Plain Layout

int N; 
\end_layout

\begin_layout Plain Layout

map <int , int> m; 
\end_layout

\begin_layout Plain Layout

int alt = 5000; 
\end_layout

\begin_layout Plain Layout

pair<map<int,int>::iterator,bool> ret;
\end_layout

\begin_layout Plain Layout

int main(int argc, char** argv) 
\end_layout

\begin_layout Plain Layout

{ 	
\end_layout

\begin_layout Plain Layout

	int temp; 	
\end_layout

\begin_layout Plain Layout

	ifstream in("input.txt"); 	
\end_layout

\begin_layout Plain Layout

	ofstream out("output.txt"); 	
\end_layout

\begin_layout Plain Layout

	in >> N; 	
\end_layout

\begin_layout Plain Layout

	for (int i = 0; i < N; i++){ 		
\end_layout

\begin_layout Plain Layout

		in >> temp; 		
\end_layout

\begin_layout Plain Layout

		alt += temp; 		
\end_layout

\begin_layout Plain Layout

		ret = m.insert(pair<int,int>(alt,1)); 		
\end_layout

\begin_layout Plain Layout

		if (ret.second == false) 			
\end_layout

\begin_layout Plain Layout

			ret.first->second++; 	
\end_layout

\begin_layout Plain Layout

	} 	
\end_layout

\begin_layout Plain Layout

	map<int,int>::iterator i; 	
\end_layout

\begin_layout Plain Layout

	i = m.begin();
\end_layout

\begin_layout Plain Layout

	int max = i->first; 	
\end_layout

\begin_layout Plain Layout

	int quanti = i->second; 	
\end_layout

\begin_layout Plain Layout

	for (map<int,int>::iterator i = m.begin(); i!=m.end();i++)
\end_layout

\begin_layout Plain Layout

		if (i->second > quanti){			
\end_layout

\begin_layout Plain Layout

			max = i->first; 			
\end_layout

\begin_layout Plain Layout

			quanti = i->second; 		
\end_layout

\begin_layout Plain Layout

		} 	
\end_layout

\begin_layout Plain Layout

	out << max; 	
\end_layout

\begin_layout Plain Layout

	return 0; 
\end_layout

\begin_layout Plain Layout

} 
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Come si vede nel codice per ogni dislivello letto viene creata una coppia
 tramite il container 
\emph on
pair
\emph default
, in cui il primo elemento è la quota attuale e il secondo viene messo a
 1, per indicare che la quota è stata raggiunta una volta, e questa coppia
 viene inserita nella 
\emph on
map
\emph default
 (riga 14).
 Il metodo 
\emph on
insert
\emph default
 ritorna a sua volta una coppia, il cui primo elemento è un iteratore all'elemen
to della mappa inserito e il secondo vale 
\emph on
true
\emph default
 se il 
\emph on
pair
\emph default
 è stato aggiunto correttamente (cioè se è la prima volta che la quota viene
 inserita nella mappa) oppure 
\emph on
false
\emph default
 se la quota è già presente nella mappa.
 In quest'ultimo caso bisogna quindi incrementare il valore indicizzato
 dalla quota (righe 15-16).
\end_layout

\begin_layout Standard
Terminato l'inserimento è necessario, come per il vettore della soluzione
 precedente, cercare il massimo: in questo caso non è possibile scandire
 la mappa utilizzando un indice, ma bisogna usare un iteratore (righe 20-24).
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename ../materiali/problemi territoriali/2011_nanga/nanga.eps
	display false
	scale 50

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:Vettore-mappa"

\end_inset

Confronto tra vettore e mappa
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Section
Gran Prix - territoriali 2012
\end_layout

\begin_layout Standard
\begin_inset Box Framed
position "t"
hor_pos "c"
has_inner_box 0
inner_pos "t"
use_parbox 0
use_makebox 0
width "100col%"
special "none"
height "1in"
height_special "totalheight"
thickness "0.4pt"
separation "3pt"
shadowsize "4pt"
framecolor "black"
backgroundcolor "none"
status collapsed

\begin_layout Subsection*
Gran Prix (granprix)
\end_layout

\begin_layout Subsubsection*
Difficoltà D = 1.
 
\end_layout

\begin_layout Subsubsection*
Descrizione del problema
\end_layout

\begin_layout Plain Layout
State assistendo a un Gran Premio di Formula 1.
 Prima dell'inizio, il tabellone riporta la griglia di partenza, ovvero
 l'ordine in cui le vetture partiranno dalla linea del traguardo.
 Non appena inizia il gran premio, per ogni sorpasso, il tabellone scrive
 due numeri: quello della vettura che ha effettuato il sorpasso, e quello
 della vettura che è stata superata.
 Il vostro compito è di scrivere un programma che, ricevuti in ingresso
 l'ordine di partenza e la lista dei sorpassi, calcoli chi ha vinto il gran
 premio.
\end_layout

\begin_layout Plain Layout
Per esempio, considerate il seguente gran premio, con 3 macchine e 4 sorpassi.
 L'ordine iniziale di partenza è stato: la vettura numero 2, poi la vettura
 numero 1 e infine la vettura numero 3.
 I sorpassi sono stati, nell'ordine:
\end_layout

\begin_layout Enumerate
la numero 3 ha superato la numero 1; 
\end_layout

\begin_layout Enumerate
la numero 3 ha superato la numero 2; 
\end_layout

\begin_layout Enumerate
la numero 1 ha superato la numero 2; 
\end_layout

\begin_layout Enumerate
la numero 2 ha superato la numero 1;
\end_layout

\begin_layout Plain Layout
In questo caso, è facile vedere che la vettura numero 3 ha vinto il gran
 premio.
 Come si può notare dall'esempio, i sorpassi avvengono sempre tra due vetture
 consecutive.
\end_layout

\begin_layout Subsubsection*
Dati di input
\end_layout

\begin_layout Plain Layout
Il file di input è costituito da 1+N+M righe di testo.
 La prima riga contiene due interi positivi separati da uno spazio: N che
 è il numero di vetture e M che è il numero di sorpassi.
 Le successive N righe contengono l'ordine di partenza: per ogni riga c'è
 un numero intero K che rappresenta una vettura, con 1 ≤ K ≤ N.
 La vettura che parte in i-esima posizione nell'ordine di partenza si trova
 quindi nella riga (i+1) del file.
 Le restanti M righe contengono tutti i sorpassi, nell'ordine in cui sono
 avvenuti, uno in ogni riga.
 Ogni riga contiene due interi separati da uno spazio: A, ovvero il numero
 della vettura che ha effettuato il sorpasso, e B, ovvero il numero della
 vettura che ha subito il sorpasso.
 
\end_layout

\begin_layout Subsubsection*
Dati di output
\end_layout

\begin_layout Plain Layout
Il file di output deve contenere un solo intero: il numero della vettura
 che ha vinto il gran premio.
 
\end_layout

\begin_layout Subsubsection*
Assunzioni
\end_layout

\begin_layout Itemize
2 ≤ N ≤ 30 
\end_layout

\begin_layout Itemize
1 ≤ M ≤ 100
\end_layout

\begin_layout Subsubsection*
Esempi di input/output 
\end_layout

\begin_layout Plain Layout
\begin_inset Tabular
<lyxtabular version="3" rows="2" columns="2">
<features tabularvalignment="middle">
<column alignment="left" valignment="top" width="1in">
<column alignment="left" valignment="top">
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
File input.txt
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
File output.txt
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
3 4 
\end_layout

\begin_layout Plain Layout
2 
\end_layout

\begin_layout Plain Layout
1 
\end_layout

\begin_layout Plain Layout
3 
\end_layout

\begin_layout Plain Layout
3 1 
\end_layout

\begin_layout Plain Layout
3 2 
\end_layout

\begin_layout Plain Layout
1 2 
\end_layout

\begin_layout Plain Layout
2 1
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
3
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Suggerimenti
\end_layout

\begin_layout Standard
Il problema è molto semplice, richiedendo a prima vista di lavorare su un
 vettore e applicando degli spostamenti ai suoi elementi, ma è istruttivo
 perchè si può migliorare la strategia risolutiva in maniera elegante e
 non immediatamente ovvia.
\end_layout

\begin_layout Itemize
Dato che ogni macchina è rappresentata da un numero, quale sarà la struttura
 dati più adatta a memorizzare la griglia di partenza? 
\end_layout

\begin_layout Itemize
Ogni sorpasso corrisponde a scambiare tra loro due elementi del vettore,
 solo che non so quali sono, quindi devo ogni volta scorrere il vettore
 per trovare le macchine, potrei evitare questa continua ricerca?
\end_layout

\begin_layout Itemize
E se al posto di memorizzare il numero di macchina come valore lo usassi
 come indice del vettore e nella casella corrispondente mettessi la posizione
 della macchina? Cosa cambierebbe? Avrei ancora bisogno di cercare le macchine
 o sarebbero immediatamente individuate dall'indice del vettore?
\end_layout

\begin_layout Itemize
Se uso il numero di macchina come indice e il valore corrispondente come
 posizione, cosa vuol dire in questo caso effettuare un sorpasso?
\end_layout

\begin_layout Itemize
Finora si è dato per scontato che sia necessario avere un vettore, ma è
 davvero necessario considerando che mi interessa solo il primo classificato?
\end_layout

\begin_layout Subsection
Soluzione
\end_layout

\begin_layout Standard
Per questo esercizio verranno presentate tre soluzioni, in quello che a
 me sembra l'ordine di intuitività, nel senso che verrà mostrata prima quella
 più intuitiva e via via quelle meno ovvie, il ché non vuole dire che qualcuno
 non possa trovare più intuitiva l'ultima presentata, ma solo che dai miei
 colloqui con alcuni alunni (e anche a mia impressione), di solito la soluzione
 che viene in mente è la prima, che adesso vedremo.
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "basicstyle={\small\ttfamily},frame=lr,language={C++},numbers=left,showstringspaces=false,tabsize=4"
inline false
status collapsed

\begin_layout Plain Layout

int vetture[31]; 
\end_layout

\begin_layout Plain Layout

int N,M; 
\end_layout

\begin_layout Plain Layout

void sorpasso(int A, int B) { 	
\end_layout

\begin_layout Plain Layout

	int i; 	
\end_layout

\begin_layout Plain Layout

	for (i=0;i < N;i++) 		
\end_layout

\begin_layout Plain Layout

		if (vetture[i] == A) break; 	
\end_layout

\begin_layout Plain Layout

	int temp = vetture[i]; 	
\end_layout

\begin_layout Plain Layout

	vetture[i] = vetture [i-1]; 	
\end_layout

\begin_layout Plain Layout

	vetture[i-1] = temp; 
\end_layout

\begin_layout Plain Layout

} 
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

int main() 
\end_layout

\begin_layout Plain Layout

{ 	
\end_layout

\begin_layout Plain Layout

	fstream in,out; 	
\end_layout

\begin_layout Plain Layout

	in.open("input.txt",ios::in); 	25).
\end_layout

\begin_layout Plain Layout

	out.open("output.txt",ios::out); 	
\end_layout

\begin_layout Plain Layout

	in >> N >> M; 	
\end_layout

\begin_layout Plain Layout

	for (int i=0;i < N;i++) 		
\end_layout

\begin_layout Plain Layout

		in >> vetture[i];     
\end_layout

\begin_layout Plain Layout

	for (int i=0;i < M;i++) { 		
\end_layout

\begin_layout Plain Layout

		int A, B; 		
\end_layout

\begin_layout Plain Layout

		in >> A >> B; 		
\end_layout

\begin_layout Plain Layout

		sorpasso(A,B); 	
\end_layout

\begin_layout Plain Layout

	} 	
\end_layout

\begin_layout Plain Layout

	out << vetture[0];	 	
\end_layout

\begin_layout Plain Layout

	return 0; 
\end_layout

\begin_layout Plain Layout

}	
\end_layout

\end_inset


\end_layout

\begin_layout Standard
La prima idea è quella di 
\begin_inset Quotes eld
\end_inset

mappare
\begin_inset Quotes erd
\end_inset

 direttamente il problema attraverso un vettore, poichè sembra naturale
 usare l'indice del vettore come posizione della macchina e nel valore corrispon
dente inserire il numero di macchina, come viene fatto nelle righe 18-19.
 A questo punto il sorpasso non è altro che lo scambio di posto tra due
 macchine, anche questo conseguenza diretta del modo naturale di modellare
 il problema.
 L'unica cosa da notare nella funzione 
\emph on
sorpasso
\emph default
 (righe 3-10) è che basta trovare la posizione della prima macchina per
 scambiarla con la macchina in posizione precedente, poichè nel problema
 si dice che il sorpasso avviene sempre tra macchine consecutive.
 Effettuati tutti i sorpassi non resta che stampare l'elemento in prima
 posizione (riga 25).La soluzione è molto semplice, però richiede ad ogni
 sorpasso di cercare nel vettore la macchina interessata e questo porta
 a una complessità computazionale di tipo quadratico: mediamente cercare
 un elemento in un vettore è proporzionale alla lunghezza del vettore e
 questa ricerca viene fatta tante volte quanti sono i sorpassi, perciò se
 numero di macchine e numero di sorpasso sono confrontabili e vicini a N,
 la complessità della soluzione sarà di tipo 
\begin_inset Formula $N^{2}$
\end_inset

.
\end_layout

\begin_layout Standard
Per evitare di fare la ricerca si può pensare di usare il numero di macchina
 come indice e di memorizzare nelle celle del vettore le posizioni in gara,
 ribaltando quanto fatto prima.
 Se ad esempio la macchina 4 è in sesta posizione, nel vettore l'elemento
 di indice 4 (numero della macchina) conterrà il valore 6 (posizione della
 macchina).
 Questo diverso modo di vedere il problema porta alla seguente soluzione:
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "basicstyle={\small\ttfamily},frame=lr,language={C++},numbers=left,showstringspaces=false,tabsize=4"
inline false
status collapsed

\begin_layout Plain Layout

int vetture[31]; 
\end_layout

\begin_layout Plain Layout

int N,M; 
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

int main() 
\end_layout

\begin_layout Plain Layout

{ 	
\end_layout

\begin_layout Plain Layout

	fstream in,out; 	
\end_layout

\begin_layout Plain Layout

	in.open("input.txt",ios::in); 	
\end_layout

\begin_layout Plain Layout

	out.open("output.txt",ios::out); 	
\end_layout

\begin_layout Plain Layout

	in >> N >> M; 	
\end_layout

\begin_layout Plain Layout

	for (int i=1;i <= N;i++) {	 		
\end_layout

\begin_layout Plain Layout

		int temp; 		
\end_layout

\begin_layout Plain Layout

		in >> temp; 		
\end_layout

\begin_layout Plain Layout

		vetture[temp] = i; 	
\end_layout

\begin_layout Plain Layout

	} 	
\end_layout

\begin_layout Plain Layout

	for (int i=0;i < M;i++) { 		
\end_layout

\begin_layout Plain Layout

		int A, B; 		
\end_layout

\begin_layout Plain Layout

		in >> A >> B; 		
\end_layout

\begin_layout Plain Layout

		vetture[A]--; 		
\end_layout

\begin_layout Plain Layout

		vetture[B]++; 	
\end_layout

\begin_layout Plain Layout

	} 	
\end_layout

\begin_layout Plain Layout

	for (int i=1;i <=N;i++) 		
\end_layout

\begin_layout Plain Layout

		if (vetture[i] == 1)	
\end_layout

\begin_layout Plain Layout

			out << i << endl;	 	 	
\end_layout

\begin_layout Plain Layout

	return 0; 
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Come si vede alle righe 10-14 il vettore viene costruito seguendo quanto
 detto e a questo punto il sorpasso non è altro che un decremento di posizione
 per la macchina che sorpassa (migliora di 1 la propria posizione) e un
 incremento per la macchina sorpassata (peggiora di 1 la propria posizione).
 Questo evita di dover ricercare nel vettore la macchina e quindi la complessità
 scende da 
\begin_inset Formula $N^{2}$
\end_inset

 a 
\begin_inset Formula $N$
\end_inset

.
 È vero che rispetto alla soluzione di prima adesso bisogna cercare nel
 vettore quale macchina ha posto 1, cioè ha vinto la gara, ma questo ha
 costo ancora N e quindi il costo totale della soluzione rimane N.
\end_layout

\begin_layout Standard
A questo punto però può sorgere il sospetto che forse, dovendo solo stampare
 la prima posizione, non serva tenere traccia realmente delle posizioni
 di tutte le macchine, ma basti sapere solo chi di volta in volta è in testa.
 In effetti, supponendo che alla partenza sia in testa la macchina A, l'unica
 cosa che ci interessa è se ci sono sorpassi in cui una qualsiasi macchina
 supera A, perchè se così è sarà quella macchina a guidare la gara.
 A questo punto si ripete lo stesso ragionamente solo che stavolta lo si
 applicherà alla nuova macchina che guida la gara e così via, fino ad avere
 esaminato tutti i sorpassi, ottenendo così il vincitore della gara.
 Questa idea porta al codice seguente:
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "basicstyle={\small\ttfamily},frame=lr,language={C++},numbers=left,showstringspaces=false,tabsize=4"
inline false
status collapsed

\begin_layout Plain Layout

int primo; 
\end_layout

\begin_layout Plain Layout

int N,M; 
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

int main() 
\end_layout

\begin_layout Plain Layout

{ 	
\end_layout

\begin_layout Plain Layout

	fstream in,out; 	
\end_layout

\begin_layout Plain Layout

	in.open("input.txt",ios::in); 	
\end_layout

\begin_layout Plain Layout

	out.open("output.txt",ios::out); 	
\end_layout

\begin_layout Plain Layout

	in >> N >> M; 	
\end_layout

\begin_layout Plain Layout

	in >> primo;
\end_layout

\begin_layout Plain Layout

	for (int i=2;i <= N;i++) {	 		
\end_layout

\begin_layout Plain Layout

		int temp; 		
\end_layout

\begin_layout Plain Layout

		in >> temp; 	
\end_layout

\begin_layout Plain Layout

	} 	
\end_layout

\begin_layout Plain Layout

	for (int i=0;i < M;i++) { 		
\end_layout

\begin_layout Plain Layout

		int A, B; 		
\end_layout

\begin_layout Plain Layout

		in >> A >> B; 		
\end_layout

\begin_layout Plain Layout

		if (B == primo) 			
\end_layout

\begin_layout Plain Layout

			primo = A; 	
\end_layout

\begin_layout Plain Layout

	} 	
\end_layout

\begin_layout Plain Layout

	out << primo << endl;	 	
\end_layout

\begin_layout Plain Layout

	return 0; 
\end_layout

\begin_layout Plain Layout

}	
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Alla riga 10 viene letta la macchina in 
\begin_inset Quotes eld
\end_inset

pole position
\begin_inset Quotes erd
\end_inset

, le successive letture (righe 11-14) sono necessarie solo per avanzare
 con la lettura, ma tutte le informazioni vengono 
\begin_inset Quotes eld
\end_inset

buttate via
\begin_inset Quotes erd
\end_inset

.
 Successivamente si controllano tutti i sorpassi e solo se viene superata
 la macchina che in quel momento è alla testa della gara si provvede a inserire
 il nuovo capoclassifica.
 Alla fine nella variabile 
\emph on
primo
\emph default
 ci sarà il vincitore della gara.
 Rispetto alla soluzione precedente questa è sostanzialmente comparabile
 dal punto di vista della complessità computazionale (entrambe sono di tipo
 lineare, sebbene quest'ultima preveda qualche operazione in meno), ma l'occupaz
ione della memoria passa da N (la lunghezza del vettore) a 1.
\end_layout

\begin_layout Standard
Dopo aver visto queste tre diverse soluzioni ci si potrebbe domandare se
 vale la pena durante la gara di 
\begin_inset Quotes eld
\end_inset

limare
\begin_inset Quotes erd
\end_inset

 l'idea risolutiva per passare da una soluzione di complessità quadratica
 e occupazione di memoria di tipo lineare a una con complessità lineare
 e occupazione di memoria unitaria.
 La risposta in questo caso è NO, poichè date le assunzioni del problema
 (massimo 30 macchine e 100 sorpassi) anche eventuali soluzioni di tipo
 cubico sarebbero andate più che bene.
 Diverso sarebbe stato il discorso se il numero massimo di macchine fosse
 stato ad esempio 1000000 con un numero di sorpassi anch'esso limitato a
 1000000: in questo caso la soluzione quadratica non sarebbe stata in grado
 di risolvere i casi con input grosso, mentre le ultime due sì.
 Si può ancora notare come informazioni non direttamente inerenti al problema
 (le assunzioni sulle dimensioni dell'input) possano aiutare a non perdere
 tempo durante la gara.
\end_layout

\begin_layout Section
Turni di guardia - territoriali 2012
\end_layout

\begin_layout Standard
\begin_inset Box Framed
position "t"
hor_pos "c"
has_inner_box 0
inner_pos "t"
use_parbox 0
use_makebox 0
width "100col%"
special "none"
height "1in"
height_special "totalheight"
thickness "0.4pt"
separation "3pt"
shadowsize "4pt"
framecolor "black"
backgroundcolor "none"
status collapsed

\begin_layout Subsection*
Turni di guardia (turni)
\end_layout

\begin_layout Subsubsection*
Difficoltà D = 2.
 
\end_layout

\begin_layout Subsubsection*
Descrizione del problema
\end_layout

\begin_layout Plain Layout
La Banda Bassotti è stata rimessa in libertà.
 Zio Paperone, in partenza per un viaggio di K giorni, ha la necessità di
 far sorvegliare il deposito: quindi ha bisogno che sia sempre presente
 almeno una persona.
 Per risparmiare, decide di chiedere la disponibilità di amici e parenti,
 e ognuno di questi fornisce un intervallo di giorni in cui è disponibile
 per la sorveglianza.
 Paperone però sa che dovrà fare un regalo a ognuna delle persone che userà,
 e volendo risparmiare al massimo deve coinvolgere il minimo numero di persone,
 senza lasciare mai il deposito scoperto.
 In questo modo riuscirà a risparmiare sui regali.
\end_layout

\begin_layout Plain Layout
Per esempio, supponiamo che il viaggio di Zio Paperone sia di K=8 giorni,
 con partenza il giorno 0 e ritorno il giorno K-1=7 e che le disponibilità
 siano le seguenti (per ogni nome, tra parentesi si indicano il giorno iniziale
 e il giorno finale della disponibilità).
\end_layout

\begin_layout Plain Layout
Paperino (3,5) 
\end_layout

\begin_layout Plain Layout
Paperoga (0,2) 
\end_layout

\begin_layout Plain Layout
Battista (1,3) 
\end_layout

\begin_layout Plain Layout
Gastone (5,6) 
\end_layout

\begin_layout Plain Layout
Archimede (4,7)
\end_layout

\begin_layout Plain Layout
In questo caso, a Zio Paperone basta coinvolgere Paperoga, Paperino e Archimede
 per assicurarsi che il deposito sia sempre sorvegliato, e se la cava con
 tre regali.
\end_layout

\begin_layout Plain Layout
Sapendo il numero di giorni di viaggio, e le disponibilità di ognuno, il
 vostro compito è quello di aiutare Zio Paperone a calcolare il minimo numero
 di persone che servono ad assicurare una sorveglianza continua al deposito.
 
\end_layout

\begin_layout Subsubsection*
Dati di input
\end_layout

\begin_layout Plain Layout
Il file di input è costituito da 2+N righe.
 La prima riga contiene un intero positivo K, ovvero il numero di giorni
 del viaggio.
 La seconda riga contiene un intero positivo N, il numero di persone che
 hanno dato la disponibilità a Zio Paperone.
 Le restanti N righe contengono una coppia di interi A e B per ognuna delle
 N persone: questa coppia di interi rappresenta l'inizio e la fine della
 disponibilità della i-esima persona.
 
\end_layout

\begin_layout Subsubsection*
Dati di output
\end_layout

\begin_layout Plain Layout
Il file di output deve contenere un solo intero positivo R, che è il numero
 minimo di persone necessarie ad assicurare una sorveglianza continua al
 deposito.
 
\end_layout

\begin_layout Subsubsection*
Assunzioni
\end_layout

\begin_layout Plain Layout
1 ≤ K, N ≤ 50 Per ognuna delle N righe, si ha 0 ≤ A ≤ B ≤ K-1 Esiste sempre
 almeno una soluzione in ognuno dei casi di input.
\end_layout

\begin_layout Subsubsection*
Esempi di input/output 
\end_layout

\begin_layout Plain Layout
\begin_inset Tabular
<lyxtabular version="3" rows="2" columns="2">
<features tabularvalignment="middle">
<column alignment="left" valignment="top" width="1in">
<column alignment="left" valignment="top">
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
File input.txt
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
File output.txt
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
8 
\end_layout

\begin_layout Plain Layout
5 
\end_layout

\begin_layout Plain Layout
3 5 
\end_layout

\begin_layout Plain Layout
0 2 
\end_layout

\begin_layout Plain Layout
1 3 
\end_layout

\begin_layout Plain Layout
5 6 
\end_layout

\begin_layout Plain Layout
4 7
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
3
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Suggerimenti
\end_layout

\begin_layout Standard
Il problema assomiglia molto ai precedenti 
\begin_inset Quotes eld
\end_inset

Giri sulla scopa Nimbus 3000
\begin_inset Quotes erd
\end_inset

 (territoriali 2007 
\begin_inset CommandInset ref
LatexCommand vpageref
reference "sec:Esempio:Nimbus"

\end_inset

 e 
\begin_inset Quotes eld
\end_inset

Missioni segrete
\begin_inset Quotes erd
\end_inset

 (territoriali 2008 
\begin_inset CommandInset ref
LatexCommand vpageref
reference "sec:Esempio-Missioni"

\end_inset

), si tratta di vedere a che tipologia di problema appartiene, se è risolubile
 tramite un approccio 
\emph on
greedy
\emph default
 (più semplice) o necessita della 
\emph on
programmazione dinamica
\emph default
.
\end_layout

\begin_layout Itemize
Come possono essere rappresentati i turni?
\end_layout

\begin_layout Itemize
Nell'algoritmo risolutivo i turni possono essere trattati in un qualsiasi
 ordine oppure un ordinamento secondo qualche criterio può essere essenziale
 per arrivare alla soluzione del problema? 
\end_layout

\begin_layout Itemize
Se sì, secondo quale criterio (giorno di inizio, giorno di fine, durata)
 possono essere ordinati i turni?
\end_layout

\begin_layout Itemize
Una volta scelto che un turno fa parte dell'insieme minimo dei turni, questa
 scelta potrebbe in un secondo momento essere messa in discussione (e quindi
 si dovrebbe utilizzare la 
\emph on
programmazione dinamica
\emph default
) oppure no (e quindi il modo corretto di procedere sarebbe di quello di
 utilizzare una strategia 
\emph on
greedy
\emph default
)?
\end_layout

\begin_layout Subsection
Soluzione
\end_layout

\begin_layout Standard
In questo problema si può arrivare molto velocemente alla soluzione se si
 riesce a stabilire che si tratta di un problema di tipo greedy.
 Si arriva a mostrare che è così tramite le seguenti osservazioni:
\end_layout

\begin_layout Enumerate
gli intervalli dei turni di guardia devono coprire completamente tutti i
 giorni, come da testo del problema, quindi esiste almeno un intervallo
 che inizia dal primo giorno: 
\begin_inset Separator latexpar
\end_inset


\end_layout

\begin_deeper
\begin_layout Itemize
se è solo uno lo scelgo e questa scelta non può essere cambiata, perchè
 nessun altro intervallo potrebbe coprire il primo giorno
\end_layout

\begin_layout Itemize
se sono più di uno scelgo quello che ha la data di fine maggiore, perchè
 sceglierne un altro comporterebbe solo un numero minore di giorni di 
\begin_inset Quotes eld
\end_inset

copertura
\begin_inset Quotes erd
\end_inset

 e nessun vantaggio.
 Anche in questo caso la scelta non potrà essere modificata successivamente,
 perchè nessuna altra scelta potrebbe portarmi in una situazione migliore
\end_layout

\end_deeper
\begin_layout Enumerate
a questo punto la data di fine del turno scelto sarà la nuova data di inizio
 per scegliere i turni successivi, reiterando il procedimento dal punto
 1, fino a quando non verrà selezionato un turno che finisce l'ultimo giorno.
\end_layout

\begin_layout Standard
In questo modo si è arrivati alla conclusione che il problema è di tipo
 
\emph on
greedy
\emph default
, e quindi conviene ordinare i turni di guardia usando come parametro per
 l'ordinamento il giorno di inizio, in modo da poter implementare in maniera
 efficiente l'algoritmo appena descritto.
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "basicstyle={\small\ttfamily},frame=lr,language={C++},numbers=left,showstringspaces=false,tabsize=4"
inline false
status open

\begin_layout Plain Layout

class Turno {  	
\end_layout

\begin_layout Plain Layout

	public: 	
\end_layout

\begin_layout Plain Layout

	int inizio, fine;  	
\end_layout

\begin_layout Plain Layout

	bool operator< (const Turno& t) const { 
\end_layout

\begin_layout Plain Layout

	return inizio < t.inizio;} 
\end_layout

\begin_layout Plain Layout

};
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

Turno turni[50]; 
\end_layout

\begin_layout Plain Layout

int K,N;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

int main() { 	
\end_layout

\begin_layout Plain Layout

	ifstream in("input.txt"); 	
\end_layout

\begin_layout Plain Layout

	ofstream out("output.txt"); 	
\end_layout

\begin_layout Plain Layout

	in >> K >> N; 	
\end_layout

\begin_layout Plain Layout

	for (int i=0; i<N; i++) 		
\end_layout

\begin_layout Plain Layout

		in >> turni[i].inizio >> turni[i].fine;     
\end_layout

\begin_layout Plain Layout

	sort(turni, turni + N); 	
\end_layout

\begin_layout Plain Layout

	int fine = -1; 	
\end_layout

\begin_layout Plain Layout

	int i = 0; 	
\end_layout

\begin_layout Plain Layout

	int quanti = 0; 	
\end_layout

\begin_layout Plain Layout

	while (fine < K-1){
\end_layout

\begin_layout Plain Layout

		int max = turni[i].fine; 		
\end_layout

\begin_layout Plain Layout

		while (turni[i].inizio - 1 <= fine){
\end_layout

\begin_layout Plain Layout

			if (turni[i].fine > max) max = turni[i].fine; 			
\end_layout

\begin_layout Plain Layout

			i++; 		
\end_layout

\begin_layout Plain Layout

		} 		
\end_layout

\begin_layout Plain Layout

		fine = max; 		
\end_layout

\begin_layout Plain Layout

		quanti++; 	
\end_layout

\begin_layout Plain Layout

	} 	
\end_layout

\begin_layout Plain Layout

	out << quanti << endl; 	
\end_layout

\begin_layout Plain Layout

	return 0;              
\end_layout

\begin_layout Plain Layout

}	
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Alle righe 1-5 viene definita la classe Turno (si poteva anche fare con
 una struttura) per gestire i turni, avente come attributi il giorno iniziale
 e finale e viene ridefinito l'operatore di minore perchè necessario all'algorit
mo di ordinamento (vedi 
\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:L'algoritmo-sort-C++"

\end_inset

).
 Dopo aver letto l'input (rige 13-15) viene chiamato l'algoritmo 
\emph on
sort
\emph default
 per ordinare il vettore dei turni a partire da quello che inizia per primo
 fino a quello che inizia per ultimo.
 Alla riga 17 viene inizializzato il valore del primo giorno a -1, in modo
 che l'algoritmo possa gestire in maniera corretta il fatto che un turno,
 per avere una copertura completa, possa iniziare a ridosso del turno precedente
 (eventualmente anche prima).
 Alla riga 20 inizia il ciclo principale, che terminerà non appena verrà
 inserito un turno che ha come giorno finale l'ultimo giorno da coprire.
 All'interno di questo ciclo ci sarà un ulteriore 
\emph on
while
\emph default
 (riga 22) che si occuperà di scegliere, tra i vari turni che possono essere
 aggiunti perchè hanno il giorno iniziale che permette di non lasciare 
\begin_inset Quotes eld
\end_inset

buchi
\begin_inset Quotes erd
\end_inset

, quello che ha il giorno finale maggiore (riga 23).
 Una volta scelto il nuovo turno da inserire verrà aggiornato il valore
 del giorno a cui finora si è riusciti a dare copertura e verrà incrementato
 il contatore dei turni.
\end_layout

\begin_layout Section
Barbablù - territoriali 2012
\end_layout

\begin_layout Standard
\begin_inset Box Framed
position "t"
hor_pos "c"
has_inner_box 0
inner_pos "t"
use_parbox 0
use_makebox 0
width "100col%"
special "none"
height "1in"
height_special "totalheight"
thickness "0.4pt"
separation "3pt"
shadowsize "4pt"
framecolor "black"
backgroundcolor "none"
status open

\begin_layout Subsection*
Il tesoro del Pirata Barbablù (barbablu) 
\end_layout

\begin_layout Subsubsection*
Difficoltà D = 2.
 
\end_layout

\begin_layout Subsubsection*
Descrizione del problema
\end_layout

\begin_layout Plain Layout
John Steam della compagnia "Oriental Steam Navigation" decide di organizzare
 una spedizione di recupero del tesoro del Pirata Barbablù, custodito nel
 relitto del galeone del pirata, affondato al largo di Gobal, che si trova
 adagiato su un fianco a 30 metri di profondità.
 L'unico punto di accesso al relitto è uno squarcio sulla fiancata, in corrispon
denza della cabina numero 1.
 Nel galeone sono presenti cabine e corridoi che le collegano.
 Tutti i corridoi sono totalmente sommersi dall'acqua a causa della rottura
 degli oblo mentre in alcune delle cabine sono rimaste delle sacche d'aria.
 A causa degli spazi angusti non è possibile, per i sommozzatori, esplorare
 la nave con le bombole d'aria; sono quindi costretti a nuotare in apnea,
 sfruttando le sacche d'aria presenti nel tragitto per respirare.
\end_layout

\begin_layout Plain Layout
Prima di procedere con le operazioni di recupero ti viene commissionata
 la realizzazione di un programma in grado di individuare il percorso più
 breve all'interno del galeone che permetta ai sommozzatori di raggiungere
 la cabina con il tesoro a partire dall'apertura.
 In alcune cabine sono presenti sacche d'aria che possono essere usate per
 respirare.
 Un sommozzatore riesce a nuotare senza aria per 20 metri al massimo prima
 di dover riprendere fiato.
\end_layout

\begin_layout Plain Layout
\begin_inset Graphics
	filename ../materiali/problemi territoriali/2012_barbablu/mappa.png
	lyxscale 50
	scale 60

\end_inset


\end_layout

\begin_layout Plain Layout
\align center
Figura 1
\end_layout

\begin_layout Plain Layout
In Figura 1 sono mostrati due possibili scenari.
 La cabina di ingresso è come detto la numero 1, mentre la cabina del tesoro
 (rappresentato da una T) è la numero 2 per l'esempio di sinistra, e la
 numero 4 per l'esempio di destra.
 Le cabine con la sacca d'aria sono quadrate, mentre quelle senza sacca
 sono tonde.
 A fianco di ogni corridoio è segnata la sua lunghezza in metri.
 L'esempio di sinistra ammette una sola soluzione, di lunghezza 29 metri,
 mentre quello di destra non ha soluzioni.
\end_layout

\begin_layout Plain Layout
Le cabine della nave sono numerate da 1 ad N e sono collegate tra loro da
 M corridoi.
 L'apertura è la numero 1 mentre il tesoro si trova nella cabina numero
 C (con 1 ≤ C ≤ N).
 Di ogni cabina si conosce l'eventuale presenza di aria e di ogni corridoio
 la lunghezza in metri.
\end_layout

\begin_layout Plain Layout
Il tuo compito è quello di trovare la lunghezza in metri del percorso più
 breve che permette ad un sommozzatore di partire dalla cabina con l'apertura
 e di raggiungere il tesoro, in apnea, sfruttando le eventuali sacche d'aria
 trovate nel percorso.
 La cabina del tesoro ha sempre una sacca d'aria, che consente al sommozzatore
 di recuperare il tesoro.
 
\end_layout

\begin_layout Subsubsection*
Dati di input
\end_layout

\begin_layout Plain Layout
Il file input.txt è composto da M+2 righe.
 La prima riga contiene quattro interi positivi separati da uno spazio,
 che rappresentano il numero N delle cabine, il numero M dei corridoi, il
 numero C che rappresenta la cabina del tesoro e il numero K che rappresenta
 quante cabine hanno sacche d'aria al loro interno.
 La seconda riga contiene K numeri separati da uno spazio che rappresentano
 i numeri (distinti) delle cabine che contengono aria.
 Ciascuna delle rimanenti M righe contiene tre interi I,J, L separati da
 uno spazio che indicano la presenza di un corridoio che collega le cabine
 I e J di lunghezza L (in metri).
 
\end_layout

\begin_layout Subsubsection*
Dati di output
\end_layout

\begin_layout Plain Layout
Il file output.txt è composto da una sola riga contenente la lunghezza in
 metri del percorso più breve che permetta, a partire dall'apertura, di
 raggiungere la cabina del tesoro in apnea.
 Riportare -1 se non esiste nessun percorso che soddisfa i vincoli.
 
\end_layout

\begin_layout Subsubsection*
Assunzioni
\end_layout

\begin_layout Itemize
2 ≤ N ≤ 30; 
\end_layout

\begin_layout Itemize
2 ≤ M ≤ 100 1 ≤ C ≤ N; 
\end_layout

\begin_layout Itemize
0≤ K ≤ N
\end_layout

\begin_layout Subsubsection*
Esempi di input/output 
\end_layout

\begin_layout Plain Layout
\begin_inset Tabular
<lyxtabular version="3" rows="2" columns="2">
<features tabularvalignment="middle">
<column alignment="left" valignment="top" width="1in">
<column alignment="left" valignment="top">
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
File input.txt
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
File output.txt
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
3 3 2 2 
\end_layout

\begin_layout Plain Layout
2 3 
\end_layout

\begin_layout Plain Layout
1 2 22 
\end_layout

\begin_layout Plain Layout
1 3 15 
\end_layout

\begin_layout Plain Layout
2 3 14
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
29
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset VSpace bigskip
\end_inset


\begin_inset Tabular
<lyxtabular version="3" rows="2" columns="2">
<features tabularvalignment="middle">
<column alignment="left" valignment="top" width="1in">
<column alignment="left" valignment="top">
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
File input.txt
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
File output.txt
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
4 5 4 2 
\end_layout

\begin_layout Plain Layout
3 4 
\end_layout

\begin_layout Plain Layout
1 2 11 
\end_layout

\begin_layout Plain Layout
1 3 7 
\end_layout

\begin_layout Plain Layout
1 4 23 
\end_layout

\begin_layout Plain Layout
2 4 14 
\end_layout

\begin_layout Plain Layout
3 4 21
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
-1
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Suggerimenti
\end_layout

\begin_layout Standard
Il problema, a una prima lettura, sembra potersi ricondurre a una ben precisa
 tipologia di algoritmi, anche se alcuni vincoli possono modificare la strategia
 risolutiva in maniera non ovvia.
\end_layout

\begin_layout Itemize
Qual è la struttura dati più adatta per rappresentare i dati in input, considera
ndo le figure mostrate nel testo?
\end_layout

\begin_layout Itemize
Quali sono i dati importanti che devono essere memorizzati e come inserirli
 all'interno della struttura dati proposta (oppure mantenerli come variabili
 esterne)?
\end_layout

\begin_layout Itemize
Che strategia risolutiva posso adottare considerando che mi viene chiesto
 di trovare un cammino minimo con certe condizioni (l'ossigeno) che limitano
 il numero di percorsi possibili?
\end_layout

\begin_layout Itemize
Le condizioni sull'ossigeno, oltre a limitare il numero di percorsi possibili,
 possono dare origine a dei casi particolari che l'algoritmo pensato in
 precedenza potrebbe non trattare?
\end_layout

\begin_layout Itemize
Se sì, esistono delle modifiche semplici che potrebbero portare a una soluzione
 sempre corretta?
\end_layout

\begin_layout Subsection
Soluzione
\end_layout

\begin_layout Standard
Già dalla prima lettura del testo si può intuire come questo problema possa
 essere affrontato avendo delle conoscenze di base sulla teoria dei grafi.
 Le figure mostrate chiariscono immediatamente che la rappresentazione naturale
 di questo problema è un grafo, dove i nodi sono le cabine e i corridoi
 sono gli archi: in particolare il problema risulta quello di trovare un
 cammino minimo che porta dal nodo di partenza al nodo dove è contenuto
 il tesoro.
 Come visto in questa guida esiste un algoritmo efficiente per raggiungere
 questo scopo (vedi pagina 
\begin_inset CommandInset ref
LatexCommand pageref
reference "sec: cammino_minimo"

\end_inset

), ma anche una visita in ampiezza (vedi pagina 
\begin_inset CommandInset ref
LatexCommand pageref
reference "sec:visite"

\end_inset

) opportunamente modificata può risolvere il problema, a fronte di una difficolt
à implementativa decisamente minore.
\end_layout

\begin_layout Standard
Adesso si vedrà come una visita in ampiezza può portare a una soluzione
 adeguata del problema, dove per adeguata si intende che è in grado di trovare
 il risultato corretto in buona parte dei casi proposti
\begin_inset Foot
status collapsed

\begin_layout Plain Layout
Al momento della stesura di questo paragrafo la soluzione proposta risolve
 correttamente tutti i casi di test presenti sul correttore del sito italiano
 delle Olimpiadi di Informatica.
\end_layout

\end_inset

, per poi discutere i limiti di questa soluzione.
 Rispetto a una visita 
\begin_inset Quotes eld
\end_inset

normale
\begin_inset Quotes erd
\end_inset

, in questo caso è necessario tenere traccia in ogni cabina della migliore
 distanza che si è trovata fino a quel momento e dell'aria rimasta al sub
 per arrivare fino ad essa.
 Man mano che la visita procede questi valori verranno aggiornati, fino
 a quando si arriverà ad avere per ogni nodo il minor costo possibile del
 cammino per raggiungerlo e a questo punto nella cabina del tesoro sarà
 contenuta la soluzione.
\end_layout

\begin_layout Standard
Una semplice implementazione di questa idea è quella mostrata nel codice
 sottostante.
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "basicstyle={\small\ttfamily},frame=lr,language={C++},numbers=left,showstringspaces=false,tabsize=4"
inline false
status collapsed

\begin_layout Plain Layout

#define INFINITO 1000000
\end_layout

\begin_layout Plain Layout

struct corridoio{ 	
\end_layout

\begin_layout Plain Layout

	int porta_a, lunghezza; 	
\end_layout

\begin_layout Plain Layout

	corridoio(int p, int l):porta_a(p), lunghezza(l){} 
\end_layout

\begin_layout Plain Layout

};
\end_layout

\begin_layout Plain Layout

struct cabina{ 	
\end_layout

\begin_layout Plain Layout

	bool aria; 	
\end_layout

\begin_layout Plain Layout

	list <corridoio> corridoi; 	
\end_layout

\begin_layout Plain Layout

	int distanza; 	
\end_layout

\begin_layout Plain Layout

	int ossigeno_rimasto; 	
\end_layout

\begin_layout Plain Layout

	cabina():aria(false), distanza(INFINITO),ossigeno_rimasto(20){} 
\end_layout

\begin_layout Plain Layout

};
\end_layout

\begin_layout Plain Layout

cabina cabine[31]; 
\end_layout

\begin_layout Plain Layout

int N,M,C,K;
\end_layout

\begin_layout Plain Layout

queue <int> coda;
\end_layout

\begin_layout Plain Layout

void visita() {	 	
\end_layout

\begin_layout Plain Layout

	while (!coda.empty()){
\end_layout

\begin_layout Plain Layout

		int c = coda.front(); 		
\end_layout

\begin_layout Plain Layout

		coda.pop(); 		
\end_layout

\begin_layout Plain Layout

		list <corridoio>::iterator i = cabine[c].corridoi.begin(); 		
\end_layout

\begin_layout Plain Layout

		for (; i != cabine[c].corridoi.end(); i++){
\end_layout

\begin_layout Plain Layout

			if (i->lunghezza < cabine[c].ossigeno_rimasto){ 				
\end_layout

\begin_layout Plain Layout

				if (cabine[c].distanza + i->lunghezza < 
\end_layout

\begin_layout Plain Layout

					cabine[i->porta_a].distanza){
\end_layout

\begin_layout Plain Layout

						cabine[i->porta_a].distanza = 
\end_layout

\begin_layout Plain Layout

						cabine[c].distanza + i->lunghezza;
\end_layout

\begin_layout Plain Layout

						if (cabine[i->porta_a].aria == false) 						
\end_layout

\begin_layout Plain Layout

							cabine[i->porta_a].ossigeno_rimasto =
\end_layout

\begin_layout Plain Layout

							cabine[c].ossigeno_rimasto - i->lunghezza;
\end_layout

\begin_layout Plain Layout

						coda.push(i->porta_a); 				
\end_layout

\begin_layout Plain Layout

				} 			
\end_layout

\begin_layout Plain Layout

			} 		
\end_layout

\begin_layout Plain Layout

		} 	
\end_layout

\begin_layout Plain Layout

	} 
\end_layout

\begin_layout Plain Layout

} 
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

int main() { 	
\end_layout

\begin_layout Plain Layout

	ifstream in("input.txt"); 	
\end_layout

\begin_layout Plain Layout

	ofstream out("output.txt"); 	
\end_layout

\begin_layout Plain Layout

	in >> N >> M >> C >> K; 	
\end_layout

\begin_layout Plain Layout

	for (int i = 0; i < K; i++){ 		
\end_layout

\begin_layout Plain Layout

		int temp; 		
\end_layout

\begin_layout Plain Layout

		in >> temp; 		
\end_layout

\begin_layout Plain Layout

		cabine[temp].aria = true; 	
\end_layout

\begin_layout Plain Layout

	} 	
\end_layout

\begin_layout Plain Layout

	for (int i = 0; i < M; i++){ 		
\end_layout

\begin_layout Plain Layout

		int r,s,t; 		
\end_layout

\begin_layout Plain Layout

		in >> r >> s >> t; 		
\end_layout

\begin_layout Plain Layout

		corridoio c(s,t); 		
\end_layout

\begin_layout Plain Layout

		cabine[r].corridoi.push_back(c); 		
\end_layout

\begin_layout Plain Layout

		corridoio d(r,t); 		
\end_layout

\begin_layout Plain Layout

		cabine[s].corridoi.push_back(d); 	
\end_layout

\begin_layout Plain Layout

	} 	
\end_layout

\begin_layout Plain Layout

	coda.push(1); 	
\end_layout

\begin_layout Plain Layout

	cabine[1].distanza = 0; 	
\end_layout

\begin_layout Plain Layout

	visita(); 	
\end_layout

\begin_layout Plain Layout

	if (cabine[C].distanza == INFINITO) 		
\end_layout

\begin_layout Plain Layout

		out << "-1" << endl; 	
\end_layout

\begin_layout Plain Layout

	else 		
\end_layout

\begin_layout Plain Layout

		out << cabine[C].distanza << endl; 	
\end_layout

\begin_layout Plain Layout

	return 0; 
\end_layout

\begin_layout Plain Layout

}	
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Come prima cosa vengono definite le strutture per gestire i dati di corridoi
 e cabine: ogni corridoio (righe 2-5) contiene informazioni sulla cabina
 verso la quale è diretto e la sua lunghezza, mentre ogni cabina (righe
 6-12) ha un flag booleano per indicare se contiene sacche d'aria o no,
 la lista dei corridoi che partono o arrivano a quella cabina, la distanza
 minima per arrivare a quella cabina partendo dalla cabina 1, che viene
 inizializzata a INFINITO dal costruttore, e la quantità di ossigeno rimasto
 rispetto al percorso fatto per giungere a quella cabina.
 Per memorizzare i dati viene quindi creato un vettore di cabine (lungo
 31 e non 30 per lavorare con gli indici dei dati del problema che partono
 da 1 e non da 0) e anche una coda che servirà nell'implementazione della
 visita in ampiezza.
\end_layout

\begin_layout Standard
Dopo aver letto i dati in input e averli inseriti nel vettore delle cabine
 (righe 40-53), viene inserita la prima cabina nella coda e viene chiamata
 la funzione che effettuerà la visita in ampiezza, registrando tutti i valori
 calcolati dei cammini per raggiungere le varie cabine.
 Questa funzione (righe 16-35) durante le visite registrerà nelle cabine
 la lunghezza minima in questo modo:
\end_layout

\begin_layout Itemize
viene estratta dalla coda il numero di cabina corrente, finchè ce ne sono
 (righe 17-19)
\end_layout

\begin_layout Itemize
per ognuno dei corridoi che partono da quella cabina (righe 20-21) si controlla
 che sia possibile attraversarlo, dato l'ossigeno rimasto nella cabina corrente
 (riga 22)
\end_layout

\begin_layout Itemize
se è possibile si verifica se la cabina alla quale porta quel corridoio
 verrà raggiunta con un percorso più corto di quello già presente nella
 cabina di arrivo (righe 23-24): se la cabina è la prima volta che viene
 visitata questa condizione sarà ovviamente vera, perchè la distanza era
 stata inizializzata a INFINITO, se non è la prima volta, la condizione
 sarà vera se il nuovo percorso è più corto di quello trovato in precedenza
 
\end_layout

\begin_layout Itemize
in caso di condizione soddisfatta verrà aggiornato il valore della distanza
 e se la cabina non contiene sacche d'aria verrà anche aggiornato il nuovo
 valore di ossigeno rimasto
\end_layout

\begin_layout Itemize
infine la cabina alla quale ha portato il corridoio verrà inserita in coda,
 per essere elaborata nei successivi passaggi.
\end_layout

\begin_layout Standard
Alla fine della funzione nella cabina numero C si troverà la distanza minima
 per raggiungerla oppure INFINITO, nel qual caso significa che non esiste
 un cammino per raggiungere la cabina del tesoro che soddisfi le condizioni
 sull'ossigeno.
\end_layout

\begin_layout Standard
Come si può vedere il codice non presenta delle complessità particolari,
 come già detto è una visita in ampiezza con aggiunte le condizioni descritte
 nel problema.
 Rimangono però dei problemi interessanti e non immediatamente visibili
 che verranno discussi adesso.
\end_layout

\begin_layout Standard
Un primo problema che può sorgere è quello di domandarsi se il numero di
 cammini da esplorare non sia troppo grande e quindi non computabile in
 un tempo ragionevole.
 Questo dipende ovviamente da quanti sono i cammini possibili in un grafo,
 dato che il nostro algoritmo tende a esplorarli tutti: l'esatto numero
 dipende oltre che dal numero di vertici e archi anche da come questi sono
 connessi, in generale comunque sono in un numero che cresce esponenzialmente
 al crescere dei vertici, come si era già visto in un semplice esempio a
 pagina 
\begin_inset CommandInset ref
LatexCommand pageref
reference "sec: cammino_minimo"

\end_inset

.
 In questo problema il numero di vertici viene limitato a 30 e il numero
 di archi a 100, ma anche in questo caso potrebbero esserci grafi la cui
 esplorazione, se venissero analizzati tutti i cammini, richiederebbe troppo
 tempo.
 Di fatto questo però non dovrebbe succedere, perchè le limitazioni sull'ossigen
o e il fatto che non vengono riesplorati percorsi che si sa già non poter
 essere minimi portano a drastiche riduzioni del numero di percorsi esplorati.
 Esistono poi delle semplici modifiche al codice proposto, lasciate come
 esercizio al lettore, che possono ridurre ancora di più il numero potenziale
 di percorsi:
\end_layout

\begin_layout Itemize
nell'input di esempio sono presenti dei corridoi di lunghezza maggiore di
 20: è evidente che tali corridoi non potranno mai essere percorsi dal sub,
 quindi non devono essere inseriti nel grafo
\end_layout

\begin_layout Itemize
quando si arriva alla cabina del tesoro si può memorizzare la lunghezza
 minore trovata fino a quel momento, che non è detto essere quella finale,
 ma che sicuramente pone un limite superiore agli altri percorsi che devono
 ancora essere visitati: se cioè mentre procedo con le visite mi accorgo
 di arrivare a delle cabine intermedie con una distanza superiore al valore
 attuale del percorso per arrivare al tesoro, non procederò oltre perchè
 sicuramente quel percorso non potrà migliorare il costo per arrivare alla
 cabina del tesoro.
\end_layout

\begin_layout Standard
Un'altra domanda che potrebbe sorgere è quella se convenga scegliere una
 visita in ampiezza o in profondità: in problemi come questi dove le visite
 vengono usate per esplorare i cammini senza sapere a priori nulla sulle
 caratteristiche del percorso più breve, non c'è differenza tra l'una e
 l'altra e quindi la scelta non è importante: anche in questo caso il lettore
 è invitato a provare a sostituire la coda con una pila e verificare che
 le prestazioni mediamente non cambiano.
\end_layout

\begin_layout Standard
Rimane un ultimo interrogativo che, pur essendo approfondito per ultimo,
 è quello più importante: ma l'algoritmo proposto è in grado di trovare
 la soluzione in tutti i casi possibili? La risposta purtroppo è no e il
 perchè lo si può vedere dall'esempio di figura 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:Casi-barbablu"

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename ../materiali/problemi territoriali/2012_barbablu/esempio cattivo totale.eps
	display false
	scale 60

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:Casi-barbablu"

\end_inset

Casi 
\begin_inset Quotes eld
\end_inset

problematici
\begin_inset Quotes erd
\end_inset

 per il problema
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Se si guarda il grafo (a), l'algoritmo proposto darebbe come cammino minimo
 54, ottenuto percorrendo i vertici 1 - 2 - 4 - 5 - 6.
 In realtà si vede subito che il percorso 1 - 3 - 4 - 2 - 6 darebbe un risultato
 migliore (46), ma l'algoritmo non può scoprirlo perchè la cabina 2 può
 essere raggiunta con costo 15 e quindi passare da 3 e 4 darebbe un risultato
 peggiore, anche se poi verrebbe ripagato dal minore costo dell'arco 2 -
 6.
 Ovviamente fare direttamente 1 - 2 - 6 non è possibile, perchè non si riesce
 a percorrere il corridoio 2 - 6 avendo solo una riserva di ossigeno pari
 a 5, ma se si guarda meglio si può vedere che c'è una possibilità non evidente
 che permette di ottenre un valore minore di 46: se il sub, dopo essere
 arrivato alla cabina 2 direttamente dalla cabina 1 va alla cabina 4 per
 riprendere fiato (la sua scorta di ossigeno torna a 20), poi può tornare
 indietro e andare dalla 2 alla 6 perchè adesso ha una riserva di ossigeno
 di 19.
 Quindi il cammino minimo per arrivare al tesoro costa 24 ed è 1 - 2 - 4
 - 2 - 6.
 
\end_layout

\begin_layout Standard
Perchè l'algoritmo proposto non lo trova? Per come è fatto non è in grado
 di tornare sui propri passi, cioè trovare cammini che contengano più volte
 lo stesso nodo e questo gli impedisce di scoprire cammini come quello dell'esem
pio (a): però con alcune semplici modifiche si può fare in modo che vengano
 scoperti percorsi come quello.
 
\end_layout

\begin_layout Standard
In particolare il problema risiede nel fatto che a volte si può affrontare
 il costo di un cammino più lungo in cambio di una situazione migliore per
 quanto riguarda l'ossigeno rimasto, se questo può portare successivamente
 a un cammino globale più corto.
 Se ad ogni passo si controlla se è possibile migliorare la situazione dell'ossi
geno, è possibile passare più volte sullo stesso nodo se questo aumenta
 la quantità di ossigeno rimasto.
 Il codice che realizza questo controllo è il seguente:
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "basicstyle={\small\ttfamily},frame=lr,language={C++},numbers=left,showstringspaces=false,tabsize=4"
inline false
status open

\begin_layout Plain Layout

if (cabine[c].ossigeno_rimasto - i->lunghezza > 
\end_layout

\begin_layout Plain Layout

	cabine[i->porta_a].ossigeno_rimasto && i->porta_a != C)
\end_layout

\begin_layout Plain Layout

{ 					
\end_layout

\begin_layout Plain Layout

	cabine[i->porta_a].distanza = cabine[c].distanza + i->lunghezza;
\end_layout

\begin_layout Plain Layout

	cabine[i->porta_a].ossigeno_rimasto = 
\end_layout

\begin_layout Plain Layout

	cabine[c].ossigeno_rimasto - i->lunghezza;
\end_layout

\begin_layout Plain Layout

	coda.push(i->porta_a);
\end_layout

\begin_layout Plain Layout

}	
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Come si può vedere, se la situazione dell'ossigeno viene migliorata si aggiorna
 il valore di ossigeno rimasto e anche la nuova distanza, anche se fosse
 peggiore di quella trovata in precedenza: l'unica accortezza è quella di
 mettere in AND la condizione che la cabina di arrivo non sia quella del
 tesoro, altrimenti il rischio è quello di aggiornare in quella cabina l'ossigen
o peggiorando un risultato ottenuto in precedenza, cosa che ovviamente non
 va bene e che succederebbe ad esempio nel grafo di figura 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:Casi-barbablu"

\end_inset

 (b).
 
\end_layout

\begin_layout Standard
Questo nuovo frammento di codice va inserito tra la riga 31 e la 32 del
 primo codice proposto, in modo da rendere il programma corretto anche su
 esempi 
\begin_inset Quotes eld
\end_inset

patologici
\begin_inset Quotes erd
\end_inset

.
\end_layout

\begin_layout Section
Gardaland - territoriali 2013
\end_layout

\begin_layout Standard
\begin_inset Box Framed
position "t"
hor_pos "c"
has_inner_box 0
inner_pos "t"
use_parbox 0
use_makebox 0
width "100col%"
special "none"
height "1in"
height_special "totalheight"
thickness "0.4pt"
separation "3pt"
shadowsize "4pt"
framecolor "black"
backgroundcolor "none"
status open

\begin_layout Subsection*
Gardaland (gardaland) 
\end_layout

\begin_layout Subsubsection*
Difficoltà D = 1 
\end_layout

\begin_layout Subsubsection*
Descrizione del problema
\end_layout

\begin_layout Plain Layout
Nel 2012 le Olimpiadi Internazionali di Informatica (IOI) si sono svolte,
 per la prima volta, in Italia, a Sirmione.
 Come da tradizione, nella giornata tra le due gare i concorrenti sono andati
 a divertirsi in un parco giochi, in questo caso, Gardaland.
 La mattina di quel giorno decine di pullman hanno prelevato i quattro ragazzi
 che costituiscono la squadra olimpica di ciascuna nazione dal Garda Village,
 dove erano stati alloggiati, e li hanno portati a Gardaland.
 Come sempre negli spostamenti, le varie nazioni erano state ripartite a
 blocco unico tra i pullman, ossia tutti gli atleti di una stessa nazione
 trovavano posto su uno stesso pullman.
 Per esempio, sul pullman dell’Italia viaggiavano anche Giappone, Israele
 e Irlanda.
 Al ritorno però, come sempre succede alle IOI, dopo una giornata in un
 parco giochi i ragazzi hanno fatto amicizia tra di loro, e al momento di
 tornare sui pullman sono saliti alla rinfusa.
 Grazie al lavoro delle guide, per ogni pullman è stata stilata una lista
 contenente, per ogni nazione, il numero di ragazzi a bordo.
 Il vostro compito è quello di aiutare Monica, responsabile dell’organizzazione,
 a capire se i pullman possono partire, ovvero se tutti i quattro ragazzi
 di ogni nazione che sono arrivati a Gardaland sono saliti sui pullman.
 In caso contrario, dovete segnalare a Monica in quanti mancano all’appello,
 divisi per nazioni.
\end_layout

\begin_layout Subsubsection*
Dati di input
\end_layout

\begin_layout Plain Layout
Il file input.txt è composto da 1+N+L righe.
 La prima riga contiene due interi positivi separati da uno spazio: il numero
 N delle nazioni e il numero L di righe contenenti informazioni su chi è
 attualmente già salito sui pullman.
 (Ciascuna nazione verrà qui rappresentata con un intero compreso tra 0
 e N-1).
 Ognuna delle successive N righe contiene un intero positivo: nella riga
 i+1 (con i >= 1) troviamo il numero totale di ragazzi della nazione i-1.
 Ciascuna delle rimanenti L righe contiene due interi positivi: un intero
 compreso tra 0 e N-1 che rappresenta la nazione, e un intero positivo che
 specifica quanti ragazzi di quella nazione sono su un certo pullman.
 Ovviamente una stessa nazione può comparire diverse volte nelle L righe,
 e più precisamente compare su tante righe quanti sono i pullman ospitanti
 atleti di quella nazione.
\end_layout

\begin_layout Subsubsection*
Dati di output
\end_layout

\begin_layout Plain Layout
Il file output.txt è composto da una sola riga contenente l’intero 0 (zero)
 se non manca alcun ragazzo.
 Altrimenti, il file contiene 1+C righe: la prima riga contiene un intero
 C, ovvero il numero di nazioni che hanno ragazzi ancora a Gardaland.
 Le restanti C righe contengono due interi: l’identificativo della nazione
 e il numero di ragazzi di quella nazione che non sono ancora saliti su
 alcun pullman.
 É necessario stampare le nazioni nell’ordine in cui sono state lette, ovvero
 in ordine crescente in base all’identificativo.
\end_layout

\begin_layout Subsubsection*
Assunzioni
\end_layout

\begin_layout Itemize
\begin_inset Formula $2\leq N\leq100$
\end_inset


\end_layout

\begin_layout Itemize
\begin_inset Formula $N\leq L\leq1000$
\end_inset


\end_layout

\begin_layout Itemize
Contrariamente alle olimpiadi di informatica reali, dove gareggiano (massimo)
 4 ragazzi per ogni nazione, nei casi di input si assume che ogni nazione
 abbia al massimo 100 ragazzi, e almeno 1 ragazzo.
 Quindi, indicando con R
\begin_inset script subscript

\begin_layout Plain Layout
i
\end_layout

\end_inset

 il numero di ragazzi della i-esima nazione, vale sempre 1 ≤ R
\begin_inset script subscript

\begin_layout Plain Layout
i
\end_layout

\end_inset

 ≤ 100.
\end_layout

\begin_layout Subsubsection*
Esempi di input/output 
\end_layout

\begin_layout Plain Layout
\begin_inset Tabular
<lyxtabular version="3" rows="2" columns="2">
<features tabularvalignment="middle">
<column alignment="left" valignment="top" width="1in">
<column alignment="left" valignment="top" width="1.3in">
<row>
<cell alignment="left" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
File input.txt
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
File output.txt
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
3 5 
\end_layout

\begin_layout Plain Layout
4
\end_layout

\begin_layout Plain Layout
4
\end_layout

\begin_layout Plain Layout
3
\end_layout

\begin_layout Plain Layout
0 2 
\end_layout

\begin_layout Plain Layout
1 3 
\end_layout

\begin_layout Plain Layout
0 1 
\end_layout

\begin_layout Plain Layout
2 2 
\end_layout

\begin_layout Plain Layout
1 1
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
2
\end_layout

\begin_layout Plain Layout
0 1
\end_layout

\begin_layout Plain Layout
2 1
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Suggerimenti
\end_layout

\begin_layout Standard
A una prima occhiata il problema non sembra essere difficile, i limiti temporali
 data la dimensione del problema sembrano essere piuttosto larghi, si tratta
 eventualmente di trovare la soluzione più rapida e efficiente da scrivere,
 per risparmiare tempo per gli altri problemi.
\end_layout

\begin_layout Itemize
Quali sono le informazioni rilevanti? I pullman, i ragazzi, le nazioni?
\end_layout

\begin_layout Itemize
Il fatto che ogni nazione sia indicata da un numero intero e che i numeri
 siano tutti quelli compresi tra 0 e N-1, può aiutarmi a scegliere la struttura
 di supporto più adatta?
\end_layout

\begin_layout Itemize
Dal momento che devo memorizzare le nazioni e i ragazzi che mancano per
 ogni nazione, di quante variabili/strutture dati ho bisogno?
\end_layout

\begin_layout Itemize
Durante la lettura dei dati è possibile risolvere il problema? Prova a immaginar
e Monica che, armata di carta e penna, gira per ogni pullman e raccoglie
 le informazioni sui ragazzi di ogni nazione: quando arriva all'ultimo pullman
 può già essere in grado di avere la soluzione?
\end_layout

\begin_layout Subsection
Soluzione
\end_layout

\begin_layout Standard
Il problema può essere risolto con un costo lineare e, come evidenziato
 nell'ultima domanda dei suggerimenti, già al momento della lettura dei
 dati è possibile trovare la soluzione.
 La scelta fondamentale che permette di raggiungere questo risultato è quella
 di usare un vettore per memorizzare i ragazzi di ogni nazione, sfruttando
 l'indice del vettore come 
\begin_inset Quotes eld
\end_inset

segnaposto
\begin_inset Quotes erd
\end_inset

 della nazione e il valore di ogni cella come il numero di ragazzi corrispondent
i alla nazione individuata dall'indice.
 
\end_layout

\begin_layout Standard
A questo punto è immediato aggiornare la situazione mano a mano che vengono
 lette le coppie nazione - numero ragazzi, in modo da avere infine una lista
 delle nazioni a cui mancano ancora ragazzi.
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "basicstyle={\small\ttfamily},frame=lr,language={C++},numbers=left,showstringspaces=false,tabsize=4"
inline false
status open

\begin_layout Plain Layout

int nazioni[100]; 
\end_layout

\begin_layout Plain Layout

int N,L;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

int main() { 	
\end_layout

\begin_layout Plain Layout

	ifstream in("input.txt"); 	
\end_layout

\begin_layout Plain Layout

	ofstream out("output.txt"); 	
\end_layout

\begin_layout Plain Layout

	in >> N >> L; 	
\end_layout

\begin_layout Plain Layout

	for (int i = 0; i < N; i++) 		
\end_layout

\begin_layout Plain Layout

		in >> nazioni[i]; 	
\end_layout

\begin_layout Plain Layout

	for (int i = 0; i < L; i++) { 		
\end_layout

\begin_layout Plain Layout

		int n,r; 		
\end_layout

\begin_layout Plain Layout

		in >> n >> r; 		
\end_layout

\begin_layout Plain Layout

		nazioni[n] -= r; 
\end_layout

\begin_layout Plain Layout

	} 	
\end_layout

\begin_layout Plain Layout

	int assenti = 0; 	
\end_layout

\begin_layout Plain Layout

	for (int i = 0; i < N; i++)
\end_layout

\begin_layout Plain Layout

		if (nazioni[i] != 0)
\end_layout

\begin_layout Plain Layout

			assenti++;	 	
\end_layout

\begin_layout Plain Layout

	out << assenti << endl; 		
\end_layout

\begin_layout Plain Layout

	if (assenti) 		
\end_layout

\begin_layout Plain Layout

		for (int i = 0; i < N; i++) 			
\end_layout

\begin_layout Plain Layout

			if (nazioni[i] != 0) 				
\end_layout

\begin_layout Plain Layout

				out << i << " " << nazioni[i] << endl; 		 	
\end_layout

\begin_layout Plain Layout

	return 0; 
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Come si vede dal codice il vettore 
\emph on
nazioni
\emph default
 conterrà tutti i ragazzi presenti alle Olimpiadi per ogni nazione, vettore
 che viene inizializzato alle righe 8-9.
 Scorrendo poi le 
\series bold
L
\series default
 righe che contengono i ragazzi presenti nei vari pullman, ad ogni lettura
 viene aggiornata la situazione relativa alla nazione letta, decrementando
 il valore contenuto nella cella di indice 
\series bold
n
\series default
 del numero 
\series bold
r
\series default
 di ragazzi appartenenti a quella nazione (righe 10-14).
 A questo punto è semplice scorrere il vettore aggiornato, che conterrà
 in ogni cella il numero di ragazzi rimasti a Gardaland, 0 nel caso che
 tutti quelli della nazione siano sui pullman.
 Dopo aver contato il numero di nazioni che non hanno tutti i ragazzi (righe
 16-18), si procede con la stampa del risultato (riga 19) ed eventualmente,
 se ci sono ragazzi assenti, con le assenze per ogni nazione (righe 21-23).
\end_layout

\begin_layout Standard
\begin_inset Newpage newpage
\end_inset


\end_layout

\begin_layout Section
Brisbane - territoriali 2013
\end_layout

\begin_layout Standard
\begin_inset Box Framed
position "t"
hor_pos "c"
has_inner_box 0
inner_pos "t"
use_parbox 0
use_makebox 0
width "100col%"
special "none"
height "1in"
height_special "totalheight"
thickness "0.4pt"
separation "3pt"
shadowsize "4pt"
framecolor "black"
backgroundcolor "none"
status collapsed

\begin_layout Subsection*
Brisbane (brisbane) 
\end_layout

\begin_layout Subsubsection*
Difficoltà D = 2.
 
\end_layout

\begin_layout Subsubsection*
Descrizione del problema
\end_layout

\begin_layout Plain Layout
Nel 2013, le IOI si svolgeranno a Brisbane (in Australia).
 La rappresentativa italiana ha già iniziato a studiare la città, per capire
 cosa ci sia di interessante da vedere, e come ci si possa spostare nella
 giornata libera successiva alla seconda gara delle Olimpiadi.
 L’offerta di trasporto pubblico a Brisbane è abbastanza variegata: ci sono
 due linee di bus, di cui una gratuita che gira intorno alla città, e due
 linee di traghetti che fermano in diversi punti del fiume Brisbane, che
 taglia la città in due; per quello che riguarda i prezzi, esiste un abbonamento
 giornaliero a tutti i trasporti pubblici, bus e traghetti insieme, oppure
 è possibile prendere un più economico abbonamento giornaliero ai soli traghetti
, o un ancor più economico abbonamento ai soli bus.
 
\end_layout

\begin_layout Plain Layout
La squadra italiana vorrà visitare il maggior numero di attrazioni possibile
 e per questo motivo Monica, la responsabile dell’organizzazione, ha deciso
 di cercare un buon compromesso tra il prezzo dei biglietti e le attrazioni
 che sarà possibile raggiungere partendo dall’hotel.
 Data una lista di attrazioni e la mappa dei collegamenti delle diverse
 linee del trasporto pubblico, il vostro compito è quello di aiutare Monica
 a capire 
\emph on
quante attrazioni sono raggiungibili
\emph default
 per ogni possibile scelta dei biglietti per i trasporti pubblici.
 
\end_layout

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename ../materiali/problemi territoriali/2013_brisbane/piantina.png
	lyxscale 30
	scale 25

\end_inset


\end_layout

\begin_layout Plain Layout
Per esempio, possiamo fare riferimento alla figura qui sopra, dove ad ogni
 fermata è associato un cerchio (o un quadrato nel caso di luogo di attrazione)
 e i collegamenti sono: 
\end_layout

\begin_layout Itemize
tratteggiati – collegamenti gratuiti (bus gratuiti e brevi percorsi a piedi);
 
\end_layout

\begin_layout Itemize
rossi – bus a pagamento; 
\end_layout

\begin_layout Itemize
gialli – traghetto.
 
\end_layout

\begin_layout Plain Layout
Il punto di partenza della rappresentativa italiana è la fermata numero
 0; le attrazioni da vedere sono quelle rappresentate con un quadrato, numerate
 rispettivamente 8, 12, 15, 22 e 28.
 Come si può vedere, spostandosi con i mezzi gratuiti si raggiungono solo
 due attrazioni (la numero 8 e la numero 22); comprando il biglietto del
 bus si raggiungono tutte le attrazioni; comprando il biglietto del traghetto
 si raggiungono, oltre alla 8 e la 22, anche la 12 e la 15 per un totale
 di quattro attrazioni.
 Il biglietto combinato, in questo caso, raggiunge tutte le attrazioni.
 
\end_layout

\begin_layout Subsubsection*
Dati di input
\end_layout

\begin_layout Plain Layout
Il file input.txt è composto da 1+A+Mg+Mb+Mt righe.
 La prima riga contiene cinque interi positivi separati da uno spazio, che
 rappresentano il numero 
\emph on
N
\emph default
 delle fermate, il numero 
\emph on
A
\emph default
 di attrazioni, il numero 
\emph on
Mg
\emph default
 dei collegamenti gratuiti, il numero 
\emph on
Mb
\emph default
 dei collegamenti via bus e il numero 
\emph on
Mt
\emph default
 dei collegamenti via traghetto.
 Ogni fermata è rappresentata da un intero compreso tra 0 e N-1.
 Le successive 
\emph on
A
\emph default
 righe contengono ognuna una fermata (un intero compreso tra 0 e N-1) corrispond
ente ad una delle attrazioni che la rappresentativa italiana può visitare.
 Ognuna delle successive 
\emph on
Mg+Mb+Mt
\emph default
 righe contiene un collegamento del trasporto pubblico, rappresentato da
 due interi positivi: le fermate collegate.
 Le prime 
\emph on
Mg
\emph default
 righe contengono i collegamenti gratuiti (bus gratuiti e brevi percorsi
 a piedi), poi le successive 
\emph on
Mb
\emph default
 contengono i collegamenti del bus a pagamento e infine le ultime 
\emph on
Mt
\emph default
 righe contengono i collegamenti dei traghetti.
 Il punto di partenza della rappresentativa italiana è la sempre la fermata
 numero 0.
 
\end_layout

\begin_layout Subsubsection*
Dati di output
\end_layout

\begin_layout Plain Layout
Il file output.txt è composto da 4 righe contenenti ognuna un intero non
 negativo, rispettivamente, il numero di attrazioni raggiungibili:
\end_layout

\begin_layout Enumerate
senza comprare biglietti (solo con mezzi gratuiti); 
\end_layout

\begin_layout Enumerate
comprando solo il biglietto giornaliero dei bus; 
\end_layout

\begin_layout Enumerate
comprando solo il biglietto giornaliero dei traghetti; 
\end_layout

\begin_layout Enumerate
comprando entrambe le tipologie di biglietti.
 
\end_layout

\begin_layout Subsubsection*
Assunzioni
\end_layout

\begin_layout Itemize
\begin_inset Formula $2\leq N\leq1000$
\end_inset


\end_layout

\begin_layout Itemize
\begin_inset Formula $N\leq Mg+Mb+Mt\leq10000$
\end_inset


\end_layout

\begin_layout Subsubsection*
Esempi di input/output 
\end_layout

\begin_layout Plain Layout
\begin_inset Tabular
<lyxtabular version="3" rows="2" columns="2">
<features tabularvalignment="middle">
<column alignment="left" valignment="top" width="1in">
<column alignment="left" valignment="top" width="1.3in">
<row>
<cell alignment="left" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
File input.txt
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
File output.txt
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
6 2 2 4 2
\end_layout

\begin_layout Plain Layout

\family typewriter
1
\end_layout

\begin_layout Plain Layout
5
\end_layout

\begin_layout Plain Layout
0 1
\end_layout

\begin_layout Plain Layout
2 5
\end_layout

\begin_layout Plain Layout
0 3
\end_layout

\begin_layout Plain Layout
1 3
\end_layout

\begin_layout Plain Layout
2 4
\end_layout

\begin_layout Plain Layout
4 5
\end_layout

\begin_layout Plain Layout
1 2
\end_layout

\begin_layout Plain Layout
3 4
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
1
\end_layout

\begin_layout Plain Layout
1
\end_layout

\begin_layout Plain Layout
2
\end_layout

\begin_layout Plain Layout
2
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Suggerimenti
\end_layout

\begin_layout Itemize
Come in molti altri problemi la figura suggerisce immediatamente che genere
 di problema si vuole affrontare: qual è?
\end_layout

\begin_layout Itemize
Se il problema fosse semplicemente quello di scoprire se dati una serie
 di nodi e archi quali sono raggiungibili da un certo nodo e quali no, cosa
 bisognerebbe fare?
\end_layout

\begin_layout Itemize
Da momento che in questo caso il problema non sembra esattamente dello stesso
 tipo, è possibile scomporlo in più istanze dello stesso problema, risolvibili
 separatamente?
\end_layout

\begin_layout Subsection
Soluzione
\end_layout

\begin_layout Standard
Dalla figura sembra evidente, e in effetti lo è, che il problema abbia a
 che fare con i grafi.
 Si trascuri per un attimo il fatto che ci siano varie tipologie di trasporto
 e si prendano in considerazione, ad esempio, solo gli archi che fanno parte
 del trasporto gratuito.
 Il problema si riduce a verificare se, dato un nodo di partenza, alcuni
 nodi particolari sono raggiungibili o meno.
 Per risolvere questo tipo di problema è sufficiente fare una visita, in
 profondità o in ampiezza (vedi pagina 
\begin_inset CommandInset ref
LatexCommand pageref
reference "sec:visite"

\end_inset

), e contare quanti dei nodi visitati sono delle attrazioni.
 Se alcune attrazioni non sono raggiungibili tramite la visita quelle non
 verranno contate.
\end_layout

\begin_layout Standard
Per risolvere i vari problemi è sufficiente trattare ogni tipo di trasporto
 (gratuito, bus, traghetti, tutti) come un grafo diverso e applicare a ognuno
 la stessa idea: per costruire i quattro diversi grafi è sufficiente, quando
 si leggono i dati dei collegamenti, inserirli nel grafo o nei grafi opportuni:
 ad esempio un collegamento del trasporto gratuito andrà in tutti i grafi,
 mentre quello dei bus solo nel grafo dei bus e in quello che li contiene
 tutti.
 Anche se questa idea prevede la ripetizione degli stessi dati più volte,
 cosa non necessaria se venissero adottati altri approci, ha dalla sua una
 semplicità implementativa notevole, perchè non richiede altro che di riapplicar
e quattro volte una visita di un grafo.
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "basicstyle={\small\ttfamily},frame=lr,language={C++},numbers=left,showstringspaces=false,tabsize=4"
inline false
status collapsed

\begin_layout Plain Layout

struct fermata{ 	
\end_layout

\begin_layout Plain Layout

	bool attrazione; 	
\end_layout

\begin_layout Plain Layout

	list <int> collegamenti; 	
\end_layout

\begin_layout Plain Layout

	fermata():attrazione(false){} 
\end_layout

\begin_layout Plain Layout

};
\end_layout

\begin_layout Plain Layout

int N, A, Mg, Mb, Mt;
\end_layout

\begin_layout Plain Layout

fermata gratuiti[1000], bus[1000], traghetti[1000], tutti[1000];
\end_layout

\begin_layout Plain Layout

void inserisci_collegamento(fermata *grafo,int a, int b) {
\end_layout

\begin_layout Plain Layout

	grafo[a].collegamenti.push_back(b);
\end_layout

\begin_layout Plain Layout

	grafo[b].collegamenti.push_back(a); 
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

int visita(fermata *grafo, int n) { 	
\end_layout

\begin_layout Plain Layout

	int contatore = 0; 	
\end_layout

\begin_layout Plain Layout

	bool visitato[1000]; 	
\end_layout

\begin_layout Plain Layout

	stack <int> pila; 	
\end_layout

\begin_layout Plain Layout

	fill(visitato, visitato + 1000,false); 	
\end_layout

\begin_layout Plain Layout

	pila.push(n); 	
\end_layout

\begin_layout Plain Layout

	while(!pila.empty()) { 		
\end_layout

\begin_layout Plain Layout

		int corrente = pila.top(); 		
\end_layout

\begin_layout Plain Layout

		pila.pop(); 		
\end_layout

\begin_layout Plain Layout

		if (visitato[corrente] == false) {
\end_layout

\begin_layout Plain Layout

			visitato[corrente] = true; 			
\end_layout

\begin_layout Plain Layout

			if (grafo[corrente].attrazione == true) contatore++;
\end_layout

\begin_layout Plain Layout

			list <int>::iterator i; 			
\end_layout

\begin_layout Plain Layout

			for (i = grafo[corrente].collegamenti.begin();
\end_layout

\begin_layout Plain Layout

				i!=grafo[corrente].collegamenti.end(); i++)
\end_layout

\begin_layout Plain Layout

				pila.push(*i); 		
\end_layout

\begin_layout Plain Layout

		} 	
\end_layout

\begin_layout Plain Layout

	} 	
\end_layout

\begin_layout Plain Layout

	return contatore; 
\end_layout

\begin_layout Plain Layout

} 
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

int main() { 	
\end_layout

\begin_layout Plain Layout

	ifstream in("input.txt"); 	
\end_layout

\begin_layout Plain Layout

	ofstream out("output.txt"); 	
\end_layout

\begin_layout Plain Layout

	int temp,a,b; 	
\end_layout

\begin_layout Plain Layout

	in >> N >> A >> Mg >> Mb >> Mt; 	
\end_layout

\begin_layout Plain Layout

	for (int i = 0; i < A; i++) { 		
\end_layout

\begin_layout Plain Layout

		in >> temp; 		
\end_layout

\begin_layout Plain Layout

		gratuiti[temp].attrazione = bus[temp].attrazione =
\end_layout

\begin_layout Plain Layout

		traghetti[temp].attrazione = tutti[temp].attrazione = true; 	
\end_layout

\begin_layout Plain Layout

	} 	
\end_layout

\begin_layout Plain Layout

	for (int i = 0; i < Mg; i++) 	{ 		
\end_layout

\begin_layout Plain Layout

		in >> a >> b;
\end_layout

\begin_layout Plain Layout

		inserisci_collegamento(gratuiti,a,b);
\end_layout

\begin_layout Plain Layout

		inserisci_collegamento(bus,a,b);
\end_layout

\begin_layout Plain Layout

		inserisci_collegamento(traghetti,a,b);
\end_layout

\begin_layout Plain Layout

		inserisci_collegamento(tutti,a,b); 	
\end_layout

\begin_layout Plain Layout

	} 	
\end_layout

\begin_layout Plain Layout

	for (int i = 0; i < Mb; i++) 	{ 		
\end_layout

\begin_layout Plain Layout

		in >> a >> b; 		
\end_layout

\begin_layout Plain Layout

		inserisci_collegamento(bus,a,b);
\end_layout

\begin_layout Plain Layout

		inserisci_collegamento(tutti,a,b); 	
\end_layout

\begin_layout Plain Layout

	} 	
\end_layout

\begin_layout Plain Layout

	for (int i = 0; i < Mt; i++) 	{ 		
\end_layout

\begin_layout Plain Layout

		in >> a >> b;
\end_layout

\begin_layout Plain Layout

		inserisci_collegamento(traghetti,a,b);
\end_layout

\begin_layout Plain Layout

		inserisci_collegamento(tutti,a,b); 	
\end_layout

\begin_layout Plain Layout

	} 	
\end_layout

\begin_layout Plain Layout

	out << visita(gratuiti,0) << endl; 	
\end_layout

\begin_layout Plain Layout

	out << visita(bus,0) << endl; 	
\end_layout

\begin_layout Plain Layout

	out << visita(traghetti,0) << endl; 	
\end_layout

\begin_layout Plain Layout

	out << visita(tutti,0) << endl;     
\end_layout

\begin_layout Plain Layout

	return 0; 
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Come prima cosa viene creata una struttura che rappresenta ogni fermata,
 che contiene le informazioni dei collegamenti che partono da quella fermata
 all'interno di una lista e un booleano che indica se la fermata è un'attrazione
 o meno, informazione che servirà a contare le attrazioni visitabili (righe
 1-5).
\end_layout

\begin_layout Standard
I quattro grafi saranno quindi dei vettori di fermate, dimensionati secondo
 i limiti del problema.
\end_layout

\begin_layout Standard
La parte risolutiva vera e propria del problema è la funzione 
\emph on
visita
\emph default
, che ha come parametri il grafo su cui deve essere applicata e il nodo
 di partenza (che in questo particolare problema è sempre il nodo 0).
 In questo caso è stata implementata una visita in profondità, ma si poteva
 fare anche una visita in ampiezza e non sarebbe cambiato niente.
 Il codice è uguale a quello mostrato a pagina 
\begin_inset CommandInset ref
LatexCommand pageref
reference "sec:visite"

\end_inset

, con alla riga 23 il controllo sulla condizione che il nodo visitato sia
 un'attrazione o no, per incrementare il contatore che poi verrà restituito
 dalla funzione.
 Due parole sulla funzione 
\emph on
fill
\emph default
 usata alla riga 16: come l'algoritmo 
\emph on
sort
\emph default
 fa parte dell'header 
\emph on
algorithm
\emph default
 e può essere comoda quando si deve inizializzare un vettore, in questo
 caso con tutte le cella a false: è chiaro che si sarebbe potuto usare un
 semplice 
\emph on
for
\emph default
, ma abituarsi a usare le librerie che mette a disposizione il C++ può essere
 utile in casi più complessi.
\end_layout

\begin_layout Standard
A questo punto l'altra parte del processo risolutivo prevede una corretta
 lettura dei dati di input, in particolare dei collegamenti: dopo aver segnato
 le stazioni che sono anche delle attrazioni (righe 38-42), si ripete per
 tre volte la stessa serie di istruzioni, per leggere i tre tipi di collegamenti
: i collegamenti gratuiti verranno inseriti in ogni grafo (righe 43-49),
 quelli dei bus solo nel grafo dei bus e in quello che li contiene tutti
 (righe 50-54) e quelli dei traghetti solo nel grafo dei traghetti e in
 quello che li contiene tutti (righe 55-59).
\end_layout

\begin_layout Standard
Dopo aver creato i grafi si chiamerà semplicemente la 
\emph on
funzione
\emph default
 visita sui quattro grafi (righe 60-63), ottenendo l'output desiderato.
\end_layout

\begin_layout Section
\begin_inset CommandInset label
LatexCommand label
name "sec:Trova-la-parola"

\end_inset

Trova la parola - territoriali 2013
\end_layout

\begin_layout Standard
\begin_inset Box Framed
position "t"
hor_pos "c"
has_inner_box 0
inner_pos "t"
use_parbox 0
use_makebox 0
width "100col%"
special "none"
height "1in"
height_special "totalheight"
thickness "0.4pt"
separation "3pt"
shadowsize "4pt"
framecolor "black"
backgroundcolor "none"
status open

\begin_layout Subsection*
Trova la parola (trovaparola) 
\end_layout

\begin_layout Subsubsection*
Difficoltà D = 2.
 
\end_layout

\begin_layout Subsubsection*
Descrizione del problema
\end_layout

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename ../materiali/problemi territoriali/2013_trovaparola/ruzzle.png
	scale 60

\end_inset


\end_layout

\begin_layout Plain Layout
Visto il successo del gioco Ruzzle©, che riprende il noto paroliere, i giochi
 basati su trovare parole stanno vivendo un periodo molto popolare.
 Luciano, patito di giochi di tutti i tipi, ha ideato un nuovo gioco, che
 funziona nel modo seguente: avete una griglia di caratteri e una parola
 da trovare nella griglia, partendo dalla cella in alto a sinistra.
 Le uniche mosse consentite sono gli spostamenti a destra o in basso.
 Ad esempio, considerate la seguente griglia e la parola “olimpiadi”: 
\end_layout

\begin_layout Plain Layout
\begin_inset Tabular
<lyxtabular version="3" rows="8" columns="7">
<features tabularvalignment="middle">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top" width="0pt">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top" width="0pt">
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
O
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
L
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
I
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
V
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
E
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
N
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
T
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
G
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Q
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
M
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
P
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
W
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
E
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
R
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
G
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
T
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
R
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
I
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
A
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Y
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
E
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
I
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
U
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
I
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
C
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
D
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
P
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
E
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
A
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
F
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
C
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
O
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
I
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
G
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
H
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
J
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
K
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
X
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
C
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
V
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
R
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
S
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
R
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
O
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
M
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
I
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
T
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
A
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
A
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
S
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
T
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
A
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
N
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
L
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
E
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
E
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Plain Layout
In questo caso, la sequenza di spostamenti è “DDBDBDBB”, rappresentando
 gli spostamenti a destra con il carattere D e quelli in basso con il carattere
 B.
 Non esiste nessuna soluzione, invece, se la parola da cercare è “olimpionico”.
 Il vostro compito consiste nello scrivere un programma che, ricevute in
 ingresso una parola (da cercare) e una griglia, restituisca la sequenza
 di spostamenti, qualora esista una soluzione, oppure stampi “ASSENTE”.
 Se dovessero esistere molteplici sequenze di spostamenti corrette, è sufficient
e stamparne una qualunque.
 
\end_layout

\begin_layout Subsubsection*
Dati di input
\end_layout

\begin_layout Plain Layout
Il file input.txt è composto da 2+R righe.
 La prima riga contiene due interi positivi R e C: le dimensioni della griglia,
 ovvero il numero di righe R e il numero di colonne C.
 La riga successiva contiene P, una parola da cercare, rappresentata da
 una stringa lunga almeno 2 caratteri (alfabetici maiuscoli) e al massimo
 R+C-1 caratteri.
 Le rimanenti R righe del file contengono le righe della griglia, rappresentate
 da stringhe di C caratteri alfabetici maiuscoli.
 
\end_layout

\begin_layout Subsubsection*
Dati di output
\end_layout

\begin_layout Plain Layout
Il file output.txt è composto da una sola riga contenente una stringa di
 testo: la sequenza di spostamenti necessari per trovare la parola nella
 griglia, se la parola è presente, oppure la stringa “ASSENTE” (senza le
 virgolette).
 
\end_layout

\begin_layout Subsubsection*
Assunzioni
\end_layout

\begin_layout Itemize
2 ≤ R,C ≤ 100; 
\end_layout

\begin_layout Subsubsection*
Esempi di input/output 
\end_layout

\begin_layout Plain Layout
\begin_inset Tabular
<lyxtabular version="3" rows="2" columns="2">
<features tabularvalignment="middle">
<column alignment="left" valignment="top" width="1in">
<column alignment="left" valignment="top">
<row>
<cell alignment="left" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
File input.txt
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
File output.txt
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
8 7
\end_layout

\begin_layout Plain Layout

\family typewriter
OLIMPIADI
\end_layout

\begin_layout Plain Layout

\family typewriter
OLIVENT
\end_layout

\begin_layout Plain Layout

\family typewriter
GQMPWER
\end_layout

\begin_layout Plain Layout

\family typewriter
GTRIAYE
\end_layout

\begin_layout Plain Layout

\family typewriter
IUICDPE
\end_layout

\begin_layout Plain Layout

\family typewriter
AFCOIGH
\end_layout

\begin_layout Plain Layout

\family typewriter
JKXCVRS
\end_layout

\begin_layout Plain Layout

\family typewriter
ROMITAA
\end_layout

\begin_layout Plain Layout

\family typewriter
STANLEE
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
DDBDBDBB
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Plain Layout
\noindent
\begin_inset VSpace defskip
\end_inset


\begin_inset Tabular
<lyxtabular version="3" rows="2" columns="2">
<features tabularvalignment="middle">
<column alignment="left" valignment="top" width="1in">
<column alignment="left" valignment="top">
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
File input.txt
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
File output.txt
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
8 7
\end_layout

\begin_layout Plain Layout

\family typewriter
OLIMPIONICO
\end_layout

\begin_layout Plain Layout

\family typewriter
OLIVENT
\end_layout

\begin_layout Plain Layout

\family typewriter
GQMPWER
\end_layout

\begin_layout Plain Layout

\family typewriter
GTRIAYE
\end_layout

\begin_layout Plain Layout

\family typewriter
IUICDPE
\end_layout

\begin_layout Plain Layout

\family typewriter
AFCOIGH
\end_layout

\begin_layout Plain Layout

\family typewriter
JKXCVRS
\end_layout

\begin_layout Plain Layout

\family typewriter
ROMITAA
\end_layout

\begin_layout Plain Layout

\family typewriter
STANLEE
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
ASSENTE
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Plain Layout

\series bold
\size footnotesize
Nota
\series default
: John Romita e Stan Lee, che compaiono nell'ultima e penultima riga dell'esempi
o, sono rispettivamente il secondo disegnatore del fumetto Spider Man e
 il creatore dello stesso.
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Suggerimenti
\end_layout

\begin_layout Itemize
Dalla figura sembra ovvio quale sia la struttura dati più adatta per memorizzare
 i dati, una matrice, può essere meno ovvio quali funzioni del linguaggio
 usare per la lettura dell'input (scanf, gets, una riga alla volta, un carattere
 alla volta,...).
 Quale ti sembra la migliore (magari prova in modi diversi)?
\end_layout

\begin_layout Itemize
Le dimensioni massime dell'input fino a quale complessità computazionale
 permettono di arrivare senza problemi (lineare, quadratica, cubica, ...)?
\end_layout

\begin_layout Itemize
Come in altri problemi sembra utile potersi 
\begin_inset Quotes eld
\end_inset

muovere
\begin_inset Quotes erd
\end_inset

 nella matrice, seguendo due possibili direzioni: siccome quando mi sposto
 in una matrice devo sempre stare attento a non uscire dei bordi, dove posso
 mettere delle sentinelle per evitare controlli espliciti?
\end_layout

\begin_layout Itemize
Riesco a implementare i movimenti tramite un approccio iterativo o viene
 più naturale un approccio ricorsivo?
\end_layout

\begin_layout Itemize
Se l'approccio ricorsivo creasse dei problemi nell'implementazione, potrei
 sostituirlo con uno iterativo molto semplice che, seppur non mi garantisca
 la correttezza in tutti i casi, può ragionevolmente portare molti punti
 in saccoccia?
\end_layout

\begin_layout Subsection
Soluzione
\end_layout

\begin_layout Standard
Come già detto nei suggerimenti sembra piuttosto chiaro che una matrice
 sia la struttura dati adatta per affrontare questo problema: bisogna però
 porre qualche attenzione su come popolare la matrice, dato il file di input
 nel formato proposto.
 Quando infatti all'interno dello stesso file compaiono sia numeri che stringhe
 le normali funzioni per l'input potrebbero generare qualche problema: per
 questo particolare problema potremmo procedere in tre modi distinti
\end_layout

\begin_layout Itemize
usare l'operatore 
\emph on
<<
\emph default
 (o 
\emph on
fscanf
\emph default
) sia per i numeri che per le stringhe
\end_layout

\begin_layout Itemize
usare l'operatore 
\emph on
<<
\emph default
 (o 
\emph on
fscanf
\emph default
) per leggere i numeri e la 
\emph on
getline
\emph default
 (o la 
\emph on
fgets
\emph default
) per le stringhe, leggendo quindi una riga di testo alla volta
\end_layout

\begin_layout Itemize
usare l'operatore 
\emph on
<<
\emph default
 (o la 
\emph on
fscanf
\emph default
) per leggere il contenuto della matrice carattere per carattere
\end_layout

\begin_layout Standard
Il primo approccio è in questo caso quello corretto, in quanto la lettura
 dei numeri non interferisce con la successiva lettura delle stringhe ed
 è molto comodo poichè, siccome ogni riga non contiene spazi, può essere
 letta tutta in un colpo e messa nella matrice così com'è.
\end_layout

\begin_layout Standard
Il secondo pone dei problemi, in quanto la 
\emph on
getline
\emph default
 (o la 
\emph on
fgets
\emph default
) non funzionano nello stesso modo dell'operatore 
\emph on
<<
\emph default
 (o della 
\emph on
fscanf
\emph default
), in particolare gestiscono diversamente il terminatore, quindi alternarle
 all'interno dello stesso programma non è mai una buona idea.
\end_layout

\begin_layout Standard
L'ultimo approccio potrebbe sembrare corretto dal momento che nei dati forniti
 in output compare anche la lunghezza delle stringhe, sotto forma del valore
 di C, e sembra quindi un invito a leggere carattere per carattere con due
 cicli annidati limitati da C e R.
 In realtà così è molto più scomodo che con il primo approccio, poichè bisognere
bbe anche gestire il terminatore di linea che altrimenti verrebbe letto
 come un qualsiasi altro carattere.
\end_layout

\begin_layout Standard
Di fatto il primo approccio rende anche inutile la lettura del valore di
 C, che non viene mai usato, ma in questo caso non bisogna preoccuparsene,
 quindi va letto ma poi ignorato, come mostrato alle righe 24-27 del codice
 sottostante.
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "basicstyle={\small\ttfamily},frame=lr,language={C++},numbers=left,showstringspaces=false,tabsize=4"
inline false
status collapsed

\begin_layout Plain Layout

int R,C; 
\end_layout

\begin_layout Plain Layout

char matrice[101][101]; 
\end_layout

\begin_layout Plain Layout

char parola[201]; 
\end_layout

\begin_layout Plain Layout

stack <char> percorso;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

bool naviga(int i, int j, int l) { 	
\end_layout

\begin_layout Plain Layout

	if (l == strlen(parola)-1 && matrice[i][j] == parola[l] )
\end_layout

\begin_layout Plain Layout

		return true; 	
\end_layout

\begin_layout Plain Layout

	if (matrice[i][j] != parola[l]) 		
\end_layout

\begin_layout Plain Layout

		return false; 	
\end_layout

\begin_layout Plain Layout

	if (naviga(i+1,j,l+1) == true) {
\end_layout

\begin_layout Plain Layout

		percorso.push('B'); 		
\end_layout

\begin_layout Plain Layout

		return true; 
\end_layout

\begin_layout Plain Layout

	} 	
\end_layout

\begin_layout Plain Layout

	if (naviga(i,j+1,l+1) == true) {
\end_layout

\begin_layout Plain Layout

		percorso.push('D'); 		
\end_layout

\begin_layout Plain Layout

		return true; 	
\end_layout

\begin_layout Plain Layout

	}	 
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

int main() { 	
\end_layout

\begin_layout Plain Layout

	ifstream in("input.txt"); 	
\end_layout

\begin_layout Plain Layout

	ofstream out("output.txt"); 	
\end_layout

\begin_layout Plain Layout

	in >> R >> C; 	
\end_layout

\begin_layout Plain Layout

	in >> parola; 	
\end_layout

\begin_layout Plain Layout

	for (int i = 0; i < R; i++) 		
\end_layout

\begin_layout Plain Layout

		in >> matrice[i]; 	
\end_layout

\begin_layout Plain Layout

	if (naviga(0,0,0) == true) {
\end_layout

\begin_layout Plain Layout

		while(!percorso.empty()) {
\end_layout

\begin_layout Plain Layout

			out << percorso.top(); 			
\end_layout

\begin_layout Plain Layout

			percorso.pop(); 	
\end_layout

\begin_layout Plain Layout

		} 		
\end_layout

\begin_layout Plain Layout

		out << endl; 	
\end_layout

\begin_layout Plain Layout

	} 	
\end_layout

\begin_layout Plain Layout

	else 		
\end_layout

\begin_layout Plain Layout

		out << "ASSENTE" << endl; 	
\end_layout

\begin_layout Plain Layout

	return 0; 
\end_layout

\begin_layout Plain Layout

}	
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Una volta chiarito come procedere con la lettura dei dati, si può provare
 a risolvere il problema con un approccio banale, che può anche far guadagnare
 diversi punti, ma che fallisce in alcuni casi.
 L'idea potrebbe essere la seguente:
\end_layout

\begin_layout Itemize
si pone la posizione di partenza uguale all'angolo in alto a sinistra, cioè
 con i=0 e j=0 e la lettera da controllare uguale alla prima lettera nella
 parola P, cioè P[0].
 Se la lettera in posizione di partenza e P[0] coincidono allora si procede,
 altrimenti ci si può già fermare
\end_layout

\begin_layout Itemize
si verifica che la lettera in posizione (i+1,j) sia uguale alla prossima
 lettera di P
\begin_inset Separator latexpar
\end_inset


\end_layout

\begin_deeper
\begin_layout Itemize
se lo è si sposta la posizione corrente in (i+1,j), si concatena la lettera
 B in una stringa di supporto e si ripete il procedimento
\end_layout

\begin_layout Itemize
se non lo è si verifica che la lettera in posizione (i,j+1) sia uguale alla
 prossima lettera di P
\begin_inset Separator latexpar
\end_inset


\end_layout

\begin_deeper
\begin_layout Itemize
se lo è si sposta la posizione corrente in (i,j+1), si concatena la lettera
 D in una stringa di supporto e si ripete il procedimento
\end_layout

\begin_layout Itemize
se non lo è la parola è ASSENTE
\end_layout

\end_deeper
\end_deeper
\begin_layout Itemize
se si arriva a una posizione pari alla lunghezza della parola P allora la
 parola è stata trovata e si stampa la stringa di supporto.
\end_layout

\begin_layout Standard
Questo procedimento è estremamente semplice da capire e implementare, ma
 ha il difetto di non portare sempre alla soluzione e apro un inciso: perchè
 vedere allora un procedimento non corretto? Come già detto in altre parti
 lo scopo di queste competizioni non è necessariamente quello di risolvere
 un problema correttamente, ma fare più punti possibile.
 É chiaro che la soluzione corretta porta al maggior numero di punti e quindi
 va ricercata, ma se non si riesce a fare di meglio anche una soluzione
 come questa non è da disdegnare.
 
\end_layout

\begin_layout Standard
Ma perchè non è corretta? Il problema sorge in alcuni casi, come si può
 vedere nella figura 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:Problema-trovaparola"

\end_inset

.
 Supponendo di dover cercare la parola BANCONE, nel caso indicato con (a)
 l'algoritmo produrrebbe la soluzione corretta, mentre nel caso (b) dopo
 essere giunto alla C si fermerebbe, poichè non troverebbe la O nè a destra
 nè in basso.
 Il problema nasce dal fatto che al passaggio precedente l'algoritmo era
 costretto a scegliere di scendere verso il basso, poichè è la prima cosa
 che controlla, e una volta sceso non ha modo di tornare sui propri passi.
 Per arrivare alla soluzione corretta sarebbe dovuto andare verso destra
 e avrebbe così trovato la soluzione con le lettere in italico.
 Ovviamente il problema non si può risolvere semplicemente scambiando l'ordine
 dei controlli (prima a destra e poi in basso), perchè basterebbe 
\begin_inset Quotes eld
\end_inset

ruotare
\begin_inset Quotes erd
\end_inset

 l'esempio (b) e il problema si presenterebbe comunque.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename ../materiali/problemi territoriali/2013_trovaparola/esempio problema.eps
	display false

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:Problema-trovaparola"

\end_inset

Problema con l'algoritmo banale
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Standard
A questo punto dovrebbe essere chiaro che il modo naturale di impostare
 questo problema è quello di permettere all'algoritmo di poter effettuare
 sia la visita nella casella in basso che in quella di sinistra e questo
 può essere ottenuto molto semplicemente attraverso una funzione ricorsiva.
 
\end_layout

\begin_layout Standard
Come impostare la ricorsione? L'idea, come nel precedente approccio, è quella
 di, partendo dalla casella in alto a sinistra, visitare ogni casella che
 sia compatibile con la parola da cercare o in basso o a destra e ripetere
 questo procedimento fino a quando la lettera nella casella corrente non
 sia diversa da quella nella parola da cercare oppure fino a quando non
 troviamo la parola.
 Tradotto in pseudocodice la ricorsione può essere impostata così:
\end_layout

\begin_layout Itemize
siano 
\emph on
i
\emph default
 e 
\emph on
j
\emph default
 le coordinate di riga e colonna nella matrice del Ruzzle© e 
\emph on
l
\emph default
 l'indice della lettera corrente nella parola da cercare
\end_layout

\begin_layout Itemize
le condizioni di terminazioni saranno
\begin_inset Separator latexpar
\end_inset


\end_layout

\begin_deeper
\begin_layout Itemize
se siamo arrivati fino alla fine della parola e la casella corrente ha il
 valore dell'ultima lettera, allora abbiamo trovato un percorso per la parola
 e restituiamo 
\emph on
true
\emph default
 (righe 7-8)
\end_layout

\begin_layout Itemize
se la casella corrente è diversa dalla lettera alla quale siamo arrivati
 restituiamo 
\emph on
false
\emph default
 perchè quella strada non porta da nessuna parte (righe 9-10)
\end_layout

\end_deeper
\begin_layout Itemize
se è possibile spostarsi nella casella in basso lo faccio e memorizzo il
 valore di spostamento 'B' in uno stack temporaneo (di cui si parlerà dopo)
 (righe 11-14)
\end_layout

\begin_layout Itemize
se è possibile spostarsi nella casella a destra lo faccio e memorizzo il
 valore di spostamento 'D' in uno stack temporaneo (righe 15-17)
\end_layout

\begin_layout Standard
Come si vede dal codice l'implementazione è immediata e la chiamata (riga
 28) avrà come parametri i valori i = 0, j = 0 e l = 0, poichè si parte
 dalla casella in alto a sinistra e dalla prima lettera della parola cercata.
 Se la funzione ritorna 
\emph on
false
\emph default
 vuol dire che la parola non è stata trovata e quindi verrà stampato ASSENTE,
 altrimenti bisogna stampare un possibile percorso (non è necessariamente
 l'unico, ma è il primo che viene trovato).
 Per far questo nella funzione 
\emph on
naviga
\emph default
 viene utilizzato uno stack, nel quale vengono inserire tutte le mosse fatte
 per arrivare alla soluzione.
 Siccome lo stack verrà riempito a partire dalla fine, via via che le chiamate
 ricorsive ritornano, basterà svuotare lo stack (righe 29-32) in stampa
 per ritrovarsi il percorso nell'ordine corretto.
 Si sarebbe anche potuta usare una semplice stringa per poi stamparla al
 contrario, ma l'utilizzo di strutture dati più adatte (in questo caso uno
 stack), mette al riparo da ogni errore banale, poichè forza ad utilizzare
 il modo giusto.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename ../materiali/problemi territoriali/2013_trovaparola/caso pessimo.eps
	display false
	scale 70

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:Caso-pessimo-trovaparola"

\end_inset

Caso pessimo per trovaparola
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Standard
Vale la pena a questo punto fare due osservazioni: 
\end_layout

\begin_layout Itemize
l'algoritmo non rischia di uscire dai bordi della matrice in qualche caso
 particolare? No, e il motivo è che, spostandosi solo in basso o a destra,
 incontrerà sempre un terminatore di stringa che lo farà fermare perchè
 renderà il carattere non uguale a quello cercato: per la colonna di destra
 dopo i caratteri validi, il terminatore sarà presente perchè inserito in
 fase di lettura, per la riga sotto agli ultimi caratteri validi la presenza
 del terminatore (un carattere con tutti i bit a zero) è garantita dal fatto
 che essendo la matrice una variabile globale tutte le sue caselle vengono
 azzerate alla partenza del programma
\end_layout

\begin_layout Itemize
qual è la complessità di questo algoritmo? Mentre il primo algoritmo proposto
 era di complessità lineare questo è in generale di tipo esponenziale, poichè
 ogni chiamata ricorsiva richiama due volte la stessa funzione e quindi,
 anche se N è piccolo (≤100) il numero di chiamate ricorsive nel caso pessimo
 (
\begin_inset Formula $2^{100}$
\end_inset

) è troppo elevato.
 Però il caso pessimo è un caso molto particolare, che deve essere costruito
 di proposito, come si può vedere in figura 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:Caso-pessimo-trovaparola"

\end_inset

, dove la parola da cercare è BANCO.
 In questo esempio la ricorsione è 
\begin_inset Quotes eld
\end_inset

obbligata
\begin_inset Quotes erd
\end_inset

 a provare tutte le strade, poichè si accorge che non porta a niente solo
 all'ultima lettera.
 Se però il caso è creato inserendo delle lettere casuali più eventualmente
 la parola da trovare, la maggior parte delle chiamate ricorsive verranno
 terminate all'inizio e quindi la maggior parte dei rami non verrà mai svolta,
 rendendo il costo poco più che lineare.
 Essendo al livello delle regionali si suppone che questa soluzione sia
 quella che consente di raccogliere tutti punti.
\end_layout

\begin_layout Section
La congettura di Collatz - territoriali 2014
\end_layout

\begin_layout Standard
\begin_inset Box Framed
position "t"
hor_pos "c"
has_inner_box 0
inner_pos "t"
use_parbox 0
use_makebox 0
width "100col%"
special "none"
height "1in"
height_special "totalheight"
thickness "0.4pt"
separation "3pt"
shadowsize "4pt"
framecolor "black"
backgroundcolor "none"
status collapsed

\begin_layout Subsection*
La congettura di Collatz (collatz) 
\end_layout

\begin_layout Subsubsection*
Difficoltà D = 1 
\end_layout

\begin_layout Subsubsection*
Descrizione del problema
\end_layout

\begin_layout Plain Layout
Consideriamo il seguente algoritmo, che prende in ingresso un intero positivo
 N: 
\end_layout

\begin_layout Enumerate
Se N vale 1, l’algoritmo termina.
 
\end_layout

\begin_layout Enumerate
Se N è pari, dividi N per 2, altrimenti (se N è dispari) moltiplicalo per
 3 e aggiungi 1.
\end_layout

\begin_layout Plain Layout
Per esempio, applicato al valore N = 6, l’algoritmo produce la seguente
 sequenza (di lunghezza 9, contando anche il valore iniziale N = 6 e il
 valore finale 1): 
\end_layout

\begin_layout Plain Layout
\align center
6, 3, 10, 5, 16, 8, 4, 2, 1.
\end_layout

\begin_layout Plain Layout
La congettura di Collatz, chiamata anche congettura 3N+1, afferma che l’algoritm
o qui sopra termini sempre per qualsiasi valore N; in altri termini, se
 prendo un qualsiasi numero intero maggiore di 1 applicare la regola numero
 2 conduce sempre al numero 1.
\end_layout

\begin_layout Plain Layout
È riferendosi a questa celebre congettura che il famoso matematico Erdős
 ha commentato sul come questioni semplici ma elusive mettono in evidenza
 quanto poco noi si possa accedere ai misteri del “grande Libro”.
\end_layout

\begin_layout Plain Layout
Giovanni sta cercando di dimostrare la congettura, ed è interessato alla
 lunghezza della sequenza.
 Il vostro compito è quello di aiutare Giovanni scrivendo un programma che,
 ricevuto in ingresso un numero N, calcoli la lunghezza della sequenza che
 si ottiene a partire da N.
 
\end_layout

\begin_layout Subsubsection*
Dati di input
\end_layout

\begin_layout Plain Layout
Il file 
\emph on
input.txt
\emph default
 è composto da una riga contenente N, un intero positivo.
 
\end_layout

\begin_layout Subsubsection*
Dati di output
\end_layout

\begin_layout Plain Layout
Il file 
\emph on
output.txt
\emph default
 è composto da una sola riga contenente un intero positivo L: la lunghezza
 della sequenza a partire da N.
 
\end_layout

\begin_layout Subsubsection*
Assunzioni
\end_layout

\begin_layout Itemize
2 ≤ N ≤ 1000; 
\end_layout

\begin_layout Itemize
E’ noto che, per qualsiasi N minore di 1000, la lunghezza L della sequenza
 è minore di 200.
\end_layout

\begin_layout Subsubsection*
Esempi di input/output 
\end_layout

\begin_layout Plain Layout
\begin_inset Tabular
<lyxtabular version="3" rows="2" columns="2">
<features tabularvalignment="middle">
<column alignment="left" valignment="top" width="1in">
<column alignment="left" valignment="top">
<row>
<cell alignment="left" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
File input.txt
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
File output.txt
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
6
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
9
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Tabular
<lyxtabular version="3" rows="2" columns="2">
<features tabularvalignment="middle">
<column alignment="left" valignment="top" width="1in">
<column alignment="left" valignment="top">
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
File input.txt
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
File output.txt
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
24
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
11
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Suggerimenti
\end_layout

\begin_layout Standard
Questo problema è molto semplice, perchè chiede solo di implementare una
 successione di numeri seguendo la regola che permette di calcolare il nuovo
 elemento della successione in base al valore dell'elemento attuale.
 L'unica domanda che ci si potrebbe porre è quella se prediligere una soluzione
 iterativa o una ricorsiva.
 
\end_layout

\begin_layout Itemize
Riesco a risolverlo sia in modo iterativo che ricorsivo?
\end_layout

\begin_layout Itemize
Quali sono i vantaggi o gli svantaggi di entrambe le soluzioni?
\end_layout

\begin_layout Itemize
Ai fini della soluzione di questo particolare problema, con i vincoli imposti
 sulla sua dimensione, sono rilevanti le differenze tra le due implementazioni?
\end_layout

\begin_layout Subsection
Soluzione
\end_layout

\begin_layout Standard
Considerando la semplicità del problema, spenderemo alcune parole solo sulla
 differenza tra le due possibili implementazioni, mostrate di seguito.
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "basicstyle={\small\ttfamily},frame=lr,language={C++},numbers=left,showstringspaces=false,tabsize=4"
inline false
status collapsed

\begin_layout Plain Layout

int lunghezza_collatz(int n) { 	
\end_layout

\begin_layout Plain Layout

	int lunghezza = 1; 	
\end_layout

\begin_layout Plain Layout

	while (n != 1) 	{ 		
\end_layout

\begin_layout Plain Layout

		if (n % 2) 			
\end_layout

\begin_layout Plain Layout

			n = n*3 + 1; 		
\end_layout

\begin_layout Plain Layout

		else 			
\end_layout

\begin_layout Plain Layout

			n = n/2; 		
\end_layout

\begin_layout Plain Layout

		lunghezza++; 	
\end_layout

\begin_layout Plain Layout

	} 	
\end_layout

\begin_layout Plain Layout

	return lunghezza; 
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

int lunghezza_collatz_ric(int n) { 	
\end_layout

\begin_layout Plain Layout

	if (n == 1) 		
\end_layout

\begin_layout Plain Layout

		return 1; 	
\end_layout

\begin_layout Plain Layout

	if (n % 2) 		
\end_layout

\begin_layout Plain Layout

		return lunghezza_collatz_ric(3*n + 1) + 1; 	
\end_layout

\begin_layout Plain Layout

	else 		
\end_layout

\begin_layout Plain Layout

		return lunghezza_collatz_ric(n/2) + 1; 
\end_layout

\begin_layout Plain Layout

} 	
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Come si può vedere la prima funzione, quella iterativa, non fa altro che
 riapplicare la regola numero 2 del testo finchè non si verifica la condizione
 1: l'unica attenzione è da porre nell'inizializzazione del contatore della
 lunghezza, che viene messo a 1 per garantire il rispetto dei requisiti
 del problema (contare tutti gli elemento della successione, compreso il
 numero di partenza e l'1).
 La seconda funzione, quella ricorsiva, appare ancora più naturale, essendo
 una riscrittura pari pari delle due condizioni spiegate nel testo.
\end_layout

\begin_layout Standard
Appurato quindi che da un punto di vista della scrittura del codice sono
 entrambe semplici da scrivere, possiamo vedere che differenze ci sono in
 termini di prestazioni e occupazione di memoria:
\end_layout

\begin_layout Itemize
la funzione ricorsiva richiederà alla peggio 200 chiamate (vedi testo del
 problema), dove quella iterativa viene chiamata una sola volta, quindi
 potrebbe esserci un costo maggiore dovuto all'overhead di chiamata di funzione:
 su test fatti sulla mia macchina usando l'utility 
\series bold
time
\series default
 presente di default sui sistemi Linux non si nota nessuna differenza significat
iva tra le due impelementazioni.
 Per stressare maggiormente le differenze ho quindi modificato il programma
 per calcolare la lunghezza di tutte le successioni di Collatz da 2 a 100000,
 ottenendo dei risultati che effettivamente mostrano che la versione iterativa
 ha delle performance leggermente migliori, come si può vedere dalla seguente
 tabella (i dati esatti sono differenti tra differenti esecuzioni del comando,
 ma indicativamente sono sempre intorno ai valori mostrati)
\end_layout

\begin_layout Standard
\align center
\begin_inset Tabular
<lyxtabular version="3" rows="2" columns="2">
<features tabularvalignment="middle">
<column alignment="left" valignment="top" width="5cm">
<column alignment="left" valignment="top" width="5cm">
<row>
<cell alignment="left" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
\series bold
\size small
Versione iterativa
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
\series bold
\size small
Versione ricorsiva
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
\size small
real 0m0.136s 
\end_layout

\begin_layout Plain Layout

\family typewriter
\size small
user 0m0.020s 
\end_layout

\begin_layout Plain Layout

\family typewriter
\size small
sys 0m0.072s 
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
\size small
real 0m0.196s 
\end_layout

\begin_layout Plain Layout

\family typewriter
\size small
user 0m0.068s 
\end_layout

\begin_layout Plain Layout

\family typewriter
\size small
sys 0m0.076s 
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Itemize
per quanto riguarda l'utilizzo della memoria, la versione ricorsiva potrebbe
 avere il problema che lo stack cresce a ogni chiamata, ponendo quindi dei
 problemi di 
\begin_inset Quotes eld
\end_inset

sforamento
\begin_inset Quotes erd
\end_inset

 dello stack.
 Considerando però i vincoli del problema lo stack non crescerà mai a sufficienz
a per presentare un rischio di segmentation fault e anche con le prove fatte
 con N da 2 a 100000 la successione di Collatz di lunghezza maggiore si
 ferma a 351, limite ampiamente all'interno della possibilità di crescita
 dello stack.
\end_layout

\begin_layout Standard
Concludendo, pur essendo in generale utile fare delle considerazioni sulle
 differenze implementative tra diverse soluzioni, in questo caso tali differenze
 sono irrilevanti.
\end_layout

\begin_layout Standard
Come nota di colore voglio aggiungere una simpatica vignetta presa da 
\noun on
xkcd
\noun default

\begin_inset Foot
status open

\begin_layout Plain Layout
\begin_inset CommandInset href
LatexCommand href
name "https://xkcd.com"
target "https://xkcd.com"

\end_inset

 A webcomic of romance, sarcasm, math, and language.
\end_layout

\end_inset

, che mostra cosa potrebbe succedere a Giovanni se si impegnasse troppo
 nella soluzione di questo problema...
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename ../materiali/problemi territoriali/2014_collatz/collatz_conjecture.png
	display false
	scale 80

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Collatz Conjecture
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Section
Giochiamo con Mojito - Territoriali 2014
\end_layout

\begin_layout Standard
\begin_inset Box Framed
position "t"
hor_pos "c"
has_inner_box 0
inner_pos "t"
use_parbox 0
use_makebox 0
width "100col%"
special "none"
height "1in"
height_special "totalheight"
thickness "0.4pt"
separation "3pt"
shadowsize "4pt"
framecolor "black"
backgroundcolor "none"
status collapsed

\begin_layout Subsection*
Giochiamo con Mojito (mojito) 
\end_layout

\begin_layout Subsubsection*
Difficoltà D = 2
\end_layout

\begin_layout Subsubsection*
Descrizione del problema
\end_layout

\begin_layout Plain Layout
Mojito, il jackrussell di Monica, è ormai diventato la mascotte dei Probabili
 Olimpici, i ragazzi che sono candidati a rappresentare l’Italia alle Olimpiadi
 Internazionali di Informatica 2014 a Taipei, Taiwan.
 Negli allenamenti a Volterra, Mojito gioca a palla con i ragazzi nel prato:
 lui porta la pallina al ragazzo più vicino che la calcia via; a quel punto
 Mojito rincorre la palla, l’acchiappa e la porta di nuovo al ragazzo che
 ha più vicino… e così via! Possiamo rappresentare questo gioco con una
 griglia: supponendo di avere tre ragazzi che giocano con Mojito, rappresentiamo
 la loro posizione nella griglia, rispettivamente, con R1, R2 e R3.
 Tutti i ragazzi sono piuttosto metodici, e ogni volta che tirano la palla
 questa finisce sempre nella stessa posizione (a seconda di chi tira!):
 sulla griglia indichiamo con P1 il punto in cui finisce la palla tirata
 da R1, P2 il punto in cui finisce la palla tirata da R2, ecc...
 La posizione iniziale di Mojito, con la palla, è rappresentata nella griglia
 da una M.
 Mojito misura la distanza come il minimo numero di spostamenti orizzontali
 e/o verticali per andare da una casella a un’altra.
 
\end_layout

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename ../materiali/problemi territoriali/2014_mojito/mojito.png
	display false
	scale 70

\end_inset


\end_layout

\begin_layout Plain Layout
Per esempio, consideriamo la griglia qui sopra, di dimensione 8x3.
 All’inizio Mojito si trova, insieme con la palla, nella casella (5,2);
 il ragazzo più vicino è R3, nella posizione (4,1), che dista due caselle
 da lui; il gioco inizia: 
\end_layout

\begin_layout Itemize
Mojito porta la palla a R3, che la tira nella casella (6,1); 
\end_layout

\begin_layout Itemize
a questo punto Mojito, presa la palla, la porta a R2, nella casella (7,1),
 che è il più vicino a lui; da qui la palla viene tirata nella casella (3,3);
 
\end_layout

\begin_layout Itemize
Mojito recupera la palla e la porta a R1, nella casella (1,3); R1 tira la
 palla nella casella (6,3); 
\end_layout

\begin_layout Itemize
da qui in poi saranno solo R1 e R2 a giocare, visto che quando tira R1 poi
 Mojito porta la palla a R2 e viceversa.
\end_layout

\begin_layout Plain Layout
Notiamo che, nel caso appena descritto, tutti e tre i ragazzi hanno giocato
 (anche se R3 ha toccato palla solo una volta).
 Se Mojito ha due o più ragazzi alla stessa distanza, sceglie quello che
 ha la coordinata X (orizzontale) minore e, se ve ne sono due o più con
 lo stesso valore, tra questi sceglie quello che ha la coordinata Y (verticale)
 minore.
 Mojito è molto concentrato sulla palla, e non riesce a ricordarsi se tutti
 i ragazzi l’hanno tirata.
 Il vostro compito è quello di scrivere un programma che calcoli il numero
 di ragazzi che lanciano la palla almeno una volta! 
\end_layout

\begin_layout Subsubsection*
Dati di input
\end_layout

\begin_layout Plain Layout
Il file 
\emph on
input.txt
\emph default
 è composto da 3+N righe.
 La prima riga contiene due interi positivi X e Y: le dimensioni della griglia.
 La seconda riga contiene una coppia di interi positivi: le coordinate della
 posizione iniziale di Mojito con la palla.
 La terza riga contiene N, il numero di ragazzi che giocano con Mojito.
 Ognuna delle successive N righe contiene due coppie di interi: le coordinate
 dell’i-esimo ragazzo (prima coppia di interi) e le coordinate di dove l’i-esimo
 ragazzo tirerà la palla.
 
\end_layout

\begin_layout Subsubsection*
Dati di output
\end_layout

\begin_layout Plain Layout
Il file 
\emph on
output.txt
\emph default
 è composto da una sola riga contenente un solo intero non negativo: il
 numero di ragazzi che giocano con Mojito, ovvero il numero di ragazzi che
 tirano la palla almeno una volta, a partire dalla posizione iniziale di
 Mojito.
 
\end_layout

\begin_layout Subsubsection*
Assunzioni
\end_layout

\begin_layout Itemize
1 ≤ X,Y,N ≤ 100 
\end_layout

\begin_layout Itemize
Le coordinate della griglia vanno da 1 a X e da 1 a Y (inclusi).
 
\end_layout

\begin_layout Itemize
Tutte le posizioni nel file di input sono distinte: non ci possono essere
 due ragazzi nella stessa casella, non ci sono due ragazzi che tirano nella
 stessa casella, nessun ragazzo tira nella casella dove c’è un altro ragazzo.
 
\end_layout

\begin_layout Itemize
Mojito, inizialmente, è in una casella non occupata da nessun ragazzo e
 dove nessun ragazzo tira la palla.
 
\end_layout

\begin_layout Itemize
Mojito, piccolo com’è, riesce agevolmente a passare tra le gambe dei ragazzi;
 non viene quindi ostacolato nel suo movimento da ragazzi presenti in una
 cella tra lui e la palla.
\end_layout

\begin_layout Subsubsection*
Esempi di input/output 
\end_layout

\begin_layout Plain Layout
\begin_inset Tabular
<lyxtabular version="3" rows="2" columns="2">
<features tabularvalignment="middle">
<column alignment="left" valignment="top" width="1in">
<column alignment="left" valignment="top">
<row>
<cell alignment="left" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
File input.txt
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
File output.txt
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
5 3
\end_layout

\begin_layout Plain Layout
3 3
\end_layout

\begin_layout Plain Layout
2
\end_layout

\begin_layout Plain Layout
4 3 5 3
\end_layout

\begin_layout Plain Layout
5 1 1 1 
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
1
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset VSpace medskip
\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Tabular
<lyxtabular version="3" rows="2" columns="2">
<features tabularvalignment="middle">
<column alignment="left" valignment="top" width="1in">
<column alignment="left" valignment="top">
<row>
<cell alignment="left" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
File input.txt
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
File output.txt
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
8 3
\end_layout

\begin_layout Plain Layout
5 2
\end_layout

\begin_layout Plain Layout
3
\end_layout

\begin_layout Plain Layout
1 3 6 3
\end_layout

\begin_layout Plain Layout
7 1 3 3
\end_layout

\begin_layout Plain Layout
4 1 6 1 
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
3
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Suggerimenti
\end_layout

\begin_layout Itemize
Quale tipologia di problema sembrano suggerire il testo e la figura?
\end_layout

\begin_layout Itemize
Se hai pensato a un grafo, cosa sono in questo caso i nodi e gli archi?
\end_layout

\begin_layout Itemize
Come può essere espresso questo problema in termini di un problema equivalente
 relativo ai grafi?
\end_layout

\begin_layout Itemize
Esistono altri modi per risolvere questo problema oltre che utilizzando
 i grafi?
\end_layout

\begin_layout Itemize
Indipendentemente dal modo usato, quanto costa calcolare la distanza tra
 Mojito e i ragazzi? Vale la pena precalcolarla oppure, date le dimensioni
 dell'input, se ne può fare a meno?
\end_layout

\begin_layout Subsection
Soluzioni
\end_layout

\begin_layout Standard
Come fatto notare nei suggerimenti il problema può essere affrontato usando
 una modalità risolutiva che utilizzi la teoria dei grafi.
 In questo caso possiamo vedere i nodi del grafo come i ragazzi e gli archi
 i passaggi della palla.
 Si nota facilmente che, siccome Mojito porta la palla sempre al ragazzo
 più vicino e la palla lanciata da un ragazzo cade sempre nel medesimo posto,
 questo è equivalente a dire che la palla lanciata da un ragazzo verrà sempre
 portata allo stesso ragazzo, quindi ogni ragazzo ha un arco uscente che
 porta a un altro ragazzo (eventualmente anche sé stesso), come è evidenziato
 nella figura 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:Esempi-Mojito"

\end_inset

 che rappresentata gli esempi dati nel testo.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename /home/xubuntu/Desktop/guida/materiali/problemi territoriali/2014_mojito/mojito.eps
	display false
	scale 65

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:Esempi-Mojito"

\end_inset

Esempi nel testo del problema
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Standard
Rispetto ad altri problemi il grafo non viene dato in maniera esplicita
 nei dati di input, ma deve essere costruito a partire da essi, calcolando
 la distanza che separa ogni lancio dai ragazzi per vedere dove sono diretti
 gli archi.
 Una volta costruito il grafo il problema si ridurrebbere alla solita visita,
 partendo dal nodo che rappresenta il primo ragazzo che riceve la palla
 da Mojito e, una volta terminata la visita, basterebbe contare quanti sono
 i nodi che sono stati raggiunti per rispondere alla domanda posta dal problema.
 
\end_layout

\begin_layout Standard
Vediamo però un'altra strada risolutiva che utilizza il concetto di macchina
 a stati finiti, come già visto nel problema 
\begin_inset CommandInset ref
LatexCommand ref
reference "sec:Eserciti-galattici"

\end_inset

 e che quindi non richiede la conoscenza di nessun algoritmo sui grafi
\begin_inset Foot
status collapsed

\begin_layout Plain Layout
Ovviamente la conoscenza delle nozioni fondamentali sui grafi mostrate in
 
\begin_inset CommandInset ref
LatexCommand ref
reference "chap:I-grafi"

\end_inset

 è sicuramente molto utile se si vogliono passare le territoriali e indispensabi
le se si vuole fare una prestazione significativa alle nazionali.
\end_layout

\end_inset

.
 Per l'implementazione della macchina a stati finiti è sufficiente avere
 una tabella (un vettore) che per ogni stato (il ragazzo che attualmente
 ha la palla) associa lo stato successivo in cui la palla andrà a finire.
 Partendo dal primo ragazzo e iterando attraverso il vettore fino a quando
 non si tornerà a un ragazzo già visto si otterrà la soluzione del problema,
 contando quanti sono gli stati attraverso cui si è passati.
 Per stabilire le regole della macchina a stati si potrebbero preventivamente
 calcolare tutte le distanze oppure, come fatto nella soluzione proposta,
 calcolare di volta in volta qual è il ragazzo più vicino: questa seconda
 strada, anche se potrebbe sembrare equivalente, permette di fare meno calcoli
 quando non tutti i ragazzi verranno raggiunti, evitando di calcolare distanze
 che non verranno mai usate (per la dimensione dei dati di input comunque
 questa differenza non è significativa).
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "basicstyle={\small\ttfamily},frame=lr,language={C++},numbers=left,showstringspaces=false,tabsize=4"
inline false
status collapsed

\begin_layout Plain Layout

struct coordinate{ int x,y; };   
\end_layout

\begin_layout Plain Layout

struct ragazzo{ coordinate posizione, lancio; };
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

coordinate mojito; 
\end_layout

\begin_layout Plain Layout

ragazzo ragazzi[100];  
\end_layout

\begin_layout Plain Layout

bool partecipanti[100];
\end_layout

\begin_layout Plain Layout

int N, R;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

int distanza(coordinate a, coordinate b) { 	
\end_layout

\begin_layout Plain Layout

	return abs(a.x - b.x) + abs(a.y - b.y); 
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

int calcolaProssimo(coordinate posizione) { 	
\end_layout

\begin_layout Plain Layout

	int dmin = 2001, d, posmin=-1; 	
\end_layout

\begin_layout Plain Layout

	for (int i = 0; i < N; i++) 	{ 		
\end_layout

\begin_layout Plain Layout

		d=distanza(ragazzi[i].posizione, posizione); 		
\end_layout

\begin_layout Plain Layout

		if (d < dmin) {	 			
\end_layout

\begin_layout Plain Layout

			dmin = d; 			
\end_layout

\begin_layout Plain Layout

			posmin = i; 		
\end_layout

\begin_layout Plain Layout

		} 		
\end_layout

\begin_layout Plain Layout

		else if (d == dmin) { 			
\end_layout

\begin_layout Plain Layout

			if (ragazzi[i].posizione.x < ragazzi[posmin].posizione.x) 				
\end_layout

\begin_layout Plain Layout

				posmin = i; 			
\end_layout

\begin_layout Plain Layout

			else if (ragazzi[i].posizione.x == ragazzi[posmin].posizione.x &&
\end_layout

\begin_layout Plain Layout

						ragazzi[i].posizione.y < ragazzi[posmin].posizione.y) 				
\end_layout

\begin_layout Plain Layout

				posmin = i; 		
\end_layout

\begin_layout Plain Layout

			} 	
\end_layout

\begin_layout Plain Layout

		} 	
\end_layout

\begin_layout Plain Layout

	return posmin; 
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

int main() { 	
\end_layout

\begin_layout Plain Layout

	int X,Y; 	
\end_layout

\begin_layout Plain Layout

	ifstream in("input.txt"); 	
\end_layout

\begin_layout Plain Layout

	ofstream out("output.txt"); 	
\end_layout

\begin_layout Plain Layout

	in >> X >> Y; 	
\end_layout

\begin_layout Plain Layout

	in >> mojito.x >> mojito.y; 	
\end_layout

\begin_layout Plain Layout

	in >> N, R = 1; 	
\end_layout

\begin_layout Plain Layout

	for (int i = 0; i < N; i++) 		
\end_layout

\begin_layout Plain Layout

		in >> ragazzi[i].posizione.x >> ragazzi[i].posizione.y >> 		
\end_layout

\begin_layout Plain Layout

			ragazzi[i].lancio.x >> ragazzi[i].lancio.y; 	
\end_layout

\begin_layout Plain Layout

	fill(partecipanti, partecipanti+N, false); 	
\end_layout

\begin_layout Plain Layout

	int prossimo = calcolaProssimo(mojito); 	
\end_layout

\begin_layout Plain Layout

	partecipanti[prossimo] = true; 	
\end_layout

\begin_layout Plain Layout

	prossimo = calcolaProssimo(ragazzi[prossimo].lancio); 	
\end_layout

\begin_layout Plain Layout

	while(partecipanti[prossimo] != true) 	{	 		
\end_layout

\begin_layout Plain Layout

		partecipanti[prossimo] = true; 		
\end_layout

\begin_layout Plain Layout

		R++; 		
\end_layout

\begin_layout Plain Layout

		prossimo = calcolaProssimo(ragazzi[prossimo].lancio); 	
\end_layout

\begin_layout Plain Layout

	} 	
\end_layout

\begin_layout Plain Layout

	out << R << endl; 	
\end_layout

\begin_layout Plain Layout

	return 0; 
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
La parte più lunga del codice proposto è quella che permette di calcolare
 chi è il ragazzo più vicino (righe 12-29), che risulta tale a causa dei
 vincoli imposti nel caso di uguaglianza nelle distanze.
 Pur essendo semplice, mi sento di evidenziare che possono sfuggire degli
 errori, dovuti probabilmente al copia/incolla tra controlli simili, come
 quelli alle righe 21 e 23 e lo dico perché io li ho commessi.
 Alla prima sottoposizione sul correttore dei dieci casi di test ne risultavano
 corretti solo 8, a causa di una dimenticanza nel non aver sostituito il
 < con un == quando ho fatto la copia della riga 21 nella riga 23.
 Questo tipo di errori, come già detto in altre parti, è difficile da individuar
e perchè la soluzione risolve i casi di test e fallisce solo in casi particolari
 in cui l'errore viene sollecitato.
 Il consiglio è quindi quello di essere sempre molto 
\begin_inset Quotes eld
\end_inset

vigili
\begin_inset Quotes erd
\end_inset

 anche su quelle parti che sembrano innocue e di routine.
\end_layout

\begin_layout Standard
Il programma a questo punto risulta molto semplice: dopo aver letto l'input,
 viene calcolato il ragazzo a cui verrà portata la palla inizialmente (righe
 42-44) e poi si itera il procedimento (righe 45-49) fino a quando non si
 passerà da un ragazzo già visitato, incrementando il contatore R ad ogni
 passaggio dell'iterazione.
\end_layout

\begin_layout Section
Corso per sommelier - Territoriali 2014
\end_layout

\begin_layout Standard
\begin_inset Box Framed
position "t"
hor_pos "c"
has_inner_box 0
inner_pos "t"
use_parbox 0
use_makebox 0
width "100col%"
special "none"
height "1in"
height_special "totalheight"
thickness "0.4pt"
separation "3pt"
shadowsize "4pt"
framecolor "black"
backgroundcolor "none"
status collapsed

\begin_layout Subsection*
Corso per sommelier (sommelier) 
\end_layout

\begin_layout Subsubsection*
Difficoltà D = 2
\end_layout

\begin_layout Subsubsection*
Descrizione del problema
\end_layout

\begin_layout Plain Layout
Paolo, per festeggiare il suo quarantesimo compleanno, si è iscritto a un
 corso per sommelier, dove impara a distinguere ed apprezzare le diverse
 tipologie di vini.
 Si è accorto però che, nonostante prenda solo un assaggio di ogni tipo
 di vino, per lui vale la regola fondamentale delle bevande alcoliche: quando
 le bevi, mai scendere di gradazione.
 Infatti, se per esempio Paolo assaggia un vino da 9 gradi e poi uno da
 7, il giorno dopo si sveglierà con un grosso mal di testa indipendentemente
 dalle quantità.
 Per fortuna, in ogni serata del corso è disponibile l’elenco dei vini che
 verranno portati uno dopo l’altro, e di ogni vino viene riportata la gradazione
 alcolica.
 Non è ammesso mettere da parte un vino per berlo in seguito: ogni volta
 che gli viene passato un vino Paolo può decidere se assaggiarlo o meno,
 versandone un poco nel suo Tastevin.
 Inoltre, dal momento che dopo aver assaggiato un vino Paolo deve pulire
 accuratamente il suo Tastevin con un panno, questa operazione in pratica
 gli impedisce di assaggiare due vini consecutivi .
 Paolo desidera assaggiare il maggior numero di vini possibile.
 
\end_layout

\begin_layout Plain Layout
\align center
\begin_inset Tabular
<lyxtabular version="3" rows="3" columns="9">
<features tabularvalignment="middle">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
1
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
2
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
3
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
4
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
5
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
6
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
7
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
8
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
9
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
Cilento
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
Barolo
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
Lambrusco
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
Picolit
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
Verdicchio
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
Cannonau
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
Chianti
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
Pigati
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
Donzelle
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
11
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
13
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
10
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
16
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
12
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
12
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
13
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
11
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
13
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Plain Layout
Ad esempio, se in una serata serviranno i vini mostrati nella tabella qui
 sopra, nell’ordine in cui compaiono nella tabella, il numero massimo di
 vini che Paolo può riuscire ad assaggiare, rispettando la regola, è quattro:
 può iniziare, indifferentemente, con il Cilento o con il Lambrusco, e poi
 assaggiare Verdicchio, Chianti e Donzelle.
 In questa maniera, la sequenza delle gradazioni alcoliche non scende mai:
 11 (oppure 10), 12, 13, 13.
 Ovviamente, come si vede nell’esempio, è possibile bere due o più vini
 con la stessa gradazione alcolica.
 
\end_layout

\begin_layout Subsubsection*
Dati di input
\end_layout

\begin_layout Plain Layout
Il file 
\emph on
input.txt
\emph default
 è composto da 2 righe.
 La prima riga contiene N, un intero positivo: il numero di vini che saranno
 serviti nella serata.
 La seconda riga contiene N interi positivi: le gradazioni alcoliche dei
 vini che saranno serviti, nell’ordine in cui saranno serviti.
 
\end_layout

\begin_layout Subsubsection*
Dati di output
\end_layout

\begin_layout Plain Layout
Il file 
\emph on
output.txt
\emph default
 è composto da una sola riga contenente un solo intero positivo: il numero
 massimo di vini che Paolo può assaggiare nella serata, rispettando la regola
 di non diminuire la gradazione alcolica nella sequenza e, contemporaneamente,
 il vincolo di dover pulire il Tastevin, che gli impedisce di assaggiare
 due vini consecutivi.
 
\end_layout

\begin_layout Subsubsection*
Assunzioni
\end_layout

\begin_layout Itemize
2 ≤ N ≤ 99 
\end_layout

\begin_layout Itemize
I vini hanno una gradazione alcolica compresa tra 1 e 99.
\end_layout

\begin_layout Subsubsection*
Esempi di input/output 
\end_layout

\begin_layout Plain Layout
\begin_inset Tabular
<lyxtabular version="3" rows="2" columns="2">
<features tabularvalignment="middle">
<column alignment="left" valignment="top" width="1in">
<column alignment="left" valignment="top">
<row>
<cell alignment="left" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
File input.txt
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
File output.txt
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
9
\end_layout

\begin_layout Plain Layout
11 
\end_layout

\begin_layout Plain Layout
13 
\end_layout

\begin_layout Plain Layout
10 
\end_layout

\begin_layout Plain Layout
16 
\end_layout

\begin_layout Plain Layout
12 
\end_layout

\begin_layout Plain Layout
12 
\end_layout

\begin_layout Plain Layout
13 
\end_layout

\begin_layout Plain Layout
11 
\end_layout

\begin_layout Plain Layout
13 
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
4
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset VSpace medskip
\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Tabular
<lyxtabular version="3" rows="2" columns="2">
<features tabularvalignment="middle">
<column alignment="left" valignment="top" width="1in">
<column alignment="left" valignment="top">
<row>
<cell alignment="left" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
File input.txt
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
File output.txt
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
12
\end_layout

\begin_layout Plain Layout
11 
\end_layout

\begin_layout Plain Layout
13 
\end_layout

\begin_layout Plain Layout
11 
\end_layout

\begin_layout Plain Layout
10 
\end_layout

\begin_layout Plain Layout
11 
\end_layout

\begin_layout Plain Layout
12 
\end_layout

\begin_layout Plain Layout
16 
\end_layout

\begin_layout Plain Layout
12 
\end_layout

\begin_layout Plain Layout
12 
\end_layout

\begin_layout Plain Layout
11 
\end_layout

\begin_layout Plain Layout
10 
\end_layout

\begin_layout Plain Layout
14 
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
5
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Suggerimenti
\end_layout

\begin_layout Itemize
Posso applicare una strategia greedy per risolvere il problema? 
\end_layout

\begin_layout Itemize
Dopo aver verificato che la strategia greedy non è applicabile, è possibile
 risolvere il problema ricorsivamente con un approccio a forza bruta, visitando
 tutte le possibili scelte che può fare Paolo e individuando quella che
 gli consente di assaggiare più vini?
\end_layout

\begin_layout Itemize
A che classe di complessità computazionale appartiene la soluzione precedente?
 É possibile applicarla e risolvere tutti i casi di test data la dimensione
 dell'input imposta dal problema?
\end_layout

\begin_layout Itemize
Riesco a vedere che il problema ha una struttura tale per cui posso calcolarmi
 delle sottosoluzioni e utilizzarle per costruire soluzioni di casi più
 grandi? In che modo?
\end_layout

\begin_layout Itemize
Se ho studiato bene questa guida, quale problema delle territoriali precedenti
 è molto simile a questo?
\end_layout

\begin_layout Subsection
Soluzione
\end_layout

\begin_layout Standard
Anche se questo problema a prima vista potrebbe far venire in mente di usare
 un approccio greedy si può velocemente verificare, guardando gli esempi,
 che non può funzionare.
 Usando la tecnica greedy infatti partirei dal primo vino, che è sempre
 possibile bere, e poi berrei tutti i vini che riesco nel rispetto delle
 regole fornite nel testo (mai due vini consecutivi, mai gradazioni più
 basse di quelle già bevute), ma questo mi porterebbe nella maggior parte
 dei casi a un risultato scorretto (per alcuni input potrei trovare la soluzione
, ma dipende appunto da come compaiono i numeri nell'input).
\end_layout

\begin_layout Standard
Esclusa quindi questa tecnica, si potrebbe pensare di generare ricorsivamente
 tutte le possibli sequenze di bevute e contare quella più lunga.
 Premesso che comunque non è banale scrivere la funzione che implementa
 questo approccio a forza bruta, guardandone la complessità computazionale
 e la dimensione dell'input risulta chiaro che non potrebbe risolvere molti
 casi.
 Infatti, considerando in prima approssimazione che posso prendere o non
 prendere un vino e che la sequenza di vini è lunga al massimo 50 (poichè
 non posso mai bere due vini consecutivi), si può vedere come la generazione
 di tutte le stringhe binarie di massimo 50 cifre (ovviamente non tutte
 sono generabili perchè molte violano le regole sui gradi alcolici).
 Sempre in maniera approssimata possiamo quindi dire che il costo è dell'ordine
 di 
\begin_inset Formula $2^{50}\simeq10^{15}$
\end_inset

, un numero troppo grosso per permettere di arrivare alla soluzione.
\end_layout

\begin_layout Standard
A questo punto, guardando bene la struttura del problema, possiamo rilevare
 che appare essere adatta per utilizzare la programmazione dinamica: come
 visto in 
\begin_inset CommandInset ref
LatexCommand ref
reference "cha:Programmazione-dinamica"

\end_inset

, si può utilizzare questa tecnica quando la soluzione ottima del problema
 di dimensione N può essere 
\begin_inset Quotes eld
\end_inset

ricostruita
\begin_inset Quotes erd
\end_inset

 a partire da sottoproblemi più piccoli di cui si conosce la soluzione.
 In questo caso i sottoproblemi sono le soluzioni con liste di vini più
 piccole, prese a partire dal fondo.
 Quindi se la lista di vini fosse composta solo dall'ultimo vino la soluzione
 sarebbe 1, cosa vera anche se fosse composta dagli ultimi due vini (poichè
 non posso bere due vini consecutivi).
 Se la lista fosse composta dagli ultimi N vini bisognerebbe guardare quali
 delle soluzioni precedenti possono essere 
\begin_inset Quotes eld
\end_inset

prese
\begin_inset Quotes erd
\end_inset

 compatibilmente con le regole e fra quelle scegliere quella che mi da il
 valore maggiore.
 Formalizzato questo risulta così:
\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
L(N)=1+max_{0<n\leq N-2}\{L(n)\}\;\forall n/G[n]\geq G[N]
\]

\end_inset


\end_layout

\begin_layout Standard
dove L(N) è il numero massimo di vini che si riescono a bere data la lista
 contenente gli ultimi 
\emph on
N
\emph default
 vini e G[n] e la gradazione alcolica del vino n-esimo.
\end_layout

\begin_layout Standard
A questo punto si può procedere utilizzando un approccio 
\emph on
top-down
\emph default
 oppure 
\emph on
bottom-up
\emph default
.
 Siccome questo problema è molto simile al problema Poldo (vedi 
\begin_inset CommandInset ref
LatexCommand ref
reference "sec:Esempio:Poldo"

\end_inset

) che era stato risolto con la metodologia 
\emph on
bottom-up
\emph default
, qui vedremo come risolvere lo stesso tipo di problema usando l'approccio
 
\emph on
top-down
\emph default
.
 
\end_layout

\begin_layout Standard
La definizione data sopra si presta naturalmente ad essere scritta in forma
 ricorsiva, avendo l'avvertenza di tabellare i valori già calcolati in modo
 da non doverli ricalcolare più volte.
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "basicstyle={\small\ttfamily},frame=lr,language={C++},numbers=left,showstringspaces=false,tabsize=4"
inline false
status open

\begin_layout Plain Layout

int vini[100]; 
\end_layout

\begin_layout Plain Layout

int sottoproblemi[100]; 
\end_layout

\begin_layout Plain Layout

int N;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

int soluzione(int n) { 	
\end_layout

\begin_layout Plain Layout

	if (sottoproblemi[n] != -1) 		
\end_layout

\begin_layout Plain Layout

		return sottoproblemi[n]; 	
\end_layout

\begin_layout Plain Layout

	int max = 1; 	
\end_layout

\begin_layout Plain Layout

	for (int i = n + 1; i < N; i++) 			
\end_layout

\begin_layout Plain Layout

		if (soluzione(i) + 1 > max && vini[n] <= vini[i]) 				
\end_layout

\begin_layout Plain Layout

			max = soluzione(i) + 1; 	
\end_layout

\begin_layout Plain Layout

	sottoproblemi[n] = max; 	
\end_layout

\begin_layout Plain Layout

	return max; 
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

int main() { 	
\end_layout

\begin_layout Plain Layout

	ifstream in("input.txt"); 	
\end_layout

\begin_layout Plain Layout

	ofstream out("output.txt"); 	
\end_layout

\begin_layout Plain Layout

	in >> N; 	
\end_layout

\begin_layout Plain Layout

	for (int i = 0; i < N; i++) 		
\end_layout

\begin_layout Plain Layout

		in >> vini[i]; 	
\end_layout

\begin_layout Plain Layout

	fill(sottoproblemi, sottoproblemi + N, -1); 	
\end_layout

\begin_layout Plain Layout

	sottoproblemi[N-1] = sottoproblemi[N-2] = 1; 	
\end_layout

\begin_layout Plain Layout

	soluzione(0); 	
\end_layout

\begin_layout Plain Layout

	out << *max_element(sottoproblemi,sottoproblemi + N) << endl; 	
\end_layout

\begin_layout Plain Layout

	return 0; 
\end_layout

\begin_layout Plain Layout

} 
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Per tabellare le soluzioni che via via vengono calcolate viene usato il
 vettore 
\emph on
sottoproblemi
\emph default
, che inizialmente è riempito di -1 (riga 22), tranne i due sottoproblemi
 finali, quelli composti da 1 e 2 vini, che come si è già detto hanno come
 soluzione 1 (riga 23).
 La funzione ricorsiva 
\emph on
soluzione
\emph default
 accetta come parametro la posizione del vino da partire per trovare la
 soluzione, quindi verrà chiamata con il valore 0 (riga 24) per indicare
 che si vuole calcolare la soluzione a partire dal vino in posizione 0,
 cioè la soluzione dell'intero problema.
 La prima operazione che viene svolta è il controllo se la soluzione del
 particolare sottoproblema è già stata tabulata, nel qual caso viene ritornata
 (righe 6-7).
 In caso contrario si guardano tutte le soluzioni dei sottoproblemi a partire
 da 
\emph on
n+1
\emph default
 fino alla fine (
\emph on
n+1
\emph default
 poichè non si può bere il vino subito dopo quello appena scelto) e per
 ogni sottosoluzione si controlla se è migliore della migliore trovata fino
 a quel momento e se il vino è compatibile con la regola sulla gradazione
 alcolica (righe 9-11).
 Trovata quindi la soluzione migliore questa viene tabulata (riga 12) e
 il risultato viene ritornato.
\end_layout

\begin_layout Standard
Infine si guarda nel vettore 
\emph on
sottoproblemi
\emph default
, dove sono state tabulate tutte le soluzioni ai vari sottoproblemi e si
 sceglie quella massima: per trovare il massimo nel codice è stato usato
 l'algoritmo 
\emph on
max_element
\emph default
 che, dati gli iteratori all'inizio e alla fine del contenitore (essendo
 questo un array stile C vengono forniti l'indirizzo iniziale e finale del
 vettore), restituisce un iteratore all'elemento massimo, che quindi necessita
 dell'asterisco per 
\begin_inset Quotes eld
\end_inset

trasformarlo
\begin_inset Quotes erd
\end_inset

 nel valore individuato da esso (riga 25).
\end_layout

\begin_layout Section
Numero semiprimo - Territoriali 2015
\end_layout

\begin_layout Standard
\begin_inset Box Framed
position "t"
hor_pos "c"
has_inner_box 0
inner_pos "t"
use_parbox 0
use_makebox 0
width "100col%"
special "none"
height "1in"
height_special "totalheight"
thickness "0.4pt"
separation "3pt"
shadowsize "4pt"
framecolor "black"
backgroundcolor "none"
status collapsed

\begin_layout Subsection*
Numero semiprimo (semiprimo) 
\end_layout

\begin_layout Subsubsection*
Difficoltà D = 1
\end_layout

\begin_layout Subsubsection*
Descrizione del problema
\end_layout

\begin_layout Plain Layout
Gemma ha appena imparato che cos’è un numero semiprimo, e presa dall’euforia
 non riesce a smettere di parlarne.
 In particolare, un numero semiprimo è un intero ≥ 2 che si fattorizza come
 prodotto di due numeri primi (non necessariamente distinti).
 
\end_layout

\begin_layout Plain Layout
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Tabular
<lyxtabular version="3" rows="1" columns="1">
<features tabularvalignment="middle">
<column alignment="center" valignment="top">
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
I numeri primi sono tutti quegli interi ≥ 2 divisibili solo per se stessi
 e per 1
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Plain Layout
Sono quindi esempi di numeri semiprimi i numeri: 
\end_layout

\begin_layout Itemize
15 , prodotto di 3 e 5 .
 
\end_layout

\begin_layout Itemize
169 , prodotto di 13 e 13 .
 
\end_layout

\begin_layout Plain Layout
Aiuta Gemma a scrivere un programma che verifichi se un numero N è semiprimo
 oppure no!
\end_layout

\begin_layout Subsubsection*
Dati di input
\end_layout

\begin_layout Plain Layout
Il file input.txt contiene l’unico intero N , di cui Gemma vuole verificare
 la semiprimalità.
\end_layout

\begin_layout Subsubsection*
Dati di output
\end_layout

\begin_layout Plain Layout
Il file output.txt contiene: 
\end_layout

\begin_layout Itemize
I due primi che fattorizzano N, stampati su un’unica riga, in ordine non-decresc
ente, se N è semiprimo.
 
\end_layout

\begin_layout Itemize
L’unico intero − 1 se N non è semiprimo.
\end_layout

\begin_layout Subsubsection*
Assunzioni
\end_layout

\begin_layout Itemize
2 ≤ N ≤ 1 000 000.
\end_layout

\begin_layout Subsubsection*
Esempi di input/output 
\end_layout

\begin_layout Plain Layout
\begin_inset Tabular
<lyxtabular version="3" rows="4" columns="2">
<features tabularvalignment="middle">
<column alignment="left" valignment="top" width="1in">
<column alignment="left" valignment="top">
<row>
<cell alignment="left" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
File input.txt
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
File output.txt
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
961
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
31 31
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
884053
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
101 8753
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
16
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
-1
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Suggerimenti
\end_layout

\begin_layout Itemize
Come si può verificare se un numero è primo?
\end_layout

\begin_layout Itemize
Quanto costa verificare se un numero è primo?
\end_layout

\begin_layout Itemize
Data la dimensione massima dell'input il costo di verificare se un numero
 è primo creerà dei problemi?
\end_layout

\begin_layout Itemize
Se un numero ha un divisore primo D e il numero ottenuto dalla sua divisione
 per D non lo è, posso dedurre qualcosa di utile alla soluzione del problema?
\end_layout

\begin_layout Subsection
Soluzione
\end_layout

\begin_layout Standard
Sembra evidente che per risolvere questo problema sia necessario prima essere
 in grado di stabilire se un numero è primo o meno e successivamente usare
 questa informazione per arrivare alla soluzione richiesta.
\end_layout

\begin_layout Standard
Chiunque stia imparando a programmare prima o poi si sarà trovato ad affrontare
 il problema di verificare se un numero intero è primo o meno.
 Nonostante il problema sembri a prima vista semplice, non esiste una formula
 immediata che, buttato dentro il numero, ci dica se è primo o no.
 La cosa più semplice che si può fare è quindi fare un test a tentativi,
 provando a dividere il numero per tutti i numeri compresi tra 2 e N-1 e
 vedere se si trova un divisore, nel qual caso non sarà primo.
\end_layout

\begin_layout Standard
Il costo di questo metodo dipende dalla lunghezza di N e il caso peggiore
 è quando N è primo, perchè in quel caso bisogna provare tutti i numeri
 prima di potersi fermare, quindi sembrerebbe che siano necessarie circa
 N divisioni.
 
\end_layout

\begin_layout Standard
Solitamente tutti si accorgono quasi subito che in effetti non è necessario
 provare tutti i divisori fino a N-1, dal momento che nessun divisore di
 N potrà mai essere più grande di N/2, evidentemente.
 Quello di cui molte meno persone si accorgono è che, se stiamo cercando
 un divisore, almeno uno deve essere compreso nell'intervallo [2,
\begin_inset Formula $\left\lfloor \sqrt{N}\right\rfloor $
\end_inset

], che è un intervallo molto più piccolo dell'intervallo [2, N/2].
 Quindi se non ci sono divisori minori o uguali alla radice quadrata di
 N, non ci sono divisori in assoluto
\begin_inset Foot
status collapsed

\begin_layout Plain Layout
Si lascia al lettore la dimostrazione del perchè questa affermazione è vera,
 suggerendo di procedere per assurdo.
\end_layout

\end_inset

.
\end_layout

\begin_layout Standard
Detto questo, trovare se un numero è primo o meno può essere fatto con questo
 codice
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "basicstyle={\small\ttfamily},frame=lr,language={C++},numbers=left,showstringspaces=false,tabsize=4"
inline false
status collapsed

\begin_layout Plain Layout

bool primo(int n)
\end_layout

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

	int N = sqrt(n);
\end_layout

\begin_layout Plain Layout

	for (int i = 2; i <= N; i++)
\end_layout

\begin_layout Plain Layout

		if (n%i == 0)
\end_layout

\begin_layout Plain Layout

			return false;
\end_layout

\begin_layout Plain Layout

	return true;
\end_layout

\begin_layout Plain Layout

} 
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Il ciclo parte da 2 perchè in questo modo i numeri non primi verranno 
\begin_inset Quotes eld
\end_inset

scoperti
\begin_inset Quotes erd
\end_inset

 velocemente, dal momento che tutti i pari (che sono la metà di tutti i
 numeri interi) verranno eliminati dopo un solo passaggio, i multipli di
 3 (che sono un terzo degli interi e contando solo quelli dispari sono comunque
 un sesto) verranno eliminati dopo 2 passaggi e così via.
 Data la dimensione massima dell'input stabilita dalle assunzioni del problema,
 che è 1000000, alla peggio serviranno circa 1000 passaggi per stabilire
 se un certo numero è primo o meno.
\end_layout

\begin_layout Standard
A questo punto scoprire se un numero è semiprimo si riduce a provare a dividerlo
 per un qualche primo e vedere se il risultato della divisione è anch'esso
 un numero primo.
 Anche se può sembrare debbano essere fatti molti calcoli questo procedimento
 termina piuttosto velocemente per quanto detto prima rispetto a dove possono
 trovarsi i divisori di un numero.
 Se infatti N fosse fattorizzabile nel prodotto AxB, con A e B entrambi
 primi, uno dei due sarà per forza minore di 
\begin_inset Formula $\left\lfloor \sqrt{N}\right\rfloor $
\end_inset

, che per i vincoli del problema è un numero minore di 1000.
\end_layout

\begin_layout Standard
Il codice risulta quindi il seguente:
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "basicstyle={\small\ttfamily},frame=lr,language={C++},numbers=left,showstringspaces=false,tabsize=4"
inline false
status collapsed

\begin_layout Plain Layout

int main()
\end_layout

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

	int N;
\end_layout

\begin_layout Plain Layout

	ifstream in("input.txt");
\end_layout

\begin_layout Plain Layout

	ofstream out("output.txt");
\end_layout

\begin_layout Plain Layout

	in >> N;
\end_layout

\begin_layout Plain Layout

	int M = sqrt(N);
\end_layout

\begin_layout Plain Layout

	for (int i = 2; i <= M; i++)
\end_layout

\begin_layout Plain Layout

		if (primo(i) && N%i == 0 && primo(N/i))
\end_layout

\begin_layout Plain Layout

		{
\end_layout

\begin_layout Plain Layout

			out << i << " " << N/i << endl;
\end_layout

\begin_layout Plain Layout

			return 0;
\end_layout

\begin_layout Plain Layout

		}
\end_layout

\begin_layout Plain Layout

	out << -1 << endl;
\end_layout

\begin_layout Plain Layout

	return 0;
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
dove l'
\emph on
if
\emph default
 non fa altro che controllare se 
\emph on
i
\emph default
 è primo, se è un divisore di 
\emph on
N
\emph default
 e se anche 
\emph on
N/i
\emph default
 è un numero primo.
\end_layout

\begin_layout Section
Rispetta i versi - Territoriali 2015
\end_layout

\begin_layout Standard
\begin_inset Box Framed
position "t"
hor_pos "c"
has_inner_box 0
inner_pos "t"
use_parbox 0
use_makebox 0
width "100col%"
special "none"
height "1in"
height_special "totalheight"
thickness "0.4pt"
separation "3pt"
shadowsize "4pt"
framecolor "black"
backgroundcolor "none"
status collapsed

\begin_layout Subsection*
Rispetta i versi (disuguaglianze) 
\end_layout

\begin_layout Subsubsection*
Difficoltà D = 2
\end_layout

\begin_layout Subsubsection*
Descrizione del problema
\end_layout

\begin_layout Plain Layout
Gabriele ha un nuovo rompicapo preferito, chiamato “Rispetta i versi”.
 Si tratta di un solitario giocato su una griglia formata da N caselle separate
 da un simbolo di disuguaglianza; in figura è mostrato un esempio con N
 = 6.
\end_layout

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename ../materiali/problemi territoriali/2015_disuguaglianze/schema.eps
	scale 60

\end_inset


\end_layout

\begin_layout Plain Layout
L’obiettivo del gioco è quello di riempire le celle vuote con tutti i numeri
 da 1 a N (ogni numero deve comparire esattamente una volta), in modo da
 rispettare le disuguaglianze tra caselle adiacenti.
 Per la griglia della figura, una delle possibili soluzioni al rompicapo
 è la seguente:
\end_layout

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename ../materiali/problemi territoriali/2015_disuguaglianze/schema_numeri.eps
	scale 60

\end_inset


\end_layout

\begin_layout Subsubsection*
Dati di input
\end_layout

\begin_layout Plain Layout
Il file input.txt contiene due righe di testo.
 Sulla prima è presente l’intero N , il numero di caselle del gioco.
 Sulla seconda è presente una stringa di N − 1 caratteri, ognuno dei quali
 può essere solo < o >, che descrive i vincoli tra le caselle, da sinistra
 a destra.
\end_layout

\begin_layout Subsubsection*
Dati di output
\end_layout

\begin_layout Plain Layout
Il file output.txt contiene su una sola riga una qualunque permutazione dei
 numeri da 1 a N - separati tra loro da uno spazio - che risolve il rompicapo.
 I numeri corrispondono ai valori scritti nelle caselle, leggendo da sinistra
 verso destra.
\end_layout

\begin_layout Subsubsection*
Assunzioni
\end_layout

\begin_layout Itemize
2 ≤ N ≤ 100 000.
 
\end_layout

\begin_layout Itemize
Nel 30% dei casi, il valore di N non supera 10.
\end_layout

\begin_layout Itemize
Nel 60% dei casi, il valore di N non supera 20.
 
\end_layout

\begin_layout Itemize
Si garantisce l’esistenza di almeno una soluzione per ciascuno dei casi
 di test utilizzati nella verifica del funzionamento del programma.
\end_layout

\begin_layout Subsubsection*
Esempi di input/output 
\end_layout

\begin_layout Plain Layout
\begin_inset Tabular
<lyxtabular version="3" rows="4" columns="2">
<features tabularvalignment="middle">
<column alignment="left" valignment="top" width="1in">
<column alignment="left" valignment="top">
<row>
<cell alignment="left" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
File input.txt
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
File output.txt
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
6
\end_layout

\begin_layout Plain Layout
<><<>
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
2 5 1 3 6 4
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
5
\end_layout

\begin_layout Plain Layout
>><<
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
5 3 1 2 4
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
8
\end_layout

\begin_layout Plain Layout
>><>><>
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
6 5 4 7 3 2 8 1
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Suggerimenti
\end_layout

\begin_layout Itemize
Il risultato è la permutazione di N elementi, come si realizza la permutazione
 di N elementi? Ma soprattutto, quante sono le possibili permutazioni di
 N elementi? È possibile produrle tutte e controllare quali di queste sono
 soluzioni? 
\end_layout

\begin_layout Itemize
Esclusa la possibilità di produrle, dati i limiti del problema, c'è qualche
 osservazione che mi permetta di produrre solo una di quelle corrette per
 via costruttiva e non a forza bruta?
\end_layout

\begin_layout Itemize
Cosa succede se tutti i segni di disuguaglianza sono <? Qual è la permutazione
 che soddisfa una sequenza composta solo da <?
\end_layout

\begin_layout Itemize
E se, al posto di tutti <, c'è anche un segno >? Come si può modificare
 la sequenza per renderla ancora corretta rispetto a tutte le disuguaglianze?
 La modifica coinvolge molte posizioni o solo alcune?
\end_layout

\begin_layout Itemize
E se al posto di un solo segno > ci sono due o più segni di maggiore consecutivi
? Posso estendere il ragionamento fatto in precedenza?
\end_layout

\begin_layout Subsection
Soluzione
\end_layout

\begin_layout Standard
Come in altri problemi in cui la risposta è una permutazione di elementi,
 bisogna verificare se sia una strada percorribile quella di produrle tutte
 per controllare quale sia una di quelle giuste, ma essendo il numero massimo
 di numeri della sequenza pari a 100000 la risposta è decisamente no.
 Tanto per aver un confronto, nel problema Domino massimale (vedi 
\begin_inset CommandInset ref
LatexCommand ref
reference "sec:Esempio:-Domino-massimale"

\end_inset

 
\begin_inset CommandInset ref
LatexCommand vpageref
reference "sec:Esempio:-Domino-massimale"

\end_inset

) era possibile calcolare tutte le permutazioni perchè N aveva un valore
 massimo di 10, già solo con 20 il numero di possibili permutazioni diventa
 dell'ordine dei miliardi di miliardi.
\end_layout

\begin_layout Standard
Scartata questa strada conviene fare delle prove per vedere se ci sono delle
 proprietà o delle regolarità che non sono immediatamente evidenti, anche
 semplicemente provando delle combinazioni di segni < e > e vedendo come
 arrivare alla soluzione con carta e penna.
 Quando si fanno delle prove senza avere ben chiaro dove si vuole andare
 a parare, può convenire partire da dei casi estremi, perchè spesso sono
 facili da analizzare e possono, se variati leggermente, suggerire una modalità
 con cui affrontare il problema generale.
\end_layout

\begin_layout Standard
Come suggerito, se si hanno solo segni < (tutto il ragionamento che segue
 potrebbe essere facilmente invertito nel caso di tutti segni >), la soluzione
 è banale poichè basta inserire tutti i numeri da 1 a N in ordine crescente
 e le disuguaglianze sono ovviamente soddisfatte, come si può vedere in
 fig 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:Soluzione_disuguaglianze"

\end_inset

 (a).
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement h
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename /home/xubuntu/Desktop/guida/materiali/problemi territoriali/2015_disuguaglianze/schema_soluzione.eps
	scale 55

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:Soluzione_disuguaglianze"

\end_inset

Soluzione disuguaglianze
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Standard
Se si prova a inserire un solo segno di maggiore all'interno della sequenza,
 come si vede nel caso (b), risulta chiaro che gli unici numeri che vengono
 
\begin_inset Quotes eld
\end_inset

influenzati
\begin_inset Quotes erd
\end_inset

 sono quelli adiacenti al segno cambiato e la situazione può essere rimessa
 a posto semplicemente scambiandoli.
 Tutti i numeri alla loro sinistra verificheranno ancora le disugliaglianze,
 poichè sono minori di entrambi e lo stesso vale per i numeri alla loro
 destra, che sono maggiori di entrambi.
\end_layout

\begin_layout Standard
Il ragionamento a questo punto si può facilmente estendere a un intervallo
 di lunghezza arbitraria di segni > consecutivi, semplicemente invertendo
 tutti i numeri all'interno di quell'intervallo e lasciando inalterati quelli
 prima e quelli dopo, per quanto detto prima, come si vede in (c).
\end_layout

\begin_layout Standard
Infine, poichè qualsiasi sequenza di segni di disuguaglianza può essere
 vista come una serie di segni < intervallati da segni >, si può applicare
 lo stesso meccanismo a tutta la sequenza e trovare una permutazione che
 soddisfa tutte le disuguaglianze.
\end_layout

\begin_layout Standard
Il codice quindi si riduce a:
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "basicstyle={\small\ttfamily},frame=lr,language={C++},numbers=left,showstringspaces=false,tabsize=4"
inline false
status collapsed

\begin_layout Plain Layout

char operatori[100000]; 
\end_layout

\begin_layout Plain Layout

int numeri[100000]; 
\end_layout

\begin_layout Plain Layout

int N;
\end_layout

\begin_layout Plain Layout

int main()
\end_layout

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

	int i = 0;
\end_layout

\begin_layout Plain Layout

	ifstream in("input.txt");
\end_layout

\begin_layout Plain Layout

	ofstream out("output.txt");
\end_layout

\begin_layout Plain Layout

	in >> N;
\end_layout

\begin_layout Plain Layout

	in >> operatori;
\end_layout

\begin_layout Plain Layout

	for (i = 0; i < N; i++)
\end_layout

\begin_layout Plain Layout

		numeri[i] = i+1;
\end_layout

\begin_layout Plain Layout

	i = 0;
\end_layout

\begin_layout Plain Layout

	while (i < N)
\end_layout

\begin_layout Plain Layout

	{
\end_layout

\begin_layout Plain Layout

		int start = i;
\end_layout

\begin_layout Plain Layout

		while (operatori[i] == '>') i++;
\end_layout

\begin_layout Plain Layout

		if (start != i)
\end_layout

\begin_layout Plain Layout

			reverse(numeri + start, numeri + i + 1);
\end_layout

\begin_layout Plain Layout

		i++;
\end_layout

\begin_layout Plain Layout

	}
\end_layout

\begin_layout Plain Layout

	for ( i = 0; i < N; i++)
\end_layout

\begin_layout Plain Layout

		out << numeri[i] << " ";
\end_layout

\begin_layout Plain Layout

	return 0;
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Alle righe 11-12 viene riempito l'array da tutti i numeri in ordine crescente,
 che quindi sarebbe la permutazione corretta nel caso tutti i segni di disuguagl
ianza fossero dei minori.
 Dopodichè, nel ciclo 
\emph on
while
\emph default
, si trovano le sequenze consecutive di simboli > (riga 17) e, una volta
 determinato l'inizio e la fine di una sequenza, si procede a invertire
 la posizione degli elementi utilizzando l'algoritmo di libreria 
\emph on
reverse
\emph default
, oppure scrivendo una propria funzione per invertire gli elementi contenuti
 in un intervallo di un array.
 Come ultimo passo è quindi sufficiente stampare l'array così modificato.
 
\end_layout

\begin_layout Standard
Viene lasciato al lettore come esercizio vedere come modificare il programma
 per evitare di usare un vettore e fare uno scambio effettivo, ma stampare
 direttamente i numeri ottenuti con il procedimento descritto: questa modifica,
 ai fini pratici, pur facendo migliorare leggermente le prestazioni, non
 ha nessun effetto sul punteggio, che in ogni caso sarà il massimo.
\end_layout

\begin_layout Section
\begin_inset CommandInset label
LatexCommand label
name "sec:Corsa-mattutina"

\end_inset

Corsa mattutina - Territoriali 2015
\end_layout

\begin_layout Standard
\begin_inset Box Framed
position "t"
hor_pos "c"
has_inner_box 0
inner_pos "t"
use_parbox 0
use_makebox 0
width "100col%"
special "none"
height "1in"
height_special "totalheight"
thickness "0.4pt"
separation "3pt"
shadowsize "4pt"
framecolor "black"
backgroundcolor "none"
status open

\begin_layout Subsection*
Corsa mattutina (footing) 
\end_layout

\begin_layout Subsubsection*
Difficoltà D = 2
\end_layout

\begin_layout Subsubsection*
Descrizione del problema
\end_layout

\begin_layout Plain Layout
William sta pensando di trasferirsi in una nuova città e vuole selezionare,
 tra le varie possibilità, quella che si concilia meglio con la sua routine
 mattutina.
 Infatti, William è abituato a fare una corsetta attorno al proprio isolato
 tutte le mattine, e teme che traslocando debba rinunciare a questo hobby,
 qualora l’isolato in cui verrebbe a trovarsi fosse troppo grande.
 La mappa della città si può rappresentare come un insieme di strade e di
 incroci tra queste.
 A ogni incrocio c’è una casa e le strade possono essere percorse in entrambi
 i sensi.
 Le case sono numerate da 1 a N .
 Per evitare di annoiarsi, William non ha intenzione di fare corsette che
 passino due volte davanti alla stessa casa, ad eccezione della sua (infatti
 la corsetta deve necessariamente cominciare e terminare nella stessa casa).
 Questo tipo di percorso prende il nome di ciclo semplice.
 
\end_layout

\begin_layout Plain Layout
Nonostante i buoni propositi, William è molto pigro; per questo motivo ha
 intenzione di rendere la sua corsetta mattutina il più breve possibile:
 aiutalo scrivendo un programma che prenda in input la mappa di una città
 e determini la lunghezza del ciclo semplice più corto.
 Con questa informazione, William potrà decidere se trasferirsi nella nuova
 città, ovviamente solo se riuscirà poi ad andare ad abitare in una delle
 case che appartengono a questo percorso.
 
\end_layout

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename ../materiali/problemi territoriali/2015_footing/fig1.png
	scale 40

\end_inset


\end_layout

\begin_layout Plain Layout
Si prenda ad esempio la mappa della città motrata qua sopra (dove il numero
 a fianco di ogni strada indica la lunghezza della strada), alcuni dei suoi
 cicli semplici sono i seguenti:
\end_layout

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename /home/xubuntu/Desktop/guida/materiali/problemi territoriali/2015_footing/fig2.png
	lyxscale 50
	scale 25

\end_inset


\end_layout

\begin_layout Plain Layout
Come si può vedere, i primi due cicli evidenziati hanno una lunghezza totale
 pari a 9, il terzo invece ha una lunghezza pari a 8 ed è quindi il percorso
 ottimale per la corsetta mattutina di William: adesso William sa quali
 sono le case coinvolte nel percorso più breve, e tra quelle potrà cercare
 la nuova casa in cui andare ad abitare.
\end_layout

\begin_layout Subsubsection*
Dati di input
\end_layout

\begin_layout Plain Layout
Il file input.txt contiene M + 1 righe di testo.
 Sulla prima sono presenti due interi separati da spazio: N e M , rispettivament
e il numero di case ed il numero di tratti di strada presenti nella città.
 Dalla riga 2 fino alla M + 1 troviamo la descrizione degli M tratti di
 strada.
 Ciascuna di queste righe contiene tre interi separati da spazio: u, v e
 w, dove u e v sono due case (quindi sono degli indici compresi tra 1 ed
 N ) e w è la lunghezza del tratto di strada che le collega.
\end_layout

\begin_layout Subsubsection*
Dati di output
\end_layout

\begin_layout Plain Layout
Il file output.txt contiene un singolo intero: la lunghezza del ciclo semplice
 più corto presente nella città in input.
\end_layout

\begin_layout Subsubsection*
Assunzioni
\end_layout

\begin_layout Itemize
3 ≤ N ≤ 1000.
 
\end_layout

\begin_layout Itemize
3 ≤ M ≤ 10 000.
\end_layout

\begin_layout Itemize
0 < w ≤ 10 000, dove w è la lunghezza di un tratto di strada.
 
\end_layout

\begin_layout Itemize
È garantito che nella città esiste sempre almeno un ciclo semplice.
 
\end_layout

\begin_layout Itemize
Nel 40% dei casi di prova tutte le strade hanno lunghezza unitaria.
 
\end_layout

\begin_layout Itemize
È garantito che una coppia di case adiacenti è collegata da un solo tratto
 di strada.
 
\end_layout

\begin_layout Itemize
Una strada non collega mai una casa a se stessa.
\end_layout

\begin_layout Subsubsection*
Esempi di input/output 
\end_layout

\begin_layout Plain Layout
\begin_inset Tabular
<lyxtabular version="3" rows="2" columns="2">
<features tabularvalignment="middle">
<column alignment="left" valignment="top" width="1.5in">
<column alignment="left" valignment="top">
<row>
<cell alignment="left" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
File input.txt
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
File output.txt
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none
6 10
\end_layout

\begin_layout Plain Layout
1 2 1 
\end_layout

\begin_layout Plain Layout
3 2 2 
\end_layout

\begin_layout Plain Layout
5 2 6
\end_layout

\begin_layout Plain Layout
4 5 2 
\end_layout

\begin_layout Plain Layout
1 4 2
\end_layout

\begin_layout Plain Layout
3 5 1
\end_layout

\begin_layout Plain Layout
3 4 7
\end_layout

\begin_layout Plain Layout
5 1 5 
\end_layout

\begin_layout Plain Layout
2 6 4
\end_layout

\begin_layout Plain Layout
3 6 3
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
8
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Suggerimenti
\end_layout

\begin_layout Itemize
Quale struttura dati è necessaria per memorizzare i dati di questo problema?
\end_layout

\begin_layout Itemize
Cosa vuol dire in termini di algoritmi di base (BFS, DFS) trovare un ciclo
 semplice? Può essere trovato usando uno di questi algoritmi? Oppure no?
\end_layout

\begin_layout Itemize
Un ciclo semplice può essere scomposto in un problema noto di cui si conosce
 l'algoritmo risolutivo? Se si toglie un arco da un ciclo semplice come
 può essere ripensato il problema?
\end_layout

\begin_layout Itemize
Una delle assunzioni garantisce che il 40% dei casi di test abbia strade
 di lunghezza unitaria, perchè questa assunzione può essere rilevante per
 la risoluzione di almeno parte del problema?
\end_layout

\begin_layout Itemize
Per la soluzione completa quale algoritmo dovrebbe essere utilizzato?
\end_layout

\begin_layout Subsection
Soluzione
\end_layout

\begin_layout Standard
Anche solo dalle immagini mostrate nel testo si vede subito che il problema
 fa parte della famiglia dei problemi relativi ai grafi e quindi una struttura
 dati per memorizzare le informazioni sui singoli problemi può essere la
 solita utilizzata in questa guida (vedi 
\begin_inset CommandInset ref
LatexCommand ref
reference "sec:Rappresentazione-di-grafi"

\end_inset

 
\begin_inset CommandInset ref
LatexCommand vpageref
reference "sec:Rappresentazione-di-grafi"

\end_inset

) o una sua variante.
\end_layout

\begin_layout Standard
Questo è il primo problema delle territoriali in cui viene richiesto di
 trovare dei cicli semplici e quindi potrebbe non essere immediato capire
 quale degli algoritmi sui grafi mostrati finora sia necessario applicare
 per risolvere il problema.
 Un'osservazione interessante che permette di ridefinire il problema in
 un modo in cui la soluzione diventa più naturale, è la seguente:
\end_layout

\begin_layout Quote
un ciclo può essere visto come l'arco che connette i nodi A e B più un percorso
 semplice tra A e B.
 Nel caso poi si cerchi il ciclo semplice più corto e ogni coppia di nodi
 abbia un solo arco che li unisce, la lunghezza di questo ciclo può essere
 definita come la lunghezza dell'arco che connette i nodi A e B più il percorso
 più breve che unisce A con B.
 
\end_layout

\begin_layout Standard
Quest'ultimo problema è uno di quelli che sono già stati mostrati e risolti
 in precedenza (vedi 
\begin_inset CommandInset ref
LatexCommand ref
reference "sec: cammino_minimo"

\end_inset

 
\begin_inset CommandInset ref
LatexCommand vpageref
reference "sec: cammino_minimo"

\end_inset

) e quindi è ora possibile risolvere questo problema utilizzando un algoritmo
 noto.
\end_layout

\begin_layout Standard
Siccome lo scopo è quello di trovare il ciclo con lunghezza minima tra tutti
 quelli presenti nel grafo, basterà trovare il percorso minimo tra ogni
 coppia di nodi adiacenti A e B, aggiungere per ognuno la lunghezza del
 tratto che li collega direttamente e tenere da parte il valore più basso.
 
\end_layout

\begin_layout Standard
Per quanto riguarda l'assunzione sul 40% dei casi con strade di lunghezza
 unitaria, è stata presumibilmente inserita per permettere a chi non conoscesse
 l'algoritmo di Dijkstra di poter comunque risolvere una serie di casi,
 usando una più semplice BFS (ricerca in ampiezza), poichè nel caso di archi
 di lunghezza unitaria anche la BFS è in grado di trovare il percorso minimo
 e in generale è più semplice da scrivere.
\end_layout

\begin_layout Standard
Detto questo la soluzione che permette di risolvere tutti i casi è la seguente:
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "basicstyle={\small\ttfamily},frame=lr,language={C++},numbers=left,showstringspaces=false,tabsize=4"
inline false
status collapsed

\begin_layout Plain Layout

struct tratto{
\end_layout

\begin_layout Plain Layout

	int arriva;
\end_layout

\begin_layout Plain Layout

	int lunghezza;
\end_layout

\begin_layout Plain Layout

	tratto(int a, int b):arriva(a),lunghezza(b){}
\end_layout

\begin_layout Plain Layout

};
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

struct casa{
\end_layout

\begin_layout Plain Layout

	int distanza;
\end_layout

\begin_layout Plain Layout

	list <tratto> collegate;
\end_layout

\begin_layout Plain Layout

	casa():distanza(numeric_limits<int>::max()){}
\end_layout

\begin_layout Plain Layout

};
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

casa casette[1001];
\end_layout

\begin_layout Plain Layout

set <int> stabili;
\end_layout

\begin_layout Plain Layout

int N, M;
\end_layout

\begin_layout Plain Layout

int tratti[10000][3];
\end_layout

\begin_layout Plain Layout

int percorso_minimo;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

void inizializza_djikstra()
\end_layout

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

	for (int i = 0; i <= N; i++)
\end_layout

\begin_layout Plain Layout

		casette[i].distanza = numeric_limits<int>::max();
\end_layout

\begin_layout Plain Layout

	stabili.clear();
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

	
\end_layout

\begin_layout Plain Layout

int djikstra(int begin, int end, int n_case, int interno)
\end_layout

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

	casette[begin].distanza = interno;
\end_layout

\begin_layout Plain Layout

	stabili.insert(begin);
\end_layout

\begin_layout Plain Layout

	casa casa_corrente = casette[begin];
\end_layout

\begin_layout Plain Layout

	int ultimo_inserito = begin;
\end_layout

\begin_layout Plain Layout

	while (ultimo_inserito != end)
\end_layout

\begin_layout Plain Layout

	{
\end_layout

\begin_layout Plain Layout

		list <tratto>::iterator i = casa_corrente.collegate.begin();
\end_layout

\begin_layout Plain Layout

		for(;i!=casa_corrente.collegate.end();++i)
\end_layout

\begin_layout Plain Layout

		{
\end_layout

\begin_layout Plain Layout

			if ((ultimo_inserito != begin || i->arriva != end))
\end_layout

\begin_layout Plain Layout

			{
\end_layout

\begin_layout Plain Layout

				int casa_da_aggiornare = i->arriva;
\end_layout

\begin_layout Plain Layout

				if (casette[casa_da_aggiornare].distanza > 
\end_layout

\begin_layout Plain Layout

					casette[ultimo_inserito].distanza + i->lunghezza)
\end_layout

\begin_layout Plain Layout

					casette[casa_da_aggiornare].distanza = 
\end_layout

\begin_layout Plain Layout

					casette[ultimo_inserito].distanza + i->lunghezza;
\end_layout

\begin_layout Plain Layout

				
\end_layout

\begin_layout Plain Layout

			}
\end_layout

\begin_layout Plain Layout

		}
\end_layout

\begin_layout Plain Layout

		int min = std::numeric_limits<int>::max();
\end_layout

\begin_layout Plain Layout

		for (int i = 1; i <= n_case; i++)
\end_layout

\begin_layout Plain Layout

		{			
\end_layout

\begin_layout Plain Layout

			if (stabili.find(i) == stabili.end() && casette[i].distanza < min)
\end_layout

\begin_layout Plain Layout

			{
\end_layout

\begin_layout Plain Layout

				min = casette[i].distanza;
\end_layout

\begin_layout Plain Layout

				ultimo_inserito = i;
\end_layout

\begin_layout Plain Layout

			}
\end_layout

\begin_layout Plain Layout

		}
\end_layout

\begin_layout Plain Layout

		casa_corrente = casette[ultimo_inserito];
\end_layout

\begin_layout Plain Layout

		if (min >= percorso_minimo ) return std::numeric_limits<int>::max();
\end_layout

\begin_layout Plain Layout

		stabili.insert(ultimo_inserito);
\end_layout

\begin_layout Plain Layout

	}
\end_layout

\begin_layout Plain Layout

	return casette[end].distanza;
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

int main()
\end_layout

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

	ifstream in("input.txt");
\end_layout

\begin_layout Plain Layout

	ofstream out("output.txt");
\end_layout

\begin_layout Plain Layout

	in >> N >> M;
\end_layout

\begin_layout Plain Layout

	for (int i = 0; i < M; i++)
\end_layout

\begin_layout Plain Layout

	{
\end_layout

\begin_layout Plain Layout

		int u,v,w;
\end_layout

\begin_layout Plain Layout

		in >> u >> v >> w;
\end_layout

\begin_layout Plain Layout

		casette[u].collegate.push_back(tratto(v,w));
\end_layout

\begin_layout Plain Layout

		casette[v].collegate.push_back(tratto(u,w));
\end_layout

\begin_layout Plain Layout

		tratti[i][0] = u;
\end_layout

\begin_layout Plain Layout

		tratti[i][1] = v;
\end_layout

\begin_layout Plain Layout

		tratti[i][2] = w;
\end_layout

\begin_layout Plain Layout

	}
\end_layout

\begin_layout Plain Layout

	percorso_minimo = numeric_limits<int>::max();
\end_layout

\begin_layout Plain Layout

	for (int i = 0; i < M; i++)
\end_layout

\begin_layout Plain Layout

	{
\end_layout

\begin_layout Plain Layout

		inizializza_djikstra();
\end_layout

\begin_layout Plain Layout

		int temp = djikstra(tratti[i][0],tratti[i][1],N,tratti[i][2]);
\end_layout

\begin_layout Plain Layout

		if (temp < percorso_minimo)
\end_layout

\begin_layout Plain Layout

			percorso_minimo = temp;
\end_layout

\begin_layout Plain Layout

	}
\end_layout

\begin_layout Plain Layout

	out << percorso_minimo << endl;
\end_layout

\begin_layout Plain Layout

	return 0;
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Come prima cosa vengono definite le strutture per memorizzare le informazioni,
 cioè gli archi e i nodi del grafo.
 
\end_layout

\begin_layout Standard
Alla riga 1 la struttura 
\emph on
tratto
\emph default
 contiene la variabile 
\emph on
arriva 
\emph default
che indica quale è il nodo di arrivo di quell'arco e 
\emph on
lunghezza 
\emph default
che è il peso dell'arco.
 Il costruttore (riga 4) serve solo a rendere più comoda l'inizializzazione.
 
\end_layout

\begin_layout Standard
Per quanto riguarda i nodi, alla riga 7 viene definita la struttura 
\emph on
casa
\emph default
 che contiene la variabile 
\emph on
distanza
\emph default
, che verrà utilizzata per memorizzare le varie distanze nel calcolo del
 cammino minimo, la lista dei tratti, 
\emph on
collegate
\emph default
, che contiene le tratte che collegano questa casa con le case adiacenti,
 e il costruttore vuoto che inizializza la distanza al valore massimo degli
 interi (quello che nell'algoritmo di Dijkstra teorico sarebbe il valore
 infinito): per recuperare il valore massimo degli interi viene utilizzato
 il template di classe 
\emph on
numeric_limits
\emph default
, che permette di interrogare il compilatore su varie caratteristiche dei
 tipi aritmetici, in questo caso appunto il valore massimo degli interi
\begin_inset Foot
status collapsed

\begin_layout Plain Layout
Va anche detto che se in gara non ci si ricordasse questa particolare classe,
 sarebbe sempre possibile inserire un numero molto alto, ad esempio 1000000000.
\end_layout

\end_inset

.
\end_layout

\begin_layout Standard
La funzione 
\emph on
inizializza_dijkstra
\emph default
 (riga 19) serve a riazzerare tutte le volte le strutture per il calcolo
 del cammino minimo, perchè, come detto in precedenza, questo calcolo dovrà
 essere ripetuto per ogni coppia di nodi adiacenti.
 In questa funzione, oltre a porre la distanza in tutte le case pari al
 massimo degli interi, viene anche svuotato l'insieme (definito alla riga
 14) dei nodi stabili.
\end_layout

\begin_layout Standard
Alla riga 26 viene poi definito l'algoritmo di Dijkstra, leggermente modificato
 rispetto alla versione scritta nel paragrafo 
\begin_inset CommandInset ref
LatexCommand ref
reference "algoritmo-dijkstra1"

\end_inset

.
 In particolare le modifiche si limitano a:
\end_layout

\begin_layout Enumerate
nella lista dei parametri ne viene aggiunto un quarto, che contiene la lunghezza
 del tratto diretto di strada tra 
\emph on
begin 
\emph default
e 
\emph on
end
\end_layout

\begin_layout Enumerate
questo parametro viene usato per inizializzare il valore contenuto nella
 casa di partenza al posto dello 0 (riga 28): in questo modo il valore finale
 fornito dalla funzione conterrà già la lunghezza del ciclo anzichè il solo
 valore del cammino minimo tra i nodi 
\emph on
begin
\emph default
 e 
\emph on
end
\end_layout

\begin_layout Enumerate
nel ciclo di aggiornamento delle distanze delle case adiacenti al nodo corrente
 (riga 35) viene aggiunto un controllo (riga 37) per evitare di includere
 il tratto diretto da 
\emph on
begin
\emph default
 a 
\emph on
end
\emph default
, che, come detto, non deve far parte del cammino minimo ma essere aggiunto
 a completamento del ciclo.
\end_layout

\begin_layout Enumerate
per fare una piccola ottimizazione, viene fatto un controllo (riga 57) per
 verificare che, se durante il calcolo del cammino minimo, si ottiene un
 valore già superiore al minimo trovato fino a quel momento in altre chiamate
 della funzione, si esce direttamente poichè quel ciclo sicuramente non
 potrà essere il più breve e il valore ritornato sarà il massimo degli interi.
\end_layout

\begin_layout Standard
Una curiosità a proposito del controllo indicato al punto 3: la sua scrittura
 non è del tutto intuitiva, probabilmente sarebbe stato più semplice da
 leggere nella sua forma equivalente (vedi teoremi di De Morgan):
\end_layout

\begin_layout Standard
\begin_inset VSpace medskip
\end_inset


\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "basicstyle={\small\ttfamily},language=C,numbers=left,showstringspaces=false"
inline true
status open

\begin_layout Plain Layout

!(ultimo_inserito == begin && i->arriva == end)
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset VSpace medskip
\end_inset


\end_layout

\begin_layout Standard
che letto suonerebbe come 
\begin_inset Quotes eld
\end_inset

Se il nodo di partenza non è begin e contemporaneamente il nodo di arrivo
 non è end
\begin_inset Quotes erd
\end_inset

.
 Pur essendo logicamente equivalenti, ripetute prove fatte con il correttore
 hanno evidenziato che mentre la prima versione permette di passare tutti
 i 10 casi di test, la seconda fallisce costantemente su un caso a causa
 della violazione dei limiti temporali, seppure di molto poco.
 Nelle territoriali, come spesso detto, i limiti di tempo non sono un problema,
 nel senso che durante l'esecuzione dei casi di test vengono lasciati apposta
 molto larghi, a differenza che nel correttore online: può comunque essere
 interessante notare che a volte piccole differenze nella scrittura di codice
 possono comportare differenze apprezzabili nella velocità di esecuzione
 di un programma.
\end_layout

\begin_layout Standard
A questo punto il programma, dopo la fase di lettura dei dati (righe 68-77),
 esegue un ciclo per ognuno dei tratti di strada (riga 79) e cerca il cammino
 minimo tra i due nodi che quel tratto collega, ritornando la lunghezza
 del ciclo che comprende quel tratto.
 Questa lunghezza verrà poi confrontata con il minimo attuale per eventualmente
 aggiornarlo.
\end_layout

\begin_layout Section
La spartizione di Totò - Territoriali 2016
\end_layout

\begin_layout Standard
\begin_inset Box Framed
position "t"
hor_pos "c"
has_inner_box 0
inner_pos "t"
use_parbox 0
use_makebox 0
width "100col%"
special "none"
height "1in"
height_special "totalheight"
thickness "0.4pt"
separation "3pt"
shadowsize "4pt"
framecolor "black"
backgroundcolor "none"
status collapsed

\begin_layout Subsection*
La spartizione di Totò (spartizione) 
\end_layout

\begin_layout Subsubsection*
Difficoltà D = 1
\end_layout

\begin_layout Subsubsection*
Descrizione del problema
\end_layout

\begin_layout Plain Layout
Nel film Totò Le Mokò, Totò ha un modo peculiare di dividere le gemme rubate
 con un suo complice:
\end_layout

\begin_layout Itemize
inizia dicendo “una a me” (e se ne prende una),
\end_layout

\begin_layout Itemize
poi dice “una a te” (e ne dà una al complice),
\end_layout

\begin_layout Itemize
poi dice “due a me” (e se ne prende due),
\end_layout

\begin_layout Itemize
poi dice “due a te” (ma ne dà solo una al complice),
\end_layout

\begin_layout Itemize
poi dice “tre a me” (e se ne prende tre),
\end_layout

\begin_layout Itemize
poi dice “tre a te” (ma ne dà solo una al complice),
\end_layout

\begin_layout Itemize
e così via.
 .
 .
\end_layout

\begin_layout Plain Layout
Totò inizia sempre la spartizione prendendo una gemma per sé.
 Per esempio, se ci sono 11 gemme da spartire, Totò ne prende 8 e il suo
 complice 3: la prima volta ne prendono una per uno, poi Totò due e il complice
 una, poi Totò tre e il complice una, infine Totò prende le due rimanenti
 (e nessuna gemma per il complice).
 
\end_layout

\begin_layout Plain Layout
La prima volta che Totò ha fatto questa spartizione il complice ha protestato,
 ma Totò gli ha mollato un ceffone e gli ha preso le gemme che gli aveva
 dato; da allora nessuno osa contraddire Totò Le Mokò in una spartizione.
 
\end_layout

\begin_layout Plain Layout
Le regole della spartizione sono le stesse anche se ci sono più complici
 con cui dividere il bottino: ad esempio, se ci sono 16 gemme da dividere
 in quattro (Totò e tre complici), Totò ne prende 7 e i tre complici ne
 prendono 3 ciascuno: la prima volta ne prendono una per uno, poi Totò due
 e i complici una ciascuno, poi Totò tre e i complici una ciascuno, infine
 Totò prende la gemma rimanente.
\end_layout

\begin_layout Plain Layout
Quando ci sono tante gemme Totò ha paura di sbagliarsi nella spartizione,
 quindi il vostro compito è quello di scrivere un programma che, ricevuti
 in ingresso il numero di gemme e il numero di persone (compreso Totò) tra
 cui spartirle, calcoli il numero di gemme che rimangono a Totò.
\end_layout

\begin_layout Subsubsection*
Dati di input
\end_layout

\begin_layout Plain Layout
Il file input.txt è composto da una riga contenente G e P , due interi positivi
 rappresentanti rispettivamente il numero di gemme e il numero di persone
 (compreso Totò) tra cui spartirle.
\end_layout

\begin_layout Subsubsection*
Dati di output
\end_layout

\begin_layout Plain Layout
Il file output.txt è composto da una sola riga contenente un intero positivo
 T : il numero di gemme che rimane a Totò dopo la spartizione.
\end_layout

\begin_layout Subsubsection*
Assunzioni
\end_layout

\begin_layout Itemize
10 ≤ G ≤ 1000.
\end_layout

\begin_layout Itemize
2 ≤ P ≤ 10.
\end_layout

\begin_layout Itemize
Nel 50% dei casi di input P = 2.
\end_layout

\begin_layout Subsubsection*
Esempi di input/output 
\end_layout

\begin_layout Plain Layout
\begin_inset Tabular
<lyxtabular version="3" rows="3" columns="2">
<features tabularvalignment="middle">
<column alignment="left" valignment="top" width="1.5in">
<column alignment="left" valignment="top">
<row>
<cell alignment="left" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
File input.txt
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
File output.txt
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none
11 2
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
8
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
18 4
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
9
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Suggerimenti
\end_layout

\begin_layout Itemize
Siccome la descrizione del problema è già di per sè un algoritmo, è sufficiente
 tradurlo in codice?
\end_layout

\begin_layout Subsection
Soluzione
\end_layout

\begin_layout Standard
Questo è chiaramente un problema molto semplice, nella cui descrizione è
 già contenuta la soluzione: date le assunzioni del problema è evidente
 che limitandosi a implementare nel codice il metodo usato da Totò non ci
 sarà nessun tipo di problema, poichè il numero massimo di gemme (1000)
 permette agevolmente di effettuare tutte le mosse che farebbe Totò durante
 la spartizione.
\end_layout

\begin_layout Standard
Il codice risulta quindi il seguente:
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "language={C++},numbers=left,basicstyle={\small\ttfamily},showstringspaces=false,tabsize=4,frame=lr"
inline false
status collapsed

\begin_layout Plain Layout

int main()
\end_layout

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

	int G, P, toto_corrente, complici, totale=0;
\end_layout

\begin_layout Plain Layout

	ifstream in("input.txt");
\end_layout

\begin_layout Plain Layout

	ofstream out("output.txt");
\end_layout

\begin_layout Plain Layout

	in >> G >> P;
\end_layout

\begin_layout Plain Layout

	toto_corrente = 1;
\end_layout

\begin_layout Plain Layout

	complici = P-1;
\end_layout

\begin_layout Plain Layout

	while (G >= toto_corrente + complici)
\end_layout

\begin_layout Plain Layout

	{
\end_layout

\begin_layout Plain Layout

		G -= toto_corrente + complici;
\end_layout

\begin_layout Plain Layout

		totale += toto_corrente;
\end_layout

\begin_layout Plain Layout

		toto_corrente++;
\end_layout

\begin_layout Plain Layout

	}
\end_layout

\begin_layout Plain Layout

	totale += G;
\end_layout

\begin_layout Plain Layout

	out << totale << endl;
\end_layout

\begin_layout Plain Layout

	return 0;
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Alle righe 7 e 8 vengono inizializzate le gemme che prende Totò e il numero
 dei suoi complici, successivamente, se il numero di gemme è sufficiente
 a procedere con un giro di spartizione (riga 9), vengono distribuite le
 gemme (riga 11), vengono incrementate le gemme che ha Totò (riga 12) e
 viene aumentato il numero di gemme che prenderà Totò al prossimo giro (riga
 13).
 Alla fine del ciclo vengono sommate al totale di gemme possedute da Totò
 quelle eventualmente avanzate (riga 15) e viene stampato il risultato.
\end_layout

\begin_layout Section
Discesa massima - Territoriali 2016
\end_layout

\begin_layout Standard
\begin_inset Box Framed
position "t"
hor_pos "c"
has_inner_box 0
inner_pos "t"
use_parbox 0
use_makebox 0
width "100col%"
special "none"
height "1in"
height_special "totalheight"
thickness "0.4pt"
separation "3pt"
shadowsize "4pt"
framecolor "black"
backgroundcolor "none"
status collapsed

\begin_layout Subsection*
Discesa massima (discesa) 
\end_layout

\begin_layout Subsubsection*
Difficoltà D = 2
\end_layout

\begin_layout Subsubsection*
Descrizione del problema
\end_layout

\begin_layout Plain Layout
Come ben sanno gli studenti che hanno passato le selezioni scolastiche delle
 Olimpiadi di Informatica di quest’anno, data una piramide di numeri, definiamo
 una 
\series bold
discesa
\series default
 come 
\emph on
una sequenza di numeri ottenuti partendo dalla cima della piramide e passando
 per uno dei due numeri sottostanti, fino a giungere alla base della piramide
\emph default
.
 Inoltre, il 
\series bold
valore
\series default
 di una discesa è definito come la somma dei numeri della discesa.
 La 
\series bold
discesa massima
\series default
 di una piramide è quella che ha il massimo valore tra tutte le discese
 della piramide.
 
\end_layout

\begin_layout Plain Layout
Nell’esempio seguente è stata cerchiata la discesa ottenuta partendo dalla
 cima scendendo prima a sinistra e poi sempre a destra fino alla base.
 I numeri che compongono tale discesa sono (1, 2, 7, 11) e la loro somma
 vale 21, che è il valore di questa discesa.
\end_layout

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename ../materiali/problemi territoriali/2016_discesa/discesa.png
	lyxscale 50
	scale 30

\end_inset


\end_layout

\begin_layout Plain Layout
La discesa massima di questa piramide è quella che si ottiene scendendo
 a destra, poi a sinistra e poi di nuovo a destra: i numeri di questa discesa
 sono (1, 9, 7, 11) e la loro somma vale 28, che è il valore della discesa
 massima.
 Il vostro compito è quello di scrivere un programma che, ricevuta in ingresso
 una piramide di numeri, stampi il valore della discesa massima, ovvero
 il massimo valore tra tutte le possibili discese della piramide.
\end_layout

\begin_layout Subsubsection*
Dati di input
\end_layout

\begin_layout Plain Layout
Il file input.txt è composto da 1 + A righe di testo.
 La prima riga contiene A, un intero positivo rappresentante l’altezza della
 piramide.
 Le seguenti A righe descrivono effettivamente la piramide: l’
\emph on
i
\emph default
-esima riga (con i compreso tra 1 e A) contiene 
\emph on
i
\emph default
 interi positivi rappresentanti l’
\emph on
i
\emph default
-esimo “livello” della piramide.
\end_layout

\begin_layout Subsubsection*
Dati di output
\end_layout

\begin_layout Plain Layout
Il file output.txt è composto da una sola riga contenente un intero positivo:
 il valore della discesa massima.
\end_layout

\begin_layout Subsubsection*
Assunzioni
\end_layout

\begin_layout Itemize
1 ≤ A ≤ 10.
\end_layout

\begin_layout Itemize
Il valore di ciascun numero nella piramide è un intero positivo non superiore
 a 100.
\end_layout

\begin_layout Subsubsection*
Esempi di input/output 
\end_layout

\begin_layout Plain Layout
Il primo esempio qui sotto si riferisce all’esempio mostrato nel testo del
 problema.
\end_layout

\begin_layout Plain Layout
\begin_inset space ~
\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Tabular
<lyxtabular version="3" rows="3" columns="2">
<features tabularvalignment="middle">
<column alignment="left" valignment="top" width="1.5in">
<column alignment="left" valignment="top">
<row>
<cell alignment="left" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
File input.txt
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
File output.txt
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
4 
\end_layout

\begin_layout Plain Layout
1 
\end_layout

\begin_layout Plain Layout
2 9 
\end_layout

\begin_layout Plain Layout
3 7 5 
\end_layout

\begin_layout Plain Layout
8 4 11 6
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
28
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
6 
\end_layout

\begin_layout Plain Layout
42 
\end_layout

\begin_layout Plain Layout
11 13 
\end_layout

\begin_layout Plain Layout
41 37 38 
\end_layout

\begin_layout Plain Layout
5 8 11 9 
\end_layout

\begin_layout Plain Layout
22 27 31 18 32 
\end_layout

\begin_layout Plain Layout
12 8 9 8 10 11
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
145
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Suggerimenti
\end_layout

\begin_layout Itemize
Qual è la struttura dati più adatta a memorizzare la piramide?
\end_layout

\begin_layout Itemize
Il problema è di tipo greedy? Se parto dal primo livello e ogni volta scelgo
 di scendere verso destra o verso sinistra a seconda di dove si trova il
 valore maggiore e poi proseguo da lì, arriverò in fondo con il valore della
 discesa massima?
\end_layout

\begin_layout Itemize
Posso provare tutte le alternative senza escluderne nessuna e scegliere
 quella di valore massimo? Il numero massimo di livelli è compatibile con
 questo tipo di soluzione?
\end_layout

\begin_layout Itemize
Volendo fare di meglio, posso trovare una soluzione che mi permetta di memorizza
re risultati intermedi e arrivare così ad un approccio che faccia uso della
 programmazione dinamica?
\end_layout

\begin_layout Subsection
Soluzione
\end_layout

\begin_layout Standard
L'immagine che rappresenta la piramide di numeri potrebbe far pensare a
 una struttura dati ad albero, riflettendo però un attimo è evidente che
 una matrice è più indicata per mantenere ed elaborare i dati, in quanto
 più semplice da gestire.
 Come si può vedere nella figura 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:piramide-matrice"

\end_inset

, ogni riga della matrice corrisponde a un livello della piramide e se si
 indica con 
\begin_inset Formula $n_{i,j}$
\end_inset

 il generico elemento di livello 
\emph on
i
\emph default
 e posizione 
\emph on
j
\emph default
 nella piramide (ad esempio il numero 9 sarebbe l'elemento 
\begin_inset Formula $n_{1,1}$
\end_inset

), allora i suoi 
\begin_inset Quotes eld
\end_inset

figli
\begin_inset Quotes erd
\end_inset

 sinistro e destro sono gli elementi 
\begin_inset Formula $n_{i+1,j}$
\end_inset

 e 
\begin_inset Formula $n_{i+1,j+1}$
\end_inset

, che vengono mappati nella matrice usando 
\emph on
i
\emph default
 e 
\emph on
j
\emph default
 come indici.
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement h
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename /home/xubuntu/Desktop/guida/materiali/problemi territoriali/2016_discesa/matrice.eps
	lyxscale 60
	scale 80

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:piramide-matrice"

\end_inset

Come memorizzare la piramide
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Stabilito il modo con cui vengono memorizzati i dati della piramide bisogna
 verificare se il problema è di tipo greedy oppure no, poichè questo determina
 anche l'algoritmo risolutivo.
 Se il problema fosse greedy si potrebbe, partendo dall'alto, scegliere
 ad ogni livello qual è la strada migliore: nella figura ad esempio, partendo
 dal numero 1 in cima, si sceglierebbe il 9 (massimo locale), poi il 7 e
 infine l'11, per un totale di 28, che è proprio la soluzione del problema.
 Basta questa prova per stabilire che il problema può essere risolto con
 un approccio di tipo greedy? No, e per averne una controprova è sufficiente
 applicare l'algoritmo greedy con il secondo caso di test: la somma in questo
 caso risulta 144, che non è la soluzione corretta.
\end_layout

\begin_layout Standard
Escluso quindi l'approccio greedy, una possibilità che sembra naturale è
 quella di provare a risolvere il problema in modo ricorsivo.
 Il primo passo da compiere è quello di riformulare il problema in modo
 che possa essere descritto ricorsivamente: guardando la figura 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:piramide-ricorsiva"

\end_inset

 si può vedere che la piramide iniziale può essere vista come il numero
 in alto (l'1) che si 
\begin_inset Quotes eld
\end_inset

appoggia
\begin_inset Quotes erd
\end_inset

 su due sottopiramidi, quella indicata con i contorni continui (A) e quella
 indicata con i contorni tratteggiati (B).
 In questo modo il problema iniziale viene scomposto in due problemi più
 piccoli e quindi la soluzione ricorsiva può essere formulata così:
\end_layout

\begin_layout Itemize
se una piramide ha altezza 0 allora il valore della discesa massima è 0
\end_layout

\begin_layout Itemize
altrimenti il valore della discesa della piramide di altezza N è uguale
 al massimo tra i valori della sottopiramide sinistra di altezza N-1 e della
 sottopiramide destra di altezza N-1, a cui va sommato il vertice della
 piramide di altezza N.
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement h
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename ../materiali/problemi territoriali/2016_discesa/ricorsione.eps
	scale 60

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:piramide-ricorsiva"

\end_inset

Descrizione ricorsiva
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
A questo punto l'implementazione non fa altro che seguire la formulazione
 precedente; rimane però una domanda che è spesso necessario porsi con gli
 algoritmi ricorsivi: il tempo di soluzione è ragionevole? Data l'assunzione
 che le piramidi al massimo avranno 10 livelli, la risposta è affermativa,
 poichè ad ogni livello sarà necessario calcolare ricorsivamente la soluzione
 di due sottoproblemi e quindi la complessità sarà di tipo 
\begin_inset Formula $2^{N}$
\end_inset

, che in generale è pessima, ma essendo al massimo N = 10 non darà nessun
 tipo di problema.
\end_layout

\begin_layout Standard
Il codice può essere quindi scritto in questo modo:
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "basicstyle={\small\ttfamily},frame=lr,language={C++},numbers=left,showstringspaces=false,tabsize=4"
inline false
status collapsed

\begin_layout Plain Layout

int piramide[10][10];
\end_layout

\begin_layout Plain Layout

int A;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

int discesa(int i, int j)
\end_layout

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

	if (i == A)
\end_layout

\begin_layout Plain Layout

		return 0;
\end_layout

\begin_layout Plain Layout

	int sinistra = discesa(i+1,j);
\end_layout

\begin_layout Plain Layout

	int destra = discesa(i+1,j+1);
\end_layout

\begin_layout Plain Layout

	if (sinistra > destra)
\end_layout

\begin_layout Plain Layout

		return sinistra + piramide[i][j];
\end_layout

\begin_layout Plain Layout

	return destra + piramide[i][j];
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

int main()
\end_layout

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

	ifstream in("input.txt");
\end_layout

\begin_layout Plain Layout

	ofstream out("output.txt");
\end_layout

\begin_layout Plain Layout

	in >> A;
\end_layout

\begin_layout Plain Layout

	for (int i = 0; i < A; i++)
\end_layout

\begin_layout Plain Layout

		for (int j = 0; j < i+1; j++)
\end_layout

\begin_layout Plain Layout

			in >> piramide[i][j];
\end_layout

\begin_layout Plain Layout

	out << discesa(0,0) << endl;
\end_layout

\begin_layout Plain Layout

	return 0;
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
La funzione ricorsiva 
\emph on
discesa
\emph default
 prende come parametri la posizione del vertice della piramide di cui si
 vuole calcolare il valore della discesa, quindi per la soluzione calcola
 il valore della discesa della sottopiramide sinistra (riga 8), il cui vertice
 ha indici 
\emph on
i+1
\emph default
, 
\emph on
j
\emph default
 e della sottopiramide destra (riga 9), il cui vertice ha indici 
\emph on
i+1
\emph default
, 
\emph on
j+1
\emph default
 e ritorna il massimo dei due a cui viene sommato il vertice della piramide.
 La condizione di terminazione, cioè quella che una piramide di altezza
 0 ha valore 0, viene espressa tramite il controllo sul livello raggiunto
 (riga 6), che se è pari ad A indica che si è arrivati al fondo della piramide.
\end_layout

\begin_layout Standard
Anche se questa soluzione sta ampiamente nei tempi risolutivi ammessi (sul
 correttore online il caso più pesante viene risolto in 0.004 secondi), può
 comunque essere interessante vedere come potrebbe essere risolto il problema
 utilizzando la programmazione dinamica.
 
\end_layout

\begin_layout Standard
Per ogni elemento 
\begin_inset Formula $n_{i,j}$
\end_inset

, come è già stato notato, il valore della discesa massima partendo da lì
 è il maggiore dei valori delle due sottopiramidi sommato al proprio valore:
 partendo quindi dall'ultimo livello e procedendo a ritroso possono essere
 calcolati i vari valori per ogni livello e utilizzati per calcolare i valori
 degli elementi del livello superiore, fino ad arrivare al vertice della
 piramide.
\end_layout

\begin_layout Standard
Espresso con una formula il valore della discesa partendo dall'elemento
 
\begin_inset Formula $n_{ij}$
\end_inset

 varrà
\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
V(n_{i,j})=n_{i,j}+Max(V(n_{i+1,j}),V(n_{i+1,j+1}))
\]

\end_inset


\end_layout

\begin_layout Standard
Il codice, limitandosi alla funzione dinamica, diventa quindi il seguente:
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "basicstyle={\small\ttfamily},frame=lr,language={C++},numbers=left,showstringspaces=false,tabsize=4"
inline false
status collapsed

\begin_layout Plain Layout

int discesa_dinamica()
\end_layout

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

	for (int i = A - 2; i >= 0; i--)
\end_layout

\begin_layout Plain Layout

		for (int j = 0 ; j< i+1; j++)
\end_layout

\begin_layout Plain Layout

			piramide[i][j] += piramide[i+1][j] > piramide[i+1][j+1] ? 
\end_layout

\begin_layout Plain Layout

				piramide[i+1][j] : piramide[i+1][j+1];
\end_layout

\begin_layout Plain Layout

	return piramide[0][0];
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Il ciclo esterno parte dal penultimo livello dal basso e risale fino ad
 arrivare al livello 0, quello con il vertice della piramide originale.
 Il ciclo interno, per ogni elemento del livello corrente, modifica il valore
 dell'elemento aggiungendogli il valore della maggiore tra le sottopiramidi
 di destra e di sinistra (per comodità di scrittura qui è stato usato l'operator
e ternario 
\emph on
cond?vero:falso
\emph default
, la stessa cosa poteva essere fatta con un 
\emph on
if-else
\emph default
).
 Come si può vedere è la stessa matrice 
\emph on
piramide,
\emph default
 che contiene i valori iniziali, che viene modificata per mantenere le sottosolu
zioni, senza bisogno di altre variabili aggiuntive.
 In questo modo il risultato desiderato si troverà nella casella 0,0 della
 variabile 
\emph on
piramide
\emph default
.
\end_layout

\begin_layout Standard
Un'ultima osservazione: il costo della versione dinamica è di tipo 
\begin_inset Formula $N^{2}$
\end_inset

 e per i limiti imposti da questo problema il guadagno è irrilevante rispetto
 alla versione ricorsiva.
 Comunque questa versione sarebbe in grado di risolvere problemi con una
 dimensione di N intorno alle decine di migliaia, dove quella ricorsiva
 inizierebbe a superare dei tempi ragionevoli anche solo con valori di N
 intorno a 30.
\begin_inset Newpage newpage
\end_inset


\end_layout

\begin_layout Section
Sentieri bollenti - Territoriali 2016
\end_layout

\begin_layout Standard
\begin_inset Box Framed
position "t"
hor_pos "c"
has_inner_box 0
inner_pos "t"
use_parbox 0
use_makebox 0
width "100col%"
special "none"
height "1in"
height_special "totalheight"
thickness "0.4pt"
separation "3pt"
shadowsize "4pt"
framecolor "black"
backgroundcolor "none"
status open

\begin_layout Subsection*
Sentieri bollenti (sentieri) 
\end_layout

\begin_layout Subsubsection*
Difficoltà D = 2
\end_layout

\begin_layout Subsubsection*
Descrizione del problema
\end_layout

\begin_layout Plain Layout
Mojito, il piccolo cane Jack Russell mascotte delle OII, ha accompagnato
 Monica per la supervisione della sede di gara della finale nazionale delle
 Olimpiadi 2016, a Catania.
 Dal momento che non era troppo interessato alla disposizione dei computer,
 Mojito è andato a farsi una passeggiata.
 Adesso però il sole si è alzato e, come spesso capita in Sicilia, fa molto
 caldo e l’asfalto che è stato esposto al sole è bollente.
 Per fortuna non tutti i sentieri sono esposti al sole.
 Ad esempio, nella figura sottostante, Mojito parte dal punto 1 e deve arrivare
 al punto 8.
 I sentieri bollenti sono quelli in rosso
\begin_inset Formula $^{1}$
\end_inset

.
 Si può vedere che Mojito, per minimizzare il numero di sentieri bollenti
 può andare dal punto 1 al punto 5, da qui al 3, poi al 4 e infine al punto
 8, percorrendo solo l’ultimo sentiero bollente.
 Altri percorsi equivalenti sono 1 
\begin_inset Formula $\rightarrow$
\end_inset

 5 
\begin_inset Formula $\rightarrow$
\end_inset

 3 
\begin_inset Formula $\rightarrow$
\end_inset

 4 
\begin_inset Formula $\rightarrow$
\end_inset

 6 
\begin_inset Formula $\rightarrow$
\end_inset

 8 (un solo sentiero bollente tra 6 e 8) e 1 
\begin_inset Formula $\rightarrow$
\end_inset

 5 
\begin_inset Formula $\rightarrow$
\end_inset

 3 
\begin_inset Formula $\rightarrow$
\end_inset

 4 
\begin_inset Formula $\rightarrow$
\end_inset

 6 
\begin_inset Formula $\rightarrow$
\end_inset

 7 
\begin_inset Formula $\rightarrow$
\end_inset

 8 (un solo sentiero bollente tra 6 e 7).
\end_layout

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename ../materiali/problemi territoriali/2016_sentieri/esempio.png
	lyxscale 50
	scale 30

\end_inset


\end_layout

\begin_layout Plain Layout
Come si vede dall’esempio, non conta il numero complessivo di sentieri percorsi,
 ma solo il numero di sentieri bollenti.
 Il vostro compito consiste nell’aiutare Mojito a trovare una strada per
 tornare alla sede di gara che abbia il numero minimo di tratti esposti
 al sole.
\end_layout

\begin_layout Subsubsection*
Dati di input
\end_layout

\begin_layout Plain Layout
Il file input.txt è composto da 
\emph on
1 + S
\emph default
 righe di testo.
 La prima riga contiene 
\emph on
N
\emph default
 , 
\emph on
A
\emph default
 e 
\emph on
B
\emph default
, tre interi separati da spazio che rappresentano rispettivamente il numero
 di incroci (punti nella mappa), il numero di sentieri non bollenti, ed
 il numero di sentieri bollenti.
 
\end_layout

\begin_layout Plain Layout
Le 
\emph on
A + B
\emph default
 righe successive contengono due interi positivi per ogni riga, rappresentanti
 i punti collegati dall’
\emph on
i
\emph default
-esimo sentiero.
 Le prime 
\emph on
A
\emph default
 righe sono quelle che rappresentano i sentieri non bollenti, mentre le
 successive 
\emph on
B
\emph default
 righe rappresentano i sentieri bollenti.
\end_layout

\begin_layout Subsubsection*
Dati di output
\end_layout

\begin_layout Plain Layout
Il file output.txt è composto da una sola riga contenente un intero positivo:
 il minimo numero di sentieri bollenti che Mojito deve percorrere per andare
 dal punto 1 al punto 
\emph on
N
\emph default
 .
\end_layout

\begin_layout Subsubsection*
Assunzioni
\end_layout

\begin_layout Itemize
Mojito parte sempre dal punto 1 e deve sempre arrivare al punto N .
\end_layout

\begin_layout Itemize
Esiste sempre almeno un percorso che collega il punto 1 al punto N .
\end_layout

\begin_layout Itemize
5 ≤ N ≤ 100.
\end_layout

\begin_layout Itemize
10 ≤ A + B ≤ 1000.
\end_layout

\begin_layout Itemize
B potrebbe valere zero.
\end_layout

\begin_layout Itemize
Un sentiero può essere percorso in entrambi i versi (informalmente: nessun
 sentiero è a senso unico).
\end_layout

\begin_layout Itemize
Uno stesso sentiero viene indicato al massimo una volta nel file di input.
\end_layout

\begin_layout Subsubsection*
Esempi di input/output 
\end_layout

\begin_layout Plain Layout
Il secondo esempio qui sotto si riferisce all’esempio mostrato nel testo
 del problema.
\end_layout

\begin_layout Plain Layout
\begin_inset space ~
\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Tabular
<lyxtabular version="3" rows="3" columns="2">
<features tabularvalignment="middle">
<column alignment="left" valignment="top" width="1.5in">
<column alignment="left" valignment="top">
<row>
<cell alignment="left" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
File input.txt
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
File output.txt
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
7 1 11
\end_layout

\begin_layout Plain Layout
1 5
\end_layout

\begin_layout Plain Layout
3 5
\end_layout

\begin_layout Plain Layout
4 3
\end_layout

\begin_layout Plain Layout
4 6
\end_layout

\begin_layout Plain Layout
1 2
\end_layout

\begin_layout Plain Layout
2 3
\end_layout

\begin_layout Plain Layout
3 1
\end_layout

\begin_layout Plain Layout
1 6
\end_layout

\begin_layout Plain Layout
5 6
\end_layout

\begin_layout Plain Layout
5 4
\end_layout

\begin_layout Plain Layout
4 7
\end_layout

\begin_layout Plain Layout
6 7
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
2
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
8 5 9
\end_layout

\begin_layout Plain Layout
1 5
\end_layout

\begin_layout Plain Layout
3 5
\end_layout

\begin_layout Plain Layout
4 3
\end_layout

\begin_layout Plain Layout
4 6
\end_layout

\begin_layout Plain Layout
7 8
\end_layout

\begin_layout Plain Layout
1 2
\end_layout

\begin_layout Plain Layout
2 3
\end_layout

\begin_layout Plain Layout
3 1
\end_layout

\begin_layout Plain Layout
1 6
\end_layout

\begin_layout Plain Layout
5 6
\end_layout

\begin_layout Plain Layout
5 4
\end_layout

\begin_layout Plain Layout
4 8
\end_layout

\begin_layout Plain Layout
6 8
\end_layout

\begin_layout Plain Layout
6 7
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
1
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset VSpace medskip
\end_inset


\end_layout

\begin_layout Plain Layout

\size footnotesize
1.
 Nella versione stampata in bianco e nero i percorsi bollenti sono quelli
 più chiari
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
footnotetext{Nella versione stampata in bianco e nero i percorsi bollenti
 sono quelli più chiari}
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Suggerimenti
\end_layout

\begin_layout Itemize
Quale struttura dati è necessaria per memorizzare i dati di questo problema?
\end_layout

\begin_layout Itemize
Si riesce a ricondurre il problema alla soluzione di un problema noto?
\end_layout

\begin_layout Itemize
L'assunzione sul fatto che ci siano casi senza sentieri bollenti (B = 0),
 cosa cambia nella soluzione del problema?
\end_layout

\begin_layout Subsection
Soluzione
\end_layout

\begin_layout Standard
Come per altri problemi delle ultime selezioni territoriali, la figura dell'esem
pio indica abbastanza chiaramente che il problema riguarda i grafi e pertanto
 verrà utilizzata la solita struttura con nodi contenenti una lista di archi
 già usata in precedenza.
\end_layout

\begin_layout Standard
Il problema principale è individuare che tipo di problema sui grafi bisogna
 andare a risolvere, poichè a prima vista non sembra essere nessuno di quelli
 già incontrati e che richiedevano uno dei classici algoritmi BFS, DFS e
 Dijkstra.
 Prima però di tentare altre strade conviene riflettere meglio e vedere
 se una qualche osservazione permette di ricondurre il problema a qualcosa
 di noto.
\end_layout

\begin_layout Standard
In effetti il problema assomiglia a quello della ricerca del cammino minimo,
 solo che al posto dei pesi sugli archi quello che interessa è minimizzare
 il numero di archi di un certo tipo.
 Se il problema fosse solo quello di minimizzare il numero di archi percorsi,
 era già stato evidenziato nel problema 
\emph on
footing 
\emph default
(
\begin_inset CommandInset ref
LatexCommand ref
reference "sec:Corsa-mattutina"

\end_inset

) che basterebbe fare una BFS, tenendo conto del numero di livelli attraversati
 a partire dal nodo sorgente fino ad arrivare al nodo che interessa.
 Nel caso quindi ci siano solo sentieri bollenti, questo algoritmo permetterebbe
 di trovare la soluzione.
 A questo punto l'assunzione che esistano dei casi con B = 0 suona un po'
 strana, nel senso che se A fosse stato uguale a 0 in alcuni casi questo
 avrebbe indicato la possibilità di usare la BFS per questi casi, con B
 = 0 invece vuol dire che se il programma stampa sempre come soluzione 0
 prenderà alcuni punti comunque.
 
\end_layout

\begin_layout Standard
Lasciando quindi perdere questa soluzione e affrontando il problema per
 poterlo risolvere completamente, è necessario fare un'osservazione di tipo
 
\emph on

\begin_inset Quotes eld
\end_inset

Aha!
\begin_inset Quotes erd
\end_inset


\emph default
, come la chiamerebbe J.
 Bentley
\begin_inset Foot
status collapsed

\begin_layout Plain Layout
Nel suo libro Programming Pearls con questa espressione vengono indicate
 quelle osservazioni che una volta fatte rendono un problema apparentemente
 complesso molto più semplice da affrontare.
\end_layout

\end_inset

.
 Nel problema i sentieri non hanno un peso e sono divisi in due tipi, quelli
 bollenti e quelli no: dei sentieri normali se ne possono percorrere quanti
 se ne vuole e il costo sarà sempre 0, mentre bisogna minimizzare il numero
 di sentieri bollenti percorsi, poichè ognuno di essi incrementerà di 1
 il costo totale.
 Messa in questo modo, cosa può venire in mente? Dovrebbe essere abbastanza
 naturale associare dei pesi particolari ai sentieri e far tornare questo
 problema alla ricerca di un cammino minimo: infatti se ad ogni sentiero
 normale viene associato il peso 0 e a ogni sentiero bollente il peso 1,
 è facile notare che l'algoritmo di Dijkstra fornisce la risposa cercata
 con un costo ottimale, sia in termini di semplicità di scrittura (è comunque
 un algoritmo noto e già utilizzato in altre situazioni) che di prestazioni.
 
\end_layout

\begin_layout Standard
Il codice a questo punto risulta il seguente:
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "basicstyle={\small\ttfamily},frame=lr,language={C++},numbers=left,showstringspaces=false,tabsize=4"
inline false
status collapsed

\begin_layout Plain Layout

struct sentiero{
\end_layout

\begin_layout Plain Layout

	int arriva;
\end_layout

\begin_layout Plain Layout

	int lunghezza;
\end_layout

\begin_layout Plain Layout

	sentiero(int a, int b):arriva(a),lunghezza(b){}
\end_layout

\begin_layout Plain Layout

};
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

struct incrocio{
\end_layout

\begin_layout Plain Layout

	int distanza;
\end_layout

\begin_layout Plain Layout

	list <sentiero> collegati;
\end_layout

\begin_layout Plain Layout

	incrocio():distanza(numeric_limits<int>::max()){}
\end_layout

\begin_layout Plain Layout

};
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

incrocio incroci[101];
\end_layout

\begin_layout Plain Layout

set <int> stabili;
\end_layout

\begin_layout Plain Layout

int N, A, B;
\end_layout

\begin_layout Plain Layout

int percorso_minimo;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

int dijkstra(int begin, int end, int n_incroci)
\end_layout

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

	incroci[begin].distanza = 0;
\end_layout

\begin_layout Plain Layout

	stabili.insert(begin);
\end_layout

\begin_layout Plain Layout

	incrocio incrocio_corrente = incroci[begin];
\end_layout

\begin_layout Plain Layout

	int ultimo_inserito = begin;
\end_layout

\begin_layout Plain Layout

	while (ultimo_inserito != end)
\end_layout

\begin_layout Plain Layout

	{
\end_layout

\begin_layout Plain Layout

		auto i = incrocio_corrente.collegati.begin();
\end_layout

\begin_layout Plain Layout

		for(;i!=incrocio_corrente.collegati.end();++i)
\end_layout

\begin_layout Plain Layout

		{
\end_layout

\begin_layout Plain Layout

			int incrocio_da_aggiornare = i->arriva;
\end_layout

\begin_layout Plain Layout

			if (incroci[incrocio_da_aggiornare].distanza > 
\end_layout

\begin_layout Plain Layout

				incroci[ultimo_inserito].distanza + i->lunghezza)
\end_layout

\begin_layout Plain Layout

					incroci[incrocio_da_aggiornare].distanza = 
\end_layout

\begin_layout Plain Layout

						incroci[ultimo_inserito].distanza + i->lunghezza;
\end_layout

\begin_layout Plain Layout

				
\end_layout

\begin_layout Plain Layout

		}
\end_layout

\begin_layout Plain Layout

		int min = std::numeric_limits<int>::max();
\end_layout

\begin_layout Plain Layout

		for (int i = 1; i <= n_incroci; i++)
\end_layout

\begin_layout Plain Layout

		{			
\end_layout

\begin_layout Plain Layout

			if (stabili.find(i) == stabili.end() && incroci[i].distanza < min)
\end_layout

\begin_layout Plain Layout

			{
\end_layout

\begin_layout Plain Layout

				min = incroci[i].distanza;
\end_layout

\begin_layout Plain Layout

				ultimo_inserito = i;
\end_layout

\begin_layout Plain Layout

			}
\end_layout

\begin_layout Plain Layout

		}
\end_layout

\begin_layout Plain Layout

		incrocio_corrente = incroci[ultimo_inserito];
\end_layout

\begin_layout Plain Layout

		stabili.insert(ultimo_inserito);
\end_layout

\begin_layout Plain Layout

	}
\end_layout

\begin_layout Plain Layout

	return incroci[end].distanza;
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

int main()
\end_layout

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

	ifstream in("input.txt");
\end_layout

\begin_layout Plain Layout

	ofstream out("output.txt");
\end_layout

\begin_layout Plain Layout

	in >> N >> A >> B;
\end_layout

\begin_layout Plain Layout

	for (int i = 0; i < A; i++)
\end_layout

\begin_layout Plain Layout

	{
\end_layout

\begin_layout Plain Layout

		int u,v;
\end_layout

\begin_layout Plain Layout

		in >> u >> v;
\end_layout

\begin_layout Plain Layout

		incroci[u].collegati.push_back(sentiero(v,0));
\end_layout

\begin_layout Plain Layout

		incroci[v].collegati.push_back(sentiero(u,0));
\end_layout

\begin_layout Plain Layout

	}
\end_layout

\begin_layout Plain Layout

	for (int i = 0; i < B; i++)
\end_layout

\begin_layout Plain Layout

	{
\end_layout

\begin_layout Plain Layout

		int u,v;
\end_layout

\begin_layout Plain Layout

		in >> u >> v;
\end_layout

\begin_layout Plain Layout

		incroci[u].collegati.push_back(sentiero(v,1));
\end_layout

\begin_layout Plain Layout

		incroci[v].collegati.push_back(sentiero(u,1));
\end_layout

\begin_layout Plain Layout

	}
\end_layout

\begin_layout Plain Layout

	out << dijkstra(1, N, N) << endl;
\end_layout

\begin_layout Plain Layout

	return 0;
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
La parte del calcolo del cammino minimo è sostanzialmente uguale a quella
 già vista nel problema 
\begin_inset CommandInset ref
LatexCommand ref
reference "sec:Corsa-mattutina"

\end_inset

 e ricalca l'algoritmo spiegato in 
\begin_inset CommandInset ref
LatexCommand ref
reference "algoritmo-dijkstra1"

\end_inset

 e quindi non verrà qui spiegata, da notare solo l'introduzione della parola
 chiave 
\series bold
auto
\series default
 (riga 26), che nello standard C++11 può essere usata per semplificare quelle
 dichiarazioni che altrimenti sarebbero prolisse, come in questo caso per
 l'iteratore: nel caso si voglia utilizzare questa caratteristica del linguaggio
 è necessario indicarlo nella fase di compilazione, spuntando il checkbox
 opportuno se si usa un ambiente grafico come CodeBlocks oppure aggiungendo
 il flag 
\series bold
-std=c++11
\series default
 alla riga di compilazione, se si compila utilizzando la riga di comando.
\end_layout

\begin_layout Standard
Infine per l'assegnazione dei pesi le righe dalla 56 alla 62 mettono il
 peso 0 ai sentieri normali, mentre le righe dalla 63 alla 69 mettono il
 peso 1 ai sentieri bollenti.
\end_layout

\begin_layout Section
\begin_inset CommandInset label
LatexCommand label
name "sec:Crittografia-LWF"

\end_inset

Crittografia LWF - Territoriali 2017
\end_layout

\begin_layout Standard
\begin_inset Box Doublebox
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
use_makebox 0
width "100col%"
special "none"
height "1in"
height_special "totalheight"
thickness "0.4pt"
separation "3pt"
shadowsize "4pt"
framecolor "black"
backgroundcolor "none"
status open

\begin_layout Plain Layout
I problemi del 2017 non sono nella loro formulazione originaria, ma sono
 stati modificati i dati di input/output in modo da riflettere la nuova
 impostazione della sottomissione che verrà utilizzata per la prima volta
 nelle territoriali del 18 aprile 2018.
 Al momento della scrittura (marzo 2018) è possibile testare questa nuova
 modalità all'indirizzo 
\begin_inset CommandInset href
LatexCommand href
name "https://territoriali.olinfo.it"
target "https://territoriali.olinfo.it"

\end_inset

, usando come token il proprio username dopo essersi loggati al sito principale
 degli allenamenti 
\begin_inset CommandInset href
LatexCommand href
name "https://training.olinfo.it/"
target "https://training.olinfo.it/"

\end_inset

.
 Una descrizione della nuova modalità si trova al paragrafo 
\begin_inset CommandInset ref
LatexCommand vref
reference "sec:Nuova-mod_sottoposizione"

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Box Framed
position "t"
hor_pos "c"
has_inner_box 0
inner_pos "t"
use_parbox 0
use_makebox 0
width "100col%"
special "none"
height "1in"
height_special "totalheight"
thickness "0.4pt"
separation "3pt"
shadowsize "4pt"
framecolor "black"
backgroundcolor "none"
status collapsed

\begin_layout Subsection*
Crittografia LWF (lwf)
\end_layout

\begin_layout Subsubsection*
Difficoltà D = 1
\end_layout

\begin_layout Subsubsection*
Descrizione del problema
\end_layout

\begin_layout Plain Layout
Luca e William devono sovente scambiarsi delle segretissime informazioni
 riguardo alle selezioni territoriali, sotto forma di numeri interi N.
 Per evitare di essere scoperti, hanno quindi deciso di inventare un nuovo
 codice crittografico, che hanno chiamato codice Luca-William-Fibonacci
 (LWF).
 In questo codice, ogni numero intero N viene tradotto in una sequenza 
\begin_inset Formula $s_{0}s_{1}\ldots s_{k}$
\end_inset

 di cifre binarie ‘0’ e ‘1’, di cui l’ultima è un ‘1’, in maniera tale che:
\end_layout

\begin_layout Plain Layout
\align center
\begin_inset Formula 
\[
N=\sum_{i=0}^{k}s_{i}\cdotp F_{i}
\]

\end_inset


\end_layout

\begin_layout Plain Layout
dove 
\begin_inset Formula $F_{i}$
\end_inset

 è il numero di Fibonacci 
\emph on
i
\emph default
-esimo.
 Più informalmente, una cifra 1 in posizione 
\emph on
i
\emph default
 nella sequenza indica che il numero di Fibonacci 
\emph on
i
\emph default
-esimo fa parte della somma che ricostruisce il numero N .
\end_layout

\begin_layout Plain Layout
\begin_inset VSpace defskip
\end_inset


\end_layout

\begin_layout Plain Layout
\align center
\begin_inset Box Doublebox
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 1
use_makebox 0
width "90col%"
special "none"
height "1in"
height_special "totalheight"
thickness "0.4pt"
separation "3pt"
shadowsize "4pt"
framecolor "black"
backgroundcolor "none"
status collapsed

\begin_layout Plain Layout
La sequenza dei numeri di Fibonacci è definita in maniera ricorsiva: i primi
 due termini della sequenza sono 
\begin_inset Formula $F_{0}=1$
\end_inset

 e 
\begin_inset Formula $F_{1}=1$
\end_inset

, mentre ognuno dei successivi viene calcolato sommando i due precedenti
 
\begin_inset Formula $F_{i}=F_{i-1}+F_{i-2}$
\end_inset

.
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
Per esempio, consideriamo la sequenza 
\family typewriter
1011001
\family default
 di lunghezza 
\emph on
k
\emph default
 = 7.
 Visto che i primi 7 numeri di Fibonacci sono:
\end_layout

\begin_layout Plain Layout
\align center
1
\begin_inset space \quad{}
\end_inset

1
\begin_inset space \quad{}
\end_inset

2
\begin_inset space \quad{}
\end_inset

3
\begin_inset space \quad{}
\end_inset

5
\begin_inset space \quad{}
\end_inset

8
\begin_inset space \quad{}
\end_inset

13
\end_layout

\begin_layout Plain Layout
il numero 
\emph on
N
\emph default
 corrispondente è pari a 1 + 2 + 3 + 13 = 19.
 
\end_layout

\begin_layout Plain Layout
Luca ha già implementato l’algoritmo di decodifica (descritto come sopra),
 che da una sequenza di cifre binarie ricostruisce il numero 
\emph on
N
\emph default
.
 Tuttavia William è ancora in alto mare con l’algoritmo di codifica, che
 dato un numero 
\emph on
N
\emph default
 dovrebbe produrre una sequenza di cifre binarie corrispondente.
 Implementalo tu!
\end_layout

\begin_layout Subsubsection*
Dati di input
\end_layout

\begin_layout Plain Layout
La prima riga del file di input contiene un intero 
\series bold
T
\series default
, il numero di testcase.
 Le successive 
\series bold
T
\series default
 righe contengono un intero ciascuna: il valore intero 
\series bold
N
\series default
 del relativo testcase.
\end_layout

\begin_layout Subsubsection*
Dati di output
\end_layout

\begin_layout Plain Layout
Il file di output deve essere composto da 
\series bold
T
\series default
 righe, ciascuna delle quali contenente la dicitura 
\family typewriter
Case #x: y
\family default
 dove 
\family typewriter
x
\family default
 è il numero del testcase (a partire da 1) e 
\family typewriter
y
\family default
 è una sequenza di cifre binarie corrispondente al valore di N del testcase,
 che termina con '1'.
\end_layout

\begin_layout Subsubsection*
Assunzioni
\end_layout

\begin_layout Itemize
1 ≤ T ≤ 20.
\end_layout

\begin_layout Itemize
1 ≤ N ≤ 1 000 000.
 
\end_layout

\begin_layout Itemize
Potrebbero esserci più sequenze di cifre ugualmente valide.
\end_layout

\begin_layout Subsubsection*
Esempi di input/output 
\end_layout

\begin_layout Plain Layout
Il secondo esempio qui sotto si riferisce all’esempio mostrato nel testo
 del problema.
\end_layout

\begin_layout Plain Layout
\begin_inset space ~
\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Tabular
<lyxtabular version="3" rows="2" columns="2">
<features tabularvalignment="middle">
<column alignment="left" valignment="top" width="1.5in">
<column alignment="left" valignment="top" width="5cm">
<row>
<cell alignment="left" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
File input.txt
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
File output.txt
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
2
\end_layout

\begin_layout Plain Layout

\family typewriter
19
\end_layout

\begin_layout Plain Layout

\family typewriter
9
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
Case #1: 1011001 
\end_layout

\begin_layout Plain Layout

\family typewriter
Case #2: 11101
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\begin_inset VSpace defskip
\end_inset


\end_layout

\begin_layout Plain Layout
\noindent
Il 
\series bold
primo caso di esempio
\series default
 è quello discusso nel testo.
 
\end_layout

\begin_layout Plain Layout
\noindent
Nel 
\series bold
secondo caso di esempio
\series default
, 9 può essere ottenuto sia come 1+1+2+5 (come nell’output di esempio),
 oppure come 1+3+5 (
\family typewriter
10011
\family default
) e 1+8 (
\family typewriter
100001
\family default
).
 
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Suggerimenti
\end_layout

\begin_layout Itemize
Data la dimensione massima dell'input, che tipo di algoritmo può essere
 utilizzato (quadratico, lineare, logaritmico, ecc.)?
\end_layout

\begin_layout Itemize
Per produrre i numeri di Fibonacci è meglio utilizzare una funzione ricorsiva
 oppure no?
\end_layout

\begin_layout Itemize
Si può pensare di procedere per forza bruta, provando tutte le possibili
 sequenze di 0 e 1 di dimensione opportuna, fino a trovare quella che da
 come somma il valore richiesto?
\end_layout

\begin_layout Itemize
Guardando come è composta la sequenza dei numeri di Fibonacci, è possibile
 fare qualche osservazione che velocizzi la soluzione?
\end_layout

\begin_layout Subsection
Soluzione
\end_layout

\begin_layout Standard
Inizialmente si può cercare di dare una stima del costo di codifica di un
 numero N, però questa stima non è così semplice, perchè il costo è determinato
 dal costo del calcolo della sequenza di Fibonacci e non è evidente fino
 a che valore di Fibonacci è necessario spingersi per poter calcolare i
 termini della somma che produrrà N.
 Procedendo per tentativi e calcolando i primi termini della sequenza (eventualm
ente scrivendo anche un programmino per visualizzarli) si può pensare che
 i primi 40 termini siano sufficienti per produrre una somma che arriva
 al massimo a un milione, poichè F(40) = 102.334.155.
\end_layout

\begin_layout Standard
A questo punto, se si è utilizzato un programma di test per provare a produrre
 i numeri di Fibonacci, esso può essere utilizzato ad esempio per precalcolare
 i primi 40 termini e poi inserirli direttamente nel codice sotto forma
 di vettore, per non doverli ricalcolare per ogni testcase: sebbene quella
 del precalcolo sia una soluzione che in generale può far risparmiare tempo
 di esecuzione nella soluzione del problema vero e proprio, in questo caso
 non è strettamente necessaria, quindi è lasciata al lettore una sua eventuale
 implementazione.
\end_layout

\begin_layout Standard
Si ricorda comunque che per un calcolo efficiente dei numeri di Fibonacci
 è da evitare assolutamente la versione ricorsiva dell'algoritmo, come spiegato
 
\begin_inset CommandInset ref
LatexCommand vpageref
reference "fibonacci-ricorsivo"

\end_inset

.
\end_layout

\begin_layout Standard
A questo punto, avendo i primi 40 termini della sequenza di Fibonacci, si
 potrebbe pensare di creare tutte le possibili combinazioni di 40 valori
 
\begin_inset Formula $a_{1}a_{2}...a_{40}$
\end_inset

, dove 
\begin_inset Formula $a_{i}$
\end_inset

 può valere 0 o 1 se il termine 
\emph on
i
\emph default
-esimo della sequenza di Fibonacci è presente (1) o non è presente (0) nella
 somma che potrebbe dare N.
 In effetti non è necessario crearle tutte, ma è possibile fermarsi appena
 se ne trova una in cui, sommati i termini corrispondenti ai posti in cui
 
\begin_inset Formula $a_{i}$
\end_inset

 vale 1, si ottiene il numero N cercato.
 Il numero di differenti combinazioni di 40 valori è pari a 
\begin_inset Formula $2^{40}$
\end_inset

, che è un numero decimale dell'ordine di 1000 miliardi: a seconda dei casi
 di test, nonostante sia indubbiamente un valore grosso, potrebbe anche
 portare a fare tutti i punti, poichè una soluzione potrebbe essere trovata
 anche in una fase iniziale della ricerca e inoltre va ricordato che ai
 territoriali il limite di tempo di esecuzione è di 5 minuti
\begin_inset Foot
status collapsed

\begin_layout Plain Layout
Con al nuova modalità che verrà inaugurata alle selezioni 2018 sarebbe addirittu
ra ipoteticamente possibile scrivere un programma nella prima mezz'ora,
 mandarlo in esecuzione sulla propria macchina con il file di test scaricato
 dal server, e sperare che finisca entro le successive due ore e mezza,
 per poi spedire la soluzione al server e nel frattempo proseguire con la
 soluzione degli altri problemi.
\end_layout

\end_inset

.
 
\end_layout

\begin_layout Standard
Si può comunque scrivere una soluzione più efficiente notando che ogni numero
 di Fibonacci 
\begin_inset Quotes eld
\end_inset

contiene
\begin_inset Quotes erd
\end_inset

 solo altri numeri di Fibonacci sommati tra di loro, quindi tra le varie
 soluzioni possibili dello stesso problema N, ne esiste sicuramente una
 che può essere ottenuta aggiungendo in maniera greedy di volta in volta
 il maggiore tra i numeri di Fibonacci minori o uguali di N, ottenendo così
 un sottoproblema 
\begin_inset Formula $N-F_{max}$
\end_inset

, dove 
\begin_inset Formula $F_{max}$
\end_inset

 è appunto il più grande numero di Fibonacci minore o uguale a N.
 Questo fatto lo si può vedere anche nell'esempio che compare nel testo
 relativo a N=9 e come conseguenza la soluzione così trovata è quella con
 il minor numero di termini, che in questo caso non era richiesto, ma che
 viene comunque garantito dall'approccio greedy.
 
\end_layout

\begin_layout Standard
Per finire ci si potrebbe domandare se qualsiasi numero N possa essere costruito
 come somma di alcuni termini della sequenza di Fibonacci e la risposta
 è affermativa, poichè, essendo i primi due termini uguali a 1, per come
 vengono costruiti i successivi termini, si potrà sempre scomporre la somma
 in una serie opportuna di somme di termini unitari per ottenere il valore
 desiderato.
\end_layout

\begin_layout Standard
Il codice che risolve il problema è il seguente:
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "basicstyle={\small\ttfamily},frame=lr,language={C++},numbers=left,showstringspaces=false,tabsize=4"
inline false
status collapsed

\begin_layout Plain Layout

const int MAX = 40;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

int risultato[MAX];
\end_layout

\begin_layout Plain Layout

int numeri_fibonacci[MAX];
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

void inizializza_numeri()
\end_layout

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

	numeri_fibonacci[0] = 1;
\end_layout

\begin_layout Plain Layout

	numeri_fibonacci[1] = 1;
\end_layout

\begin_layout Plain Layout

	for (int i = 2; i < MAX; i++)
\end_layout

\begin_layout Plain Layout

		numeri_fibonacci[i] = numeri_fibonacci[i-1] + numeri_fibonacci[i-2];
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

int calcola_codice(int N)
\end_layout

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

	int i = MAX - 1, lunghezza;
\end_layout

\begin_layout Plain Layout

	std::fill_n(risultato, MAX, 0);
\end_layout

\begin_layout Plain Layout

	while (numeri_fibonacci[i] > N) i--;
\end_layout

\begin_layout Plain Layout

	lunghezza = i;
\end_layout

\begin_layout Plain Layout

	while (N > 0)
\end_layout

\begin_layout Plain Layout

	{
\end_layout

\begin_layout Plain Layout

		if (numeri_fibonacci[i] <= N){
\end_layout

\begin_layout Plain Layout

			N -= numeri_fibonacci[i];
\end_layout

\begin_layout Plain Layout

			risultato[i] = 1;
\end_layout

\begin_layout Plain Layout

		}
\end_layout

\begin_layout Plain Layout

		i--;
\end_layout

\begin_layout Plain Layout

	}
\end_layout

\begin_layout Plain Layout

	return lunghezza;
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

int main()
\end_layout

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

	int T, N;
\end_layout

\begin_layout Plain Layout

	cin >> T;
\end_layout

\begin_layout Plain Layout

	inizializza_numeri();
\end_layout

\begin_layout Plain Layout

	for (int i = 0; i < T; i++)
\end_layout

\begin_layout Plain Layout

	{
\end_layout

\begin_layout Plain Layout

        cin >> N;
\end_layout

\begin_layout Plain Layout

        cout << "Case #" << i+1 << ": ";
\end_layout

\begin_layout Plain Layout

        int lunghezza = calcola_codice(N);
\end_layout

\begin_layout Plain Layout

        for (int i = 0; i <= lunghezza; i++)
\end_layout

\begin_layout Plain Layout

            cout << risultato[i];
\end_layout

\begin_layout Plain Layout

        cout << endl;
\end_layout

\begin_layout Plain Layout

    }
\end_layout

\begin_layout Plain Layout

	return 0;
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Standard
I due vettori 
\emph on
risultati 
\emph default
e 
\emph on
numeri_fibonacci
\emph default
 conterranno rispettivamente la soluzione e i numeri precalcolati della
 sequenza di Fibonacci (il precalcolo viene svolto dalla funzione 
\emph on
inizializza_numeri
\emph default
, righe 6-12).
\end_layout

\begin_layout Standard
La funzione 
\emph on
calcola_codice
\emph default
 implementa la soluzione greedy così come descritta nel testo: inizialmente
 riempie di zeri il vettore dei risultati (riga 17) e questo è fondamentale
 nella nuova modalità di sottoposizione, in cui il programma calcola tante
 soluzioni quanti sono i casi di test contenuti nell'unico file di input
 e quindi ogni volta bisogna garantire che le variabili siano inizializzate
 correttamente.
 Alla riga 18 viene trovato il primo numero di Fibonacci minore o uguale
 alla cifra da codificare, poichè ovviamente numeri più grandi non possono
 fare parte della codifica.
 Il suo indice sarà anche il numero di cifre che comporranno la codifica
 del numero N, che quindi sarà ritornato dalla funzione per stampare successivam
ente la soluzione richiesta.
 Il ciclo 
\series bold
while
\series default
 (righe 20-27) scorre a ritroso la sequenza di Fibonacci e include il numero
 nella codifica solo se è minore della parte di N non ancora codificata,
 segnando anche nel vettore 
\emph on
risultato
\emph default
 un 1 nella posizione corrispondente all'
\emph on
i
\emph default
-esimo numero di Fibonacci incluso nella codifica.
\end_layout

\begin_layout Standard
A questo punto nel 
\emph on
main
\emph default
 è necessario leggere il numero di casi di test, cosa che viene fatta alla
 riga 34, e ripetere la chiamata alla funzione 
\emph on
calcola_codice
\emph default
 per ogni caso di test, stampando il numero del caso di test (riga 39) e
 la soluzione (righe 41-42).
\end_layout

\begin_layout Section
Sport intellettuali - Territoriali 2017
\end_layout

\begin_layout Standard
\begin_inset Box Framed
position "t"
hor_pos "c"
has_inner_box 0
inner_pos "t"
use_parbox 0
use_makebox 0
width "100col%"
special "none"
height "1in"
height_special "totalheight"
thickness "0.4pt"
separation "3pt"
shadowsize "4pt"
framecolor "black"
backgroundcolor "none"
status open

\begin_layout Subsection*
Sport intellettuali (scommessa)
\end_layout

\begin_layout Subsubsection*
Difficoltà: 2
\end_layout

\begin_layout Subsubsection*
\noindent
Descrizione del problema
\end_layout

\begin_layout Plain Layout
Romeo è un grande appassionato di sport intellettuali, e adora ritrovarsi
 con gli amici per seguire le competizioni internazionali più avvincenti
 di questo tipo.
 Di recente, il gruppo di amici si è appassionato a uno sport molto particolare.
 In questo gioco, un mazzo di carte numerate da 0 a N −1 (dove N è dispari)
 viene prima mescolato, e poi le carte vengono affiancate in linea retta
 sul tavolo.
 Ai telespettatori, per aumentare la suspence, vengono mostrati i numeri
 delle carte 
\begin_inset Formula $C_{0},C_{1},\ldots,C_{i},\ldots,C_{N-1}$
\end_inset

 nell’ordine così ottenuto.
 A questo punto i giocatori
\begin_inset script superscript

\begin_layout Plain Layout
1
\end_layout

\end_inset

 possono scoprire due carte disposte consecutivamente sul tavolo, e prenderle
 nel solo caso in cui queste due carte abbiano somma dispari.
 Se queste carte vengono prese, le altre vengono aggiustate quanto basta
 per riempire il buco lasciato libero.
 Il gioco prosegue quindi a questo modo finché nessun giocatore può più
 prendere carte.
 Romeo e i suoi amici, per sentirsi più partecipi, hanno oggi deciso di
 fare un “gioco nel gioco”: all’inizio della partita, scommettono su quali
 carte pensano rimarranno sul tavolo una volta finita la partita.
 Aiuta Romeo, determinando quali carte potrebbero rimanere sul tavolo alla
 fine del gioco!
\end_layout

\begin_layout Plain Layout
\begin_inset VSpace medskip
\end_inset


\end_layout

\begin_layout Plain Layout
\align center
\begin_inset Box Doublebox
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 1
use_makebox 0
width "90col%"
special "none"
height "1in"
height_special "totalheight"
thickness "0.4pt"
separation "3pt"
shadowsize "4pt"
framecolor "black"
backgroundcolor "none"
status open

\begin_layout Plain Layout
Una carta potrebbe rimanere sul tavolo a fine gioco, se esiste una sequenza
 di mosse (rimozioni di coppie di carte consecutive con somma dispari) tale
 per cui dopo di esse nessuna altra mossa è possibile (il gioco e finito)
 e la carta suddetta è ancora sul tavolo.
\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection*
Dati di input
\end_layout

\begin_layout Plain Layout
La prima riga del file di input contiene un intero 
\series bold
T
\series default
, il numero di testcase.
 Seguono 
\series bold
T
\series default
 testcase, ognuno dei quali composto da due righe:
\end_layout

\begin_layout Itemize
Riga 1: l'unico intero 
\series bold
N
\series default
.
 
\end_layout

\begin_layout Itemize
Riga 2: gli 
\series bold
N
\series default
 interi 
\series bold

\begin_inset Formula $C_{i}$
\end_inset


\series default
 separati da spazio, nell'ordine in cui sono disposti sul tavolo.
\end_layout

\begin_layout Subsubsection*
Dati di output
\end_layout

\begin_layout Plain Layout
Il file di output deve essere composto da tre righe per ciascun testcase:
\end_layout

\begin_layout Itemize
Riga 1: la dicitura 
\series bold
Case #x:
\series default
 dove 
\series bold
x
\series default
 è il numero del testcase (a partire da 1).
 
\end_layout

\begin_layout Itemize
Riga 2: il numero di diverse carte 
\series bold
K
\series default
 che potrebbero rimanere sul tavolo a fine partita.
 
\end_layout

\begin_layout Itemize
Riga 3: i 
\series bold
K
\series default
 interi che identificano le carte che potrebbero rimanere sul tavolo a fine
 partita.
\end_layout

\begin_layout Subsubsection*
Assunzioni
\end_layout

\begin_layout Itemize
1≤T≤10.
 
\end_layout

\begin_layout Itemize
1≤N≤100.
 
\end_layout

\begin_layout Itemize
N è sempre un numero dispari.
 
\end_layout

\begin_layout Itemize
0≤
\series bold

\begin_inset Formula $C_{i}$
\end_inset


\series default
​​≤N−1 per ogni i=0...N−1.
 
\end_layout

\begin_layout Itemize
Ogni numero tra 0 e N−1 compare esattamente una volta nella sequenza dei
 
\series bold

\begin_inset Formula $C_{i}$
\end_inset


\series default
​​.
\end_layout

\begin_layout Plain Layout
\begin_inset Tabular
<lyxtabular version="3" rows="2" columns="2">
<features tabularvalignment="middle">
<column alignment="left" valignment="top" width="2.5in">
<column alignment="left" valignment="top" width="5cm">
<row>
<cell alignment="left" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
File input.txt
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
File output.txt
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
2 
\end_layout

\begin_layout Plain Layout

\family typewriter
3 
\end_layout

\begin_layout Plain Layout

\family typewriter
1 2 0 
\end_layout

\begin_layout Plain Layout

\family typewriter
11 
\end_layout

\begin_layout Plain Layout

\family typewriter
1 0 2 6 4 5 3 9 8 10 7
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
Case #1: 
\end_layout

\begin_layout Plain Layout

\family typewriter
1 
\end_layout

\begin_layout Plain Layout

\family typewriter
0 
\end_layout

\begin_layout Plain Layout

\family typewriter
Case #2: 
\end_layout

\begin_layout Plain Layout

\family typewriter
2 
\end_layout

\begin_layout Plain Layout

\family typewriter
8
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset VSpace medskip
\end_inset


\end_layout

\begin_layout Plain Layout

\size footnotesize
1.
 Seguendo un elaborato ordine di gioco che non rientra nei margini di questo
 problema.
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Suggerimenti
\end_layout

\begin_layout Itemize
Quanto costa provare ad abbinare in vari modi tutti i numeri della sequenza
 per vedere chi rimane? Quanto è complicato da scrivere?
\end_layout

\begin_layout Itemize
Il fatto che i numeri siano in quantità dispari e che siano esattamente
 i primi N-1 numeri naturali (0 compreso), quali tipi di considerazioni
 solleva?
\end_layout

\begin_layout Itemize
Provando su un foglio di carta il secondo esempio, quali caratteristiche
 condividono il numero 2 e il numero 8 che non hanno gli altri numeri della
 sequenza? 
\end_layout

\begin_layout Itemize
Se un numero 
\begin_inset Formula $C_{i}$
\end_inset

 può rimanere sulla tavola, che caratteristiche deve avere la sottosequenza
 di sinistra 
\begin_inset Formula $C_{0}\ldots C_{i-1}$
\end_inset

 e quella di destra 
\begin_inset Formula $C_{i+1}\ldots C_{N-1}$
\end_inset

?
\end_layout

\begin_layout Subsection
Soluzione
\end_layout

\begin_layout Standard
Una prima idea che potrebbe venire, considerato che il numero di carte è
 al massimo 99, è quella di provare tutti i modi possibili di eliminare
 coppie di carte e vedere di volta in volta quale carta rimane in tavola.
 Questo approccio però, oltre a non essere di semplice implementazione,
 è sicuramente molto oneroso da un punto di vista computazionale: senza
 entrare troppo nel dettaglio, il numero di modi con cui possono essere
 estratte le coppie sono decisamente troppi, in quanto per ogni valore di
 N ci sono al massimo N-1 coppie che possono essere estratte, scegliendone
 poi una per iniziare, ne rimangono (N-2) - 1 e continuando così si arriva
 a una complessità che alla peggio è di tipo 
\begin_inset Formula $O(N!)$
\end_inset

.
 
\end_layout

\begin_layout Standard
Come in altri casi, un'attenta analisi degli esempi e delle assunzioni permette
 invece di individuare un algoritmo 
\emph on
ad-hoc
\emph default
 di complessità lineare, che permette di risolvere tutti i casi di test.
\end_layout

\begin_layout Standard
Il fatto che i numeri siano in quantità dispari e che siano compresi tra
 0 e N-1, con ogni numero che compare una e una sola volta, permette di
 derivare che nell'insieme ci saranno sempre (N-1)/2 + 1 numeri pari e (N-1)/2
 numeri dispari.
 Questo garantisce che, qualunque sia l'ordine con cui verranno estratte
 le coppie, rimarrà sempre un numero sul tavolo e che questo sarà per forza
 un numero pari.
 Inoltre un numero 
\begin_inset Formula $C_{i}$
\end_inset

 potrà rimanere 
\series bold
se e solo se
\series default
 sia alla sua destra che alla sua sinistra ci saranno la stessa quantità
 di numeri pari e dispari.
 Difatti se questo non fosse vero, eliminando via via le coppie si arriverebbe
 a una situazione in cui da una parte e dall'altra rimarrebbero numeri non
 più accoppiabili e quindi sarebbe necessario usare il numero 
\begin_inset Formula $C_{i}$
\end_inset

 per continuare a formare coppie, che, come detto nele ipotesi, è sempre
 possibile formare fino a quando non rimane un numero solo.
 Per verificarlo basta vedere figura 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:Controesempio-di-carta"

\end_inset

, in cui ci si domanda se il numero 4 potrà rimanere sul tavolo.
 Come si vede la quantità di numeri pari a sinistra è 3 mentre i numeri
 dispari sono 1, laddove i numeri pari alla sua destra sono 2 e i numeri
 dispari sono 4.
 Eliminando le coppie in figura, evidenziate con le freccie che le uniscono,
 rimangono a sinistra due pari (il 2 e il 6) e a destra due dispari (il
 5 e il 7) e quindi il 4 dovrà essere messo insieme al 5 e non potrà rimanere
 come ultima carta (è facile notare che le coppie scelte, che avrebbero
 anche potuto essere differenti, non influenzano il risultato finale).
 Provando con qualsiasi altro numero pari in questo esempio si nota che
 solo il 2 e l'8, che soddisfano la condizione richiesta, hanno la possibilità
 di rimanere sul tavolo una volta tolte tutte le coppie possibili.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename ../materiali/problemi territoriali/2017_scommessa/esempio.eps
	scale 70

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:Controesempio-di-carta"

\end_inset

Controesempio di carta rimasta
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Quindi il problema si riduce, scelto un certo elemento 
\begin_inset Formula $C_{i}$
\end_inset

, a stabilire quanti elementi pari e dispari si trovano alla sua sinistra
 e verificare se soddisfano la condizione richiesta, risolvendo così il
 problema con un algoritmo di complessità lineare.
 Si può notare che è sufficiente contare gli elementi alla sinistra di 
\begin_inset Formula $C_{i}$
\end_inset

, perchè se viene soddisfatta la condizione su quegli elementi è per forza
 soddisfatta anche per quelli alla sua destra.
\end_layout

\begin_layout Standard
La soluzione potrebbe essere quindi implementata in questo modo:
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "basicstyle={\small\ttfamily},frame=lr,language={C++},numbers=left,showstringspaces=false,tabsize=4"
inline false
status collapsed

\begin_layout Plain Layout

int main()
\end_layout

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

	int T, N;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

	ifstream in("input.txt");
\end_layout

\begin_layout Plain Layout

	ofstream out("output.txt");
\end_layout

\begin_layout Plain Layout

	in >> T;
\end_layout

\begin_layout Plain Layout

	for (int k = 0; k < T; k++)
\end_layout

\begin_layout Plain Layout

	{
\end_layout

\begin_layout Plain Layout

		vector <int> esclusi;
\end_layout

\begin_layout Plain Layout

		in >> N;
\end_layout

\begin_layout Plain Layout

		int pari = 0, dispari = 0;
\end_layout

\begin_layout Plain Layout

		for (int i = 0; i < N; i++)
\end_layout

\begin_layout Plain Layout

		{
\end_layout

\begin_layout Plain Layout

			int n;
\end_layout

\begin_layout Plain Layout

			in >> n;
\end_layout

\begin_layout Plain Layout

			if (n%2 == 0 && pari == dispari)
\end_layout

\begin_layout Plain Layout

				esclusi.push_back(n);
\end_layout

\begin_layout Plain Layout

			if (n%2 == 0)
\end_layout

\begin_layout Plain Layout

				pari++;
\end_layout

\begin_layout Plain Layout

			else
\end_layout

\begin_layout Plain Layout

				dispari++;
\end_layout

\begin_layout Plain Layout

		}
\end_layout

\begin_layout Plain Layout

		out << "Case #" << k+1 << ":" << endl;
\end_layout

\begin_layout Plain Layout

		out << esclusi.size() << endl;
\end_layout

\begin_layout Plain Layout

		for (auto i: esclusi)
\end_layout

\begin_layout Plain Layout

			out << i << " ";
\end_layout

\begin_layout Plain Layout

		out << endl;
\end_layout

\begin_layout Plain Layout

	}
\end_layout

\begin_layout Plain Layout

	return 0;
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Come si vede nel codice, per ogni caso di test (ciclo alla riga 8), viene
 letto il numero di carte che verranno usate nella partita e si inizializzano
 la quantità di numeri pari e dispari alla sinistra della posizione corrente
 a 0 (riga 12).
 Successivamente si leggono i valori delle N carte e per ognuno si verifica
 se vengono soddisfatte le condizioni perchè la carta rimanga come ultima
 carta sul tavolo (riga 17, il valore deve essere pari e le quantità di
 numeri pari e dispari alla sinistra del numero appena letto devono essere
 uguali).
 Se la condizione è soddisfatta allora il numero viene inserito nel vettore
 
\emph on
esclusi
\emph default
 e poi viene aggiornato il valore degli elementi pari a dispari alla sinistra
 del prossimo numero da analizzare.
\end_layout

\begin_layout Standard
Dopo aver letto tutti i numeri che compongono il caso di test non rimane
 altro da fare che stampare i numeri memorizzati all'interno del vettore
 
\emph on
esclusi
\emph default
 (righe 24-28).
\end_layout

\begin_layout Section
Appetito aracnide - Territoriali 2017
\end_layout

\begin_layout Standard
\begin_inset Box Framed
position "t"
hor_pos "c"
has_inner_box 0
inner_pos "t"
use_parbox 0
use_makebox 0
width "100col%"
special "none"
height "1in"
height_special "totalheight"
thickness "0.4pt"
separation "3pt"
shadowsize "4pt"
framecolor "black"
backgroundcolor "none"
status collapsed

\begin_layout Subsection*
Appetito aracnide (tecla)
\end_layout

\begin_layout Subsubsection*
Difficoltà: 2
\end_layout

\begin_layout Subsubsection*
\noindent
Descrizione del problema
\end_layout

\begin_layout Plain Layout
Ape Maya è rimasta intrappolata in un nodo della tela di Tecla, un ragno
 molto temuto tra le api dell’alveare.
 Tecla si affretta ad afferrarla ma, quando giunge su quel nodo, si accorge
 di non avere appetito, e dice “BLEAH”.
 Va detto che l’appetito dei ragni è molto particolare: ogni volta che percorron
o un filamento della loro rete, essi invertono lo stato del loro stomaco
 tra “SLURP” e “BLEAH”.
 Tecla deve quindi farsi un giretto nella rete sperando di tornare da Maya
 in stato “SLURP”.
\end_layout

\begin_layout Plain Layout
La tela di Tecla è composta da 
\emph on
N
\emph default
 nodi (numerati da 
\emph on
0
\emph default
 a 
\emph on
N - 1
\emph default
) connessi tra loro da 
\emph on
M
\emph default
 filamenti.
 Tecla e Ape Maya all’inizio si trovano entrambe nel nodo 
\emph on
0
\emph default
, e ogni filamento può essere attraversato da Tecla in entrambe le direzioni.
 Aiuta Tecla ad individuare una passeggiata funzionale al buon appetito!
\end_layout

\begin_layout Subsubsection*
Dati di input
\end_layout

\begin_layout Plain Layout
La prima riga del file di input contiene un intero 
\series bold
T
\series default
, il numero di testcase.
 Seguono 
\series bold
T
\series default
 testcase, ognuno dei quali composto da 
\series bold
M+1
\series default
 righe:
\end_layout

\begin_layout Itemize
Riga 1: gli interi 
\series bold
N
\series default
 ed 
\series bold
M
\series default
, il numero di nodi e di filamenti della tela..
 
\end_layout

\begin_layout Itemize
Righe 2…
\series bold
M+1
\series default
: due interi separati da spazio 
\emph on
u, v
\emph default
, dove 
\emph on
u
\emph default
 e 
\emph on
v
\emph default
 identificano i due nodi ai capi del filamento 
\emph on
i
\emph default
-esimo.
\end_layout

\begin_layout Subsubsection*
Dati di output
\end_layout

\begin_layout Plain Layout
Il file di output deve essere composto da tre righe per ciascun testcase:
\end_layout

\begin_layout Itemize
Riga 1: la dicitura 
\series bold
Case #x:
\series default
 dove 
\series bold
x
\series default
 è il numero del testcase (a partire da 1).
 
\end_layout

\begin_layout Itemize
Riga 2: il numero di spostamenti 
\series bold
L
\series default
 che Tecla deve compiere nella sua passeggiata.
\end_layout

\begin_layout Itemize
Riga 3: 
\series bold
L+1
\series default
 numeri separati da uno spazio, di cui il primo e l’ultimo devono essere
 0 (nodo di partenza e di arrivo), e gli altri sono i nodi come visitati
 da Tecla nell’ordine (e possono avere ripetizioni).
\end_layout

\begin_layout Subsubsection*
Assunzioni
\end_layout

\begin_layout Itemize
1≤T≤50.
\end_layout

\begin_layout Itemize
1≤N≤30.
\end_layout

\begin_layout Itemize
1≤M≤100.
 
\end_layout

\begin_layout Itemize
In ogni filamento, 
\emph on
u≠v
\emph default
 e sono entrambi compresi tra 0 e N - 1.
\end_layout

\begin_layout Itemize
Si garantisce l’esistenza di una soluzione: Ape Maya è spacciata!
\end_layout

\begin_layout Plain Layout
\begin_inset Tabular
<lyxtabular version="3" rows="2" columns="2">
<features tabularvalignment="middle">
<column alignment="left" valignment="top" width="2.5in">
<column alignment="left" valignment="top" width="5cm">
<row>
<cell alignment="left" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
File input.txt
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
File output.txt
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
2 
\end_layout

\begin_layout Plain Layout

\family typewriter
3 3 
\end_layout

\begin_layout Plain Layout

\family typewriter
0 1 
\end_layout

\begin_layout Plain Layout

\family typewriter
1 2 
\end_layout

\begin_layout Plain Layout

\family typewriter
2 0 
\end_layout

\begin_layout Plain Layout

\family typewriter
8 12 
\end_layout

\begin_layout Plain Layout

\family typewriter
0 1 
\end_layout

\begin_layout Plain Layout

\family typewriter
1 2 
\end_layout

\begin_layout Plain Layout

\family typewriter
2 3 
\end_layout

\begin_layout Plain Layout

\family typewriter
3 0 
\end_layout

\begin_layout Plain Layout

\family typewriter
2 4 
\end_layout

\begin_layout Plain Layout

\family typewriter
3 4 
\end_layout

\begin_layout Plain Layout

\family typewriter
4 5 
\end_layout

\begin_layout Plain Layout

\family typewriter
5 6 
\end_layout

\begin_layout Plain Layout

\family typewriter
6 7 
\end_layout

\begin_layout Plain Layout

\family typewriter
7 0 
\end_layout

\begin_layout Plain Layout

\family typewriter
0 5 
\end_layout

\begin_layout Plain Layout

\family typewriter
6 3
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
Case #1: 
\end_layout

\begin_layout Plain Layout

\family typewriter
3 
\end_layout

\begin_layout Plain Layout

\family typewriter
0 2 1 0
\end_layout

\begin_layout Plain Layout

\family typewriter
Case #2: 
\end_layout

\begin_layout Plain Layout

\family typewriter
7 
\end_layout

\begin_layout Plain Layout

\family typewriter
0 5 6 3 4 2 3 0 
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Subsubsection*
Spiegazione
\end_layout

\begin_layout Plain Layout
Nel 
\series bold
primo caso di esempio
\series default
, la tela di Tecla è come nella figura seguente, dove il percorso da seguire
 è evidenziato in rosso (con le frecce per stampa in B/N):
\end_layout

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename ../materiali/problemi territoriali/2017_tecla/esempio_1_testo.png
	lyxscale 25
	scale 25

\end_inset


\end_layout

\begin_layout Plain Layout
Nel 
\series bold
secondo caso di esempio
\series default
, la tela e il percorso sono:
\end_layout

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename ../materiali/problemi territoriali/2017_tecla/esempio_2_testo.png
	lyxscale 25
	scale 25

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Suggerimenti
\end_layout

\begin_layout Itemize
Sembra evidente che il problema riguardi i grafi, in particolare quale algoritmo
 sembra appropriato per risolverlo (visite, cammino minimo, altro)?
\end_layout

\begin_layout Itemize
Rispetto a un percorso 
\begin_inset Quotes eld
\end_inset

standard
\begin_inset Quotes erd
\end_inset

, in cui ogni nodo viene attraversato una volta sola, quante volte può essere
 attraversato un nodo appartenente alla soluzione (esattamente una, più
 di una, al massimo ....)?
\end_layout

\begin_layout Itemize
Lo stato di Tecla è un'informazione che riguarda solo Tecla oppure in qualche
 modo deve essere memorizzata anche nel grafo?
\end_layout

\begin_layout Subsection
Soluzione
\end_layout

\begin_layout Standard
Per arrivare alla soluzione si può partire da un paio di osservazioni:
\end_layout

\begin_layout Itemize
usando una visita in profondità si può costruire un percorso chiuso, con
 qualche modifica alla normale visita in cui ogni nodo viene visitato una
 volta sola
\end_layout

\begin_layout Itemize
un nodo può essere attraversato al massimo due volte, in particolare viene
 visitato un nodo se:
\begin_inset Separator latexpar
\end_inset


\end_layout

\begin_deeper
\begin_layout Itemize
non è mai stato visto prima
\end_layout

\begin_layout Itemize
è stato visto prima, ma ripassandoci lo stato di Tecla cambia rispetto alla
 visita precedente.
 Chiaramente passare per un nodo una terza volta porterebbe per forza Tecla
 in uno stato con cui aveva già effettuato la visita in precedenza, quindi
 in una situazione indistinguibile dalla precedente e come conseguenza porterebb
e a una ricorsione infinita.
\end_layout

\end_deeper
\begin_layout Standard
Da queste due osservazioni segue che utilizzando una visita in profondità
 con backtracking e applicando le considerazioni sopra esposte verrà trovata
 una soluzione (che è garantito esserci).
 Il backtracking è necessario perchè, come detto, bisogna provare più percorsi
 e quindi lo stesso nodo può essere riutilizzato all'interno di percorsi
 diversi.
 L'implementazione scelta è quella ricorsiva, per la semplicità di scrittura.
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "basicstyle={\small\ttfamily},frame=lr,language={C++},numbers=left,showstringspaces=false,tabsize=4"
inline false
status collapsed

\begin_layout Plain Layout

enum tipo{BLEAH,SLURP};
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

struct Nodo{
\end_layout

\begin_layout Plain Layout

    list <int> nodi_collegati;
\end_layout

\begin_layout Plain Layout

    int tipo;
\end_layout

\begin_layout Plain Layout

    int passaggi = 0;
\end_layout

\begin_layout Plain Layout

};
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

Nodo nodi[30];
\end_layout

\begin_layout Plain Layout

list<int> soluzione;
\end_layout

\begin_layout Plain Layout

bool finito;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

void inizializza()
\end_layout

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

    soluzione.clear();
\end_layout

\begin_layout Plain Layout

    finito = false;
\end_layout

\begin_layout Plain Layout

    soluzione.push_back(0);
\end_layout

\begin_layout Plain Layout

    for (int i = 0; i < 30; i++)
\end_layout

\begin_layout Plain Layout

    {
\end_layout

\begin_layout Plain Layout

        nodi[i].passaggi = 0;
\end_layout

\begin_layout Plain Layout

        nodi[i].nodi_collegati.clear();
\end_layout

\begin_layout Plain Layout

    }
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

void naviga(int i)
\end_layout

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

    for (auto n: nodi[i].nodi_collegati)
\end_layout

\begin_layout Plain Layout

    {
\end_layout

\begin_layout Plain Layout

        if (nodi[n].passaggi == 0 || 
\end_layout

\begin_layout Plain Layout

			(nodi[n].passaggi == 1 && nodi[i].tipo == nodi[n].tipo))
\end_layout

\begin_layout Plain Layout

        {
\end_layout

\begin_layout Plain Layout

            if (n == 0 && nodi[i].tipo == BLEAH)
\end_layout

\begin_layout Plain Layout

            {
\end_layout

\begin_layout Plain Layout

                finito = true;
\end_layout

\begin_layout Plain Layout

                return;
\end_layout

\begin_layout Plain Layout

            }
\end_layout

\begin_layout Plain Layout

            soluzione.push_back(n);
\end_layout

\begin_layout Plain Layout

            nodi[n].passaggi++;
\end_layout

\begin_layout Plain Layout

            if (nodi[i].tipo == BLEAH)
\end_layout

\begin_layout Plain Layout

                nodi[n].tipo = SLURP;
\end_layout

\begin_layout Plain Layout

            else
\end_layout

\begin_layout Plain Layout

                nodi[n].tipo = BLEAH;
\end_layout

\begin_layout Plain Layout

            naviga(n);
\end_layout

\begin_layout Plain Layout

            if (finito) return;
\end_layout

\begin_layout Plain Layout

            soluzione.pop_back();
\end_layout

\begin_layout Plain Layout

            nodi[n].passaggi--;
\end_layout

\begin_layout Plain Layout

            if (nodi[n].tipo == BLEAH)
\end_layout

\begin_layout Plain Layout

                nodi[n].tipo = SLURP;
\end_layout

\begin_layout Plain Layout

            else
\end_layout

\begin_layout Plain Layout

                nodi[n].tipo = BLEAH;
\end_layout

\begin_layout Plain Layout

        }
\end_layout

\begin_layout Plain Layout

    }
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

int main()
\end_layout

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

	int T, N;
\end_layout

\begin_layout Plain Layout

	ifstream in("input.txt");
\end_layout

\begin_layout Plain Layout

	ofstream out("output.txt");
\end_layout

\begin_layout Plain Layout

	in >> T;
\end_layout

\begin_layout Plain Layout

	for (int k = 0; k < T; k++)
\end_layout

\begin_layout Plain Layout

	{
\end_layout

\begin_layout Plain Layout

        int N, M;
\end_layout

\begin_layout Plain Layout

        inizializza();
\end_layout

\begin_layout Plain Layout

        in >> N >> M;
\end_layout

\begin_layout Plain Layout

        out << "Case #" << k+1 << ":" << endl;
\end_layout

\begin_layout Plain Layout

        for (int i = 0; i < M; i++)
\end_layout

\begin_layout Plain Layout

        {
\end_layout

\begin_layout Plain Layout

            int parte, arriva;
\end_layout

\begin_layout Plain Layout

            in >> parte >> arriva;
\end_layout

\begin_layout Plain Layout

            nodi[parte].nodi_collegati.push_back(arriva);
\end_layout

\begin_layout Plain Layout

            nodi[arriva].nodi_collegati.push_back(parte);
\end_layout

\begin_layout Plain Layout

        }
\end_layout

\begin_layout Plain Layout

        naviga(0);
\end_layout

\begin_layout Plain Layout

        out << soluzione.size() << endl;
\end_layout

\begin_layout Plain Layout

        for (auto i: soluzione)
\end_layout

\begin_layout Plain Layout

            out << i << " ";
\end_layout

\begin_layout Plain Layout

        out << "0" << endl;
\end_layout

\begin_layout Plain Layout

	}
\end_layout

\begin_layout Plain Layout

	return 0;
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Il nodo in questo programma viene definito, oltre che dalla solita lista
 dei nodi collegati (riga 4), anche dal 
\emph on
tipo
\emph default
, che rappresenta lo stato che aveva Tecla l'ultima volta che è passata
 in quel nodo (BLEAH o SLURP), e dal numero di 
\emph on
passaggi
\emph default
, che saranno 0 se il nodo non è mai stato visitato, 1 se è stato visitato
 solo una volta e 2 se Tecla è passata due volte: come detto in precedenza
 questo valore non sarà mai maggiore di 2.
\end_layout

\begin_layout Standard
Il grafo sarà quindi rappresentato da un vettore di nodi (riga 9), la soluzione
 sarà la lista di interi che rappresenta i nodi ordinati attraverso cui
 deve passare Tecla (riga 10) e inoltre si farà uso della variabile booleana
 
\emph on
finito
\emph default
 (riga 11), che, come si vedrà, verrà utilizzata all'interno della funzione
 ricorsiva per terminare la ricerca una volta trovata una soluzione.
\end_layout

\begin_layout Standard
La funzione 
\emph on
inizializza
\emph default
 (riga 13 e seguenti) ha il solo scopo di 
\begin_inset Quotes eld
\end_inset

pulire
\begin_inset Quotes erd
\end_inset

 le varie strutture dati utilizzate, sempre per il motivo che, avendo nel
 file di input più casi di test, ogni volta si calcola la soluzione bisogna
 reinizializzare tutte le variabili necessarie al funzionamento dell'algoritmo
 risolutivo.
\end_layout

\begin_layout Standard
Il nocciolo della soluzione si trova all'interno della funzione ricorsiva
 
\emph on
naviga
\emph default
 (riga 25), che come unico parametro utilizza il nodo che andrà a visitare.
 Data quindi la visita del nodo 
\emph on
i
\emph default
-esimo, vengono iterati con un 
\series bold
for
\series default
 (riga 27) tutti i nodi ad esso collegati e, tramite l'
\series bold
if
\series default
 successivo, si procede con la visita se:
\end_layout

\begin_layout Itemize
il nodo non è mai stato visitato prima da Tecla (riga 29), oppure
\end_layout

\begin_layout Itemize
il nodo è già stato visitato una volta in precedenza, ma la nuova visita
 porta Tecla in uno stato diverso da quello in cui era entrata precedentemente
 (riga 30)
\end_layout

\begin_layout Standard
Il primo 
\series bold
if
\series default
 controlla quindi se si è arrivati alla soluzione, cioè se il nodo che si
 sta andando a visitare sarà il nodo 0 e se si entrerà con Tecla in stato
 SLURP (quindi la condizione è che nel nodo corrente 
\emph on
i
\emph default
-esimo lei sia nello stato BLEAH).
 Nel caso questa condizione sia verificata si va ad impostare a 
\emph on
true
\emph default
 il flag 
\emph on
finito
\emph default
 e si esce dalla chiamata ricorsiva corrente.
\end_layout

\begin_layout Standard
Altrimenti si prosegue con la ricorsione, andando a inserire il nodo che
 si andrà a visitare nella ipotetica soluzione e andando a settare i suoi
 parametri, cioè il tipo e il numero di passaggi, nelle righe dalla 37 alla
 42.
 Alla riga 43 viene avviata la ricorsione sul nuovo nodo e nelle righe successiv
e, a cui si ritornerà una volta finita la visita ricorsiva del nodo 
\emph on
n
\emph default
, viene 
\begin_inset Quotes eld
\end_inset

smontato
\begin_inset Quotes erd
\end_inset

 lo stato del nodo 
\emph on
n
\emph default
 per riportarlo alla situazione precedente alla visita (quindi viene fatto
 
\emph on
backtracking
\emph default
).
 Da notare l'
\series bold
if
\series default
 alla riga 44 che, controllando il flag 
\emph on
finito
\emph default
, interrompe la ricorsione evitando che la lista che contiene la soluzione
 venga svuotata come conseguenza della terminazione della ricorsione.
\end_layout

\begin_layout Standard
Infine il 
\emph on
main
\emph default
 si occuperà solo della lettura dei dati, inserendo gli archi, che non sono
 orientati, sia nel nodo di partenza che in quello di arrivo (righe 71-72),
 chiamando la funzione ricorsiva sul nodo 0 e successivamente stampando
 il contenuto della lista 
\emph on
soluzione
\emph default
, che, come visto, verrà riempita dalla funzione 
\emph on
naviga
\emph default
.
\end_layout

\begin_layout Section
Festa canina - Territoriali 2018
\end_layout

\begin_layout Standard
\begin_inset Box Framed
position "t"
hor_pos "c"
has_inner_box 0
inner_pos "t"
use_parbox 0
use_makebox 0
width "100col%"
special "none"
height "1in"
height_special "totalheight"
thickness "0.4pt"
separation "3pt"
shadowsize "4pt"
framecolor "black"
backgroundcolor "none"
status open

\begin_layout Subsection*
Festa canina (party)
\end_layout

\begin_layout Subsubsection*
Punteggio massimo: 6
\end_layout

\begin_layout Subsubsection*
\noindent
Descrizione del problema
\end_layout

\begin_layout Plain Layout
Mojito, il cane di Monica, vuole organizzare una festa con i suoi amici.
 Aiutalo a scegliere quali invitare e quali escludere in modo da rendere
 la festa più bella possibile.
 Mojito ha 
\series bold
N
\series default
 amici, ognuno dei quali ha un grado di amicizia 
\series bold
A
\begin_inset script subscript

\begin_layout Plain Layout

\series bold
i
\end_layout

\end_inset


\series default
 che indica quanto Mojito apprezzi la sua presenza.
 Ovviamente nella lista c'è anche qualche antipatico che quindi ha un grado
 di amicizia negativo.
\end_layout

\begin_layout Plain Layout
La bellezza della festa è definita come la somma del grado di amicizia degli
 invitati.
 Quanto può valere al massimo questa somma?
\end_layout

\begin_layout Subsubsection*
Dati di input
\end_layout

\begin_layout Plain Layout
La prima riga del file di input contiene un intero 
\series bold
T
\series default
, il numero di casi di test.
 Seguono 
\series bold
T
\series default
 casi di test, numerati da 1 a 
\series bold
T
\series default
.
 Ogni caso di test è preceduto da una riga vuota.
 In ciascun caso di test, la prima riga contiene l'unico intero 
\series bold
N
\series default
.
 La seconda riga contiene gli 
\series bold
N
\series default
 interi separati da spazi, 
\series bold
A
\begin_inset script subscript

\begin_layout Plain Layout

\series bold
i
\end_layout

\end_inset


\series default
.
\end_layout

\begin_layout Subsubsection*
Dati di output
\end_layout

\begin_layout Plain Layout
Il file di output deve contenere la risposta ai casi di test che sei riuscito
 a risolvere.
 Per ogni caso di test che hai risolto, il file di output deve contenere
 una riga con la dicitura: 
\end_layout

\begin_layout Verbatim

Case #t: k 
\end_layout

\begin_layout Plain Layout
dove 
\series bold
t
\series default
 è il numero del caso di test (a partire da 1) e 
\series bold
k
\series default
 è il massimo valore di bellezza ottenibile.
\end_layout

\begin_layout Subsubsection*
Assunzioni
\end_layout

\begin_layout Itemize
T=6, sono presenti 6 casi di input (nell'esempio per brevità ne sono mostrati
 solo 2)
\end_layout

\begin_layout Itemize
1≤N≤10.000, il numero di amici di Mojito.
\end_layout

\begin_layout Itemize
−100≤A
\begin_inset script subscript

\begin_layout Plain Layout
i
\end_layout

\end_inset

 ≤100, il grado di amicizia dell'i-esimo amico.
\end_layout

\begin_layout Itemize
È anche possibile che Mojito festeggi senza amici, in tal caso la festa
 ha valore 0.
\end_layout

\begin_layout Plain Layout
\begin_inset Tabular
<lyxtabular version="3" rows="2" columns="2">
<features tabularvalignment="middle">
<column alignment="left" valignment="top" width="2.5in">
<column alignment="left" valignment="top" width="5cm">
<row>
<cell alignment="left" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
File input.txt
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
File output.txt
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
2 
\end_layout

\begin_layout Plain Layout
\begin_inset VSpace defskip
\end_inset


\end_layout

\begin_layout Plain Layout

\family typewriter
8 
\end_layout

\begin_layout Plain Layout

\family typewriter
1 -4 5 -2 -1 8 0 1 
\end_layout

\begin_layout Plain Layout
\begin_inset VSpace defskip
\end_inset


\end_layout

\begin_layout Plain Layout

\family typewriter
3 
\end_layout

\begin_layout Plain Layout

\family typewriter
-1 -2 -4 
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
Case #1: 15
\end_layout

\begin_layout Plain Layout

\family typewriter
Case #2: 0
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Subsubsection*
Spiegazione
\end_layout

\begin_layout Plain Layout
Nel 
\series bold
primo caso d'esempio
\series default
 la soluzione si ottiene invitando il primo, il terzo, il sesto, il settimo
 e l'ottavo amico, totalizzando una somma di 15.
 
\end_layout

\begin_layout Plain Layout
Nel 
\series bold
secondo caso d'esempio
\series default
 la soluzione si ottiene non invitando alcun amico, totalizzando quindi
 0.
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Suggerimenti
\end_layout

\begin_layout Itemize
Gli antipatici potranno mai rendere una festa più bella?
\end_layout

\begin_layout Subsection
Soluzione
\end_layout

\begin_layout Standard
Quelle del 2018 sono state le prime selezioni territoriali nelle quali è
 stata utilizzata la nuova modalità di sottoposizione (si veda 
\begin_inset CommandInset ref
LatexCommand pageref
reference "sec:Nuova-mod_sottoposizione"

\end_inset

), quindi immagino che l'idea degli autori fosse quella di fornire un semplice
 problema per testare la modalità di sottoposizione, che non avesse difficoltà
 risolutive, ma permettesse altresì di verificare se si era in grado di
 gestire la nuova modalità.
 Detto questo, il problema in sè è piuttosto semplice: poichè gli antipatici
 non possono mai aumentare il valore della bellezza di una festa, avendo
 valori di amicizia negativi, basta invitare alla festa solo gli amici simpatici
 che hanno un grado di amicizia maggiore di 0.
 Una soluzione quindi può essere scritta nel modo seguente:
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "basicstyle={\small\ttfamily},frame=lr,language={C++},numbers=left,showstringspaces=false,tabsize=4"
inline false
status collapsed

\begin_layout Plain Layout

int main()
\end_layout

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

    ifstream in("input.txt");
\end_layout

\begin_layout Plain Layout

    ofstream out("output.txt");
\end_layout

\begin_layout Plain Layout

    int T;
\end_layout

\begin_layout Plain Layout

    in >> T;
\end_layout

\begin_layout Plain Layout

    for (int test = 1; test <= T; test++)
\end_layout

\begin_layout Plain Layout

    {
\end_layout

\begin_layout Plain Layout

        out << "Case #" << test << ": ";
\end_layout

\begin_layout Plain Layout

        int n, bellezza = 0;
\end_layout

\begin_layout Plain Layout

        in >> n;
\end_layout

\begin_layout Plain Layout

        for (int i = 0; i < n; i++)
\end_layout

\begin_layout Plain Layout

        {
\end_layout

\begin_layout Plain Layout

            int valore;
\end_layout

\begin_layout Plain Layout

            in >> valore;
\end_layout

\begin_layout Plain Layout

            if (valore > 0)
\end_layout

\begin_layout Plain Layout

                bellezza += valore;
\end_layout

\begin_layout Plain Layout

        }
\end_layout

\begin_layout Plain Layout

        out << bellezza << endl;
\end_layout

\begin_layout Plain Layout

    }
\end_layout

\begin_layout Plain Layout

    return 0;
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
La soluzione vera e propria si trova quindi tra le righe 10-19 e non fa
 altro che leggere il numero 
\series bold
n 
\series default
di amici (riga 11), fare un ciclo per leggere i valori di amicizia degli
 
\series bold
n 
\series default
amici (riga 12 e seguenti), e sommare nella variabile 
\series bold
bellezza 
\series default
solo i gradi di amicizia positivi, concludendo con la stampa del valore
 di 
\series bold
bellezza
\series default
.
\end_layout

\begin_layout Standard
Ritengo utile soffermarmi un attimo ancora sulle peculiarità del nuovo sistema
 di sottoposizione:
\end_layout

\begin_layout Itemize
il sistema fornisce un file di input (
\emph on
input.txt
\emph default
), che deve essere letto secondo le istruzioni del testo e che in generale
 contiene più di una istanza del problema.
 Questo implica che ci sarà sempre un ciclo esterno come quello alla riga
 7, che permette di ripetere il procedimento risolutivo per ognuna delle
 istanze del problema.
\end_layout

\begin_layout Itemize
una conseguenza ovvia, ma che durante la gara può essere dimenticata
\begin_inset Foot
status open

\begin_layout Plain Layout
Lo dico per esperienza personale
\end_layout

\end_inset

, è che ogni volta devono essere reinizializzate eventuali variabili che
 ne abbiano necessità, ad esempio in questo problema la variabile 
\series bold
bellezza 
\series default
(riga 10)
\end_layout

\begin_layout Itemize
il vantaggio del nuovo sistema è che, una volta eseguito sul proprio computer
 il programma e prodotto il file di output (
\emph on
output.txt
\emph default
 in questo esempio, ma il nome è irrilevante), la sottoposizione al correttore
 restituisca immediatamente il numero di casi di test risolti correttamente,
 dando quindi un feedback istantaneo sulla bontà della soluzione proposta
 e, di conseguenza, sul numero di punti guadagnati.
\end_layout

\begin_layout Section
Antivirus - Territoriali 2018
\end_layout

\begin_layout Standard
\begin_inset Box Framed
position "t"
hor_pos "c"
has_inner_box 0
inner_pos "t"
use_parbox 0
use_makebox 0
width "100col%"
special "none"
height "1in"
height_special "totalheight"
thickness "0.4pt"
separation "3pt"
shadowsize "4pt"
framecolor "black"
backgroundcolor "none"
status open

\begin_layout Subsection*
Antivirus (antivirus)
\end_layout

\begin_layout Subsubsection*
Punteggio massimo: 12
\end_layout

\begin_layout Subsubsection*
\noindent
Descrizione del problema
\end_layout

\begin_layout Plain Layout
Il nuovo sistema di gara delle Selezioni Territoriali funziona alla grande,
 ma Mojito non è così convinto...
 sembra infatti che la nota mascotte delle Olimpiadi abbia fiutato un 
\series bold
virus
\series default
 nascosto fra i file inviati da un partecipante!
\end_layout

\begin_layout Plain Layout
Conosciamo la lunghezza del virus e sappiamo che si ripete uguale nei quattro
 file che abbiamo ricevuto, ma non sappiamo dove.
 Aiutaci ad individuare il virus!
\end_layout

\begin_layout Plain Layout
I quattro file F
\begin_inset script subscript

\begin_layout Plain Layout
1
\end_layout

\end_inset

,F
\begin_inset script subscript

\begin_layout Plain Layout
2
\end_layout

\end_inset

,F
\begin_inset script subscript

\begin_layout Plain Layout
3
\end_layout

\end_inset

,F
\begin_inset script subscript

\begin_layout Plain Layout
4
\end_layout

\end_inset

 sono dati in input, rappresentati come quattro stringhe di caratteri di
 lunghezza rispettivamente N
\begin_inset script subscript

\begin_layout Plain Layout
1
\end_layout

\end_inset

, N
\begin_inset script subscript

\begin_layout Plain Layout
2
\end_layout

\end_inset

, N
\begin_inset script subscript

\begin_layout Plain Layout
3
\end_layout

\end_inset

, N
\begin_inset script subscript

\begin_layout Plain Layout
4
\end_layout

\end_inset

.
\end_layout

\begin_layout Plain Layout
Il virus è una stringa di caratteri 
\emph on
V
\emph default
 di lunghezza 
\emph on
M
\emph default
.
 La lunghezza 
\emph on
M
\emph default
 è data in input, ma non si conosce il contenuto della stringa 
\emph on
V
\emph default
 del virus.
\end_layout

\begin_layout Plain Layout
Sappiamo con certezza che il virus 
\emph on
V
\emph default
 appare all'interno di tutti e quattro i file, come sottostringa di caratteri
 consecutivi.
 Sappiamo inoltre che 
\series bold
NON
\series default
 ci sono altre sottostringhe consecutive di lunghezza 
\emph on
M
\emph default
 che si ripetono uguali in tutti e quattro i file.
\end_layout

\begin_layout Plain Layout
Le posizioni dei caratteri nelle stringhe sono numerati a partire da 
\emph on
0
\emph default
.
 Per ciascuno dei quattro file F
\begin_inset script subscript

\begin_layout Plain Layout
i
\end_layout

\end_inset

, trova la posizione in cui è inserito il virus, ovvero la posizione dove
 appare il primo carattere del virus 
\emph on
V
\emph default
 all'interno della stringa F
\begin_inset script subscript

\begin_layout Plain Layout
i
\end_layout

\end_inset

.
\end_layout

\begin_layout Subsubsection*
Dati di input
\end_layout

\begin_layout Plain Layout
La prima riga del file di input contiene un intero 
\emph on
T
\emph default
, il numero di casi di test.
 Seguono 
\emph on
T
\emph default
 casi di test, numerati da 1 a 
\emph on
T.

\emph default
 Ogni caso di test è preceduto da una riga vuota.
\end_layout

\begin_layout Plain Layout
In ciascun caso di test:
\end_layout

\begin_layout Itemize
La prima riga contiene quattro interi, N
\begin_inset script subscript

\begin_layout Plain Layout
1
\end_layout

\end_inset

, N
\begin_inset script subscript

\begin_layout Plain Layout
2
\end_layout

\end_inset

, N
\begin_inset script subscript

\begin_layout Plain Layout
3
\end_layout

\end_inset

, N
\begin_inset script subscript

\begin_layout Plain Layout
4
\end_layout

\end_inset

, separati da uno spazio, che corrispondono alla lunghezza di ciascuno dei
 quattro file.
\end_layout

\begin_layout Itemize
La seconda riga contiene un solo intero 
\emph on
M
\emph default
, che corrisponde alla lunghezza del virus.
\end_layout

\begin_layout Itemize
Le successive 4 righe contengono rispettivamente le quattro stringhe F
\begin_inset script subscript

\begin_layout Plain Layout
1
\end_layout

\end_inset

,F
\begin_inset script subscript

\begin_layout Plain Layout
2
\end_layout

\end_inset

,F
\begin_inset script subscript

\begin_layout Plain Layout
3
\end_layout

\end_inset

,F
\begin_inset script subscript

\begin_layout Plain Layout
4
\end_layout

\end_inset

.
\end_layout

\begin_layout Subsubsection*
Dati di output
\end_layout

\begin_layout Plain Layout
Il file di output deve contenere la risposta ai casi di test che sei riuscito
 a risolvere.
 Per ogni caso di test che hai risolto, il file di output deve contenere
 una riga con la dicitura
\end_layout

\begin_layout Verbatim

Case #t: p1 p2 p3 p4
\end_layout

\begin_layout Plain Layout
dove 
\emph on
t
\emph default
 è il numero del caso di test (a partire da 1) e i valori 
\emph on
p1, p2, p3, p4
\emph default
 sono le posizioni in cui si trova il virus in ciascuno dei quattro file.
 Con posizione si intende l'indice del primo carattere del virus, il primo
 carattere del file ha indice zero.
\end_layout

\begin_layout Subsubsection*
Assunzioni
\end_layout

\begin_layout Itemize

\emph on
T
\emph default
=12, sono presenti 12 casi di input.
\end_layout

\begin_layout Itemize
2 ≤ N
\begin_inset script subscript

\begin_layout Plain Layout
1
\end_layout

\end_inset

, N
\begin_inset script subscript

\begin_layout Plain Layout
2
\end_layout

\end_inset

, N
\begin_inset script subscript

\begin_layout Plain Layout
3
\end_layout

\end_inset

, N
\begin_inset script subscript

\begin_layout Plain Layout
4
\end_layout

\end_inset

 ≤ 100, i file non sono più lunghi di 100 caratteri.
\end_layout

\begin_layout Itemize
2≤M≤20, il virus non è più lungo di 20 caratteri.
\end_layout

\begin_layout Itemize
M≤min(N
\begin_inset script subscript

\begin_layout Plain Layout
1
\end_layout

\end_inset

, N
\begin_inset script subscript

\begin_layout Plain Layout
2
\end_layout

\end_inset

, N
\begin_inset script subscript

\begin_layout Plain Layout
3
\end_layout

\end_inset

, N
\begin_inset script subscript

\begin_layout Plain Layout
4
\end_layout

\end_inset

), il virus non è più lungo del file più corto.
\end_layout

\begin_layout Itemize
Tutti i caratteri dei file sono lettere minuscole dell'alfabeto inglese
 (dalla a alla z), 
\series bold
NON
\series default
 sono presenti spazi.
\end_layout

\begin_layout Itemize
È garantito che il virus esiste ed è unico.
\end_layout

\begin_layout Plain Layout
\begin_inset Tabular
<lyxtabular version="3" rows="2" columns="2">
<features tabularvalignment="middle">
<column alignment="left" valignment="top" width="2.5in">
<column alignment="left" valignment="top" width="5cm">
<row>
<cell alignment="left" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
File input.txt
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
File output.txt
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none
2
\end_layout

\begin_layout Plain Layout
\begin_inset VSpace defskip
\end_inset


\end_layout

\begin_layout Plain Layout

\family typewriter
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none
8 12 10 74
\end_layout

\begin_layout Plain Layout

\family typewriter
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none
ananasso
\end_layout

\begin_layout Plain Layout

\family typewriter
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none
associazione
\end_layout

\begin_layout Plain Layout

\family typewriter
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none
tassonomia
\end_layout

\begin_layout Plain Layout

\family typewriter
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none
massone
\end_layout

\begin_layout Plain Layout
\begin_inset VSpace defskip
\end_inset


\end_layout

\begin_layout Plain Layout

\family typewriter
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none
6 9 11 10
\end_layout

\begin_layout Plain Layout

\family typewriter
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none
3
\end_layout

\begin_layout Plain Layout

\family typewriter
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none
simone
\end_layout

\begin_layout Plain Layout

\family typewriter
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none
ponessimo
\end_layout

\begin_layout Plain Layout

\family typewriter
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none
milionesimo
\end_layout

\begin_layout Plain Layout

\family typewriter
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none
cassonetto
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
Case #1: 4 0 1 1
\end_layout

\begin_layout Plain Layout

\family typewriter
Case #2: 3 1 4 4
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Subsubsection*
Spiegazione
\end_layout

\begin_layout Plain Layout
Nel 
\series bold
primo caso d'esempio
\series default
 il virus è 
\series bold
asso
\series default
: anan
\series bold
asso
\series default
, 
\series bold
asso
\series default
ciazione, t
\series bold
asso
\series default
nomia, m
\series bold
asso
\series default
ne
\end_layout

\begin_layout Plain Layout
\noindent
Nel 
\series bold
secondo caso d'esempio
\series default
 il virus è 
\series bold
one
\series default
: sim
\series bold
one
\series default
, p
\series bold
one
\series default
ssimo, mili
\series bold
one
\series default
simo, cass
\series bold
one
\series default
tto.
 
\end_layout

\begin_layout Plain Layout
\noindent
Nota che 
\series bold
sim
\series default
 è presente nei primi tre file ma non nel quarto, quindi non è il virus
 cercato.
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Suggerimenti
\end_layout

\begin_layout Itemize
Meglio stringhe C o C++?
\end_layout

\begin_layout Itemize
Come si cerca una stringa all'interno di un'altra stringa?
\end_layout

\begin_layout Itemize
Come può aiutare il fatto di sapere già la dimensione del virus?
\end_layout

\begin_layout Itemize
Date le dimensioni del problema, è fattibile una soluzione a forza bruta?
\end_layout

\begin_layout Subsection
Soluzione
\end_layout

\begin_layout Standard
Il passo elementare nella soluzione di questo problema prevede di cercare
 una stringa all'interno di un'altra, cosa che può essere fatta in due modi:
\end_layout

\begin_layout Itemize
implementando una piccola funzione che risolva il problema
\end_layout

\begin_layout Itemize
usando la funzionalità presente nelle librerie di C e C++, 
\emph on
strstr
\emph default
 e 
\emph on
find
\emph default
, rispettivamente.
\end_layout

\begin_layout Standard
Sapendo verificare la presenza di una stringa all'interno di un'altra, ci
 si può iniziare a domandare come fare a scoprire quale stringa in particolare
 è il virus cercato, dal momento che se ne conosce la dimensione, ma non
 il contenuto.
\end_layout

\begin_layout Standard
Un semplice algoritmo risolutivo consiste nel prendere tutte le sottostringhe
 di caratteri consecutivi di lunghezza 
\emph on
M
\emph default
 all'interno di uno dei quattro file, il primo per semplicità, e avere quindi
 una lista di candidati ad essere virus: tra tutti questi candidati solo
 uno sarà presente contemporaneamente nei tre file rimanenti, quindi basterà
 provare con tutti fino a trovare quello che soddisfa questa proprietà.
\end_layout

\begin_layout Standard
Prima di guardare l'implementazione può valere la pena soffermarsi sul costo
 computazionale della soluzione proposta.
 La prima domanda riguarda il numero di virus candidati: quanti possono
 essere al massimo? Essendo i file lunghi al massimo 100 e i virus lunghi
 al minimo 2, il numero massimo di virus candidati è 99, che è il numero
 di stringhe di 2 caratteri consecutivi all'interno di una stringa di lunghezza
 100.
\end_layout

\begin_layout Standard
Anche avendo 99 stringhe candidate a essere virus, la ricerca di ognuna
 di esse all'interno dei 3 file rimasti ha un costo basso, in generale proporzio
nale a
\family typewriter
:
\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
O(3*numero\_candidati*numero\_confronti)
\]

\end_inset


\end_layout

\begin_layout Standard
dove 
\family typewriter
numero_confronti
\family default
 è il numero di confronti che devono essere fatti all'interno di ogni stringa
 per vedere se contiene o meno il virus.
 Siccome anche ogni altra stringa (file) al massimo è lunga 100, il numero
 di confronti che un algoritmo di ricerca banale fa è di nuovo proporzionale
 a 100.
 Questa analisi ci conforta sul fatto che, date le dimensioni del problema,
 non serve andare a cercare una soluzione più sofisticata di quella descritta,
 e quindi una possibibile inplementazione è la seguente:
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "basicstyle={\small\ttfamily},frame=lr,language={C++},numbers=left,showstringspaces=false,tabsize=4"
inline false
status open

\begin_layout Plain Layout

int main()
\end_layout

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

    ifstream in("input.txt");
\end_layout

\begin_layout Plain Layout

    ofstream out("output.txt");
\end_layout

\begin_layout Plain Layout

    int T;
\end_layout

\begin_layout Plain Layout

    in >> T;
\end_layout

\begin_layout Plain Layout

    for (int test = 1; test <= T; test++)
\end_layout

\begin_layout Plain Layout

    {
\end_layout

\begin_layout Plain Layout

        out << "Case #" << test << ": ";
\end_layout

\begin_layout Plain Layout

        int trash;
\end_layout

\begin_layout Plain Layout

        int l_virus;
\end_layout

\begin_layout Plain Layout

        string F[4];
\end_layout

\begin_layout Plain Layout

        vector<string> viruses;
\end_layout

\begin_layout Plain Layout

        string soluzione;
\end_layout

\begin_layout Plain Layout

        in >> trash >> trash >> trash >> trash;
\end_layout

\begin_layout Plain Layout

        in >> l_virus;
\end_layout

\begin_layout Plain Layout

        in >> F[0] >> F[1] >> F[2] >> F[3];
\end_layout

\begin_layout Plain Layout

        for (int i = 0; i < F[0].size() - l_virus; i++)
\end_layout

\begin_layout Plain Layout

            viruses.push_back(F[0].substr(i, l_virus));
\end_layout

\begin_layout Plain Layout

        for (auto virus: viruses)
\end_layout

\begin_layout Plain Layout

        {
\end_layout

\begin_layout Plain Layout

            bool trovato = true;
\end_layout

\begin_layout Plain Layout

            for (int j = 1; j < 4; j++)
\end_layout

\begin_layout Plain Layout

                if (F[j].find(virus) == string::npos)
\end_layout

\begin_layout Plain Layout

                    trovato = false;
\end_layout

\begin_layout Plain Layout

            if (trovato)
\end_layout

\begin_layout Plain Layout

                soluzione = virus;
\end_layout

\begin_layout Plain Layout

        }
\end_layout

\begin_layout Plain Layout

        for (auto file: F)
\end_layout

\begin_layout Plain Layout

            out << file.find(soluzione) << " ";
\end_layout

\begin_layout Plain Layout

        out <<  endl;
\end_layout

\begin_layout Plain Layout

    }
\end_layout

\begin_layout Plain Layout

    return 0;
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
La soluzione si trova tra la riga 9 e la 31 e utilizza le stringhe C++ per
 raggiungere il risultato richiesto.
 Tra le variabili utilizzate vale la pena notare il vettore 
\emph on
F
\emph default
 di quattro 
\family typewriter
string
\family default
 per contenere i quattro file, il 
\emph on
vector
\emph default
 di 
\emph on
string
\emph default
 
\family typewriter
viruses
\family default
 per contenere i virus candidati e
\family typewriter
 l_virus
\family default
 che rappresenta la lunghezza del virus.
\end_layout

\begin_layout Standard
Utilizzando le stringhe C++ (ma probabilmente lo stesso discorso si sarebbe
 potuto fare con le stringhe C), i primi quattro interi che rappresentano
 la lunghezza delle stringhe sono di fatto inutili e quindi vengono letti,
 perchè ovviamente non si può non farlo, ma i loro valori vengono 
\begin_inset Quotes eld
\end_inset

buttati via
\begin_inset Quotes erd
\end_inset

 nella variabile 
\family typewriter
trash
\family default
 (riga 15).
 Dopo aver letto le quattro stringhe (file), viene presa la prima e viene
 utilizzata per inserire nel vettore viruses tutti i virus candidati (righe
 18-19), stando attenti a prendere solo sottostringhe di lunghezza 
\family typewriter
l_virus
\family default
 e non più corte: questo spiega perchè 
\family typewriter
i
\family default
 viene fermato a 
\family typewriter
F[0].size() - l_virus
\family default
 e non a 
\family typewriter
F[0].size()
\family default
, altrimenti la 
\emph on
substring
\emph default
 avrebbe generato in coda stringhe di lunghezza via via più corta, portando
 a un errore nell'algoritmo.
\end_layout

\begin_layout Standard
Una volta creato il vettore dei possibili virus, viene fatta un'iterazione
 per ognuno di essi, usando il costrutto 
\emph on
foreach
\emph default
 del C++ 2011 (riga 20) e, per ognuno di essi, si utilizza il metodo find
 per verificare se 
\series bold
non
\series default
 compare, poichè in quel caso non è sicuramente il virus cercato.
 Per verificare la condizione 
\begin_inset Quotes eld
\end_inset

la sottostringa non è presente nella stringa
\begin_inset Quotes erd
\end_inset

 si confronta il valore di ritorno di 
\emph on
find
\emph default
 con 
\emph on
string::npos
\emph default
, che è ciò che ritorna 
\emph on
find
\emph default
 quando non trova la stringa, altrimenti ritorna la sua posizione.
 La stringa dell'insieme 
\family typewriter
viruses
\family default
 che viene trovata in tutti e tre i file viene memorizzata nella variabile
 
\family typewriter
soluzione
\family default
.
\end_layout

\begin_layout Standard
A questo punto non rimane che stampare la posizione all'interno delle quattro
 stringhe utilizzando ancora il metodo 
\emph on
find
\emph default
.
\end_layout

\begin_layout Standard
Un'ultima osservazione: per ridurre il numero di virus candidati si sarebbe
 potuta scegliere tra le quattro stringhe F quella di lunghezza minore,
 ma, come osservato durante l'analisi del costo del problema, non ci sarebbero
 stati vantaggi significativi.
\end_layout

\begin_layout Section
Radioanalisi fossile - Territoriali 2018
\end_layout

\begin_layout Standard
\begin_inset Box Framed
position "t"
hor_pos "c"
has_inner_box 0
inner_pos "t"
use_parbox 0
use_makebox 0
width "100col%"
special "none"
height "1in"
height_special "totalheight"
thickness "0.4pt"
separation "3pt"
shadowsize "4pt"
framecolor "black"
backgroundcolor "none"
status open

\begin_layout Subsection*
Radioanalisi fossile (xray)
\end_layout

\begin_layout Subsubsection*
Punteggio massimo: 19
\end_layout

\begin_layout Subsubsection*
\noindent
Descrizione del problema
\end_layout

\begin_layout Plain Layout
È stato appena ritrovato un fossile della rarissima specie 
\emph on
Canis mojitus albus
\emph default
, ritenuta antenata della più comune 
\emph on
Canis mojitus familiaris
\emph default
.
 Per analizzarlo, gli scienziati devono trattarlo con delle radiazioni:
 ogni centimetro dell'osso deve riceverne una precisa quantità.
 La macchina che fa il trattamento può applicare radiazioni in modo uniforme
 su un qualsiasi segmento contiguo: calcola quante volte deve essere azionata
 la macchina per ottenere la giusta quantità di radiazioni su ogni punto
 dell'osso.
\end_layout

\begin_layout Plain Layout
L'osso da trattare è lungo 
\series bold
N
\series default
 centimetri, numerati da 1 a 
\series bold
N
\series default
.
 Il centimetro 
\emph on
i
\emph default
 deve ricevere una quantità di radiazioni specificata da un numero naturale
 R
\begin_inset script subscript

\begin_layout Plain Layout
i
\end_layout

\end_inset

.
 Il numero 
\series bold
N
\series default
 ed i numeri 
\begin_inset Formula $R_{1}\ldots R_{N}$
\end_inset

 sono dati in input.
\end_layout

\begin_layout Plain Layout
La macchina viene azionata specificando due numeri interi positivi 
\emph on
a
\emph default
 e 
\emph on
b
\emph default
, che indicano gli estremi del segmento di osso su cui la macchina opera
 (
\begin_inset Formula $a\leq b$
\end_inset

).
 Dopo tale azionamento, tutti i centimetri da 
\emph on
a
\emph default
 a 
\emph on
b
\emph default
 dell'osso accumulano 1 unità di radiazioni.
\end_layout

\begin_layout Plain Layout
Dopo aver azionato la macchina un certo numero di volte, la quantità di
 radiazioni ricevute sul centimetro 
\emph on
i
\emph default
 si può conoscere contando quante volte una radiazione ha operato su quella
 zona (ovvero, quante volte la macchina è stata azionata con valori tali
 per cui 
\begin_inset Formula $a\leq i\leq b$
\end_inset

).
\end_layout

\begin_layout Plain Layout
Calcola il numero minimo di volte in cui è necessario azionare la macchina
 affinché ciascuna zona 
\emph on
i
\emph default
 riceva esattamente la quantità di radiazioni richiesta 
\begin_inset Formula $R_{i}$
\end_inset

.
\end_layout

\begin_layout Subsubsection*
Dati di input
\end_layout

\begin_layout Plain Layout
La prima riga del file di input contiene un intero T, il numero di casi
 di test.
 Seguono T casi di test, numerati da 1 a T.
 Ogni caso di test è preceduto da una riga vuota.
\end_layout

\begin_layout Plain Layout
In ciascun caso di test, la prima riga contiene l'intero 
\emph on
N
\emph default
.
 La seconda riga contiene gli 
\emph on
N
\emph default
 valori 
\begin_inset Formula $R_{1}\ldots R_{N}$
\end_inset

 separati da spazio.
\end_layout

\begin_layout Subsubsection*
Dati di output
\end_layout

\begin_layout Plain Layout
Il file di output deve contenere la risposta ai casi di test che sei riuscito
 a risolvere.
 Per ogni caso di test che hai risolto, il file di output deve contenere
 una riga con la dicitura
\end_layout

\begin_layout Verbatim

Case #t: p
\end_layout

\begin_layout Plain Layout
dove 
\emph on
t
\emph default
 è il numero del caso di test (a partire da 1) e 
\emph on
p
\emph default
 è il minimo numero di volte in cui la macchina deve essere azionata.
\end_layout

\begin_layout Subsubsection*
Assunzioni
\end_layout

\begin_layout Itemize

\emph on
T
\emph default
=19, sono presenti 19 casi di prova.
\end_layout

\begin_layout Itemize
1≤N≤1000, ovvero, l'osso è lungo al massimo 1000 centimetri.
\end_layout

\begin_layout Itemize
0≤R
\begin_inset script subscript

\begin_layout Plain Layout
i
\end_layout

\end_inset

≤1000, ogni centimetro può dover ricevere una quantità di radiazione fino
 a 1000.
\end_layout

\begin_layout Plain Layout
\begin_inset Tabular
<lyxtabular version="3" rows="2" columns="2">
<features tabularvalignment="middle">
<column alignment="left" valignment="top" width="2.5in">
<column alignment="left" valignment="top" width="5cm">
<row>
<cell alignment="left" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
File input.txt
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
File output.txt
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none
2
\end_layout

\begin_layout Plain Layout
\begin_inset VSpace defskip
\end_inset


\end_layout

\begin_layout Plain Layout

\family typewriter
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none
4 
\end_layout

\begin_layout Plain Layout

\family typewriter
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none
1 2 3 1
\end_layout

\begin_layout Plain Layout
\begin_inset VSpace defskip
\end_inset


\end_layout

\begin_layout Plain Layout

\family typewriter
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none
4 
\end_layout

\begin_layout Plain Layout

\family typewriter
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none
100 0 1 1
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
Case #1: 3
\end_layout

\begin_layout Plain Layout

\family typewriter
Case #2: 101
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Subsubsection*
Spiegazione
\end_layout

\begin_layout Plain Layout
\noindent
Nel 
\series bold
primo caso d'esempio
\series default
, è possibile azionare la macchina ad esempio nel seguente modo:
\end_layout

\begin_layout Enumerate
\noindent
segmento da 
\emph on
a
\emph default
=2 a 
\emph on
b
\emph default
=3
\end_layout

\begin_layout Enumerate
\noindent
segmento da 
\emph on
a
\emph default
=1 a 
\emph on
b
\emph default
=4
\end_layout

\begin_layout Enumerate
\noindent
segmento da 
\emph on
a
\emph default
=3 a 
\emph on
b
\emph default
=3
\end_layout

\begin_layout Plain Layout
\noindent
Graficamente:
\end_layout

\begin_layout Verbatim
\noindent

.
 x x .
 <-- azionamento 1
\end_layout

\begin_layout Verbatim
\noindent

x x x x <-- azionamento 2
\end_layout

\begin_layout Verbatim
\noindent

.
 .
 x .
 <-- azionamento 3
\end_layout

\begin_layout Verbatim
\noindent

-------
\end_layout

\begin_layout Verbatim
\noindent

1 2 3 1 <-- totale radiazione accumulata
\end_layout

\begin_layout Plain Layout
\noindent
Non ci sono soluzioni con solo 2 azionamenti o meno, quindi la risposta
 corretta è 3.
\end_layout

\begin_layout Plain Layout
\noindent
Nel 
\series bold
secondo caso d'esempio
\series default
, è possibile azionare la macchina ad esempio nel seguente modo:
\end_layout

\begin_layout Enumerate
\noindent
segmento da 
\emph on
a
\emph default
=1a 
\emph on
b
\emph default
=1(ripeti 100 volte)
\end_layout

\begin_layout Enumerate
\noindent
segmento da 
\emph on
a
\emph default
=3 a 
\emph on
b
\emph default
=4
\end_layout

\begin_layout Plain Layout
\noindent
Non ci sono soluzioni con solo 100 azionamenti o meno, quindi la risposta
 corretta è 101.
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Suggerimenti
\end_layout

\begin_layout Itemize
Quante volte deve essere irradiato un centimetro di osso per ottenere la
 quantità richiesta 
\begin_inset Formula $R_{i}$
\end_inset

?
\end_layout

\begin_layout Itemize
Se ogni centimetro venisse irradiato separatamente da ogni altro quante
 operazioni di irradiamento sarebbero necessarie in totale? Sarebbero troppe?
\end_layout

\begin_layout Itemize
Se invece si irradiasse tutto l'osso un numero di volte pari al massimo
 valore di 
\begin_inset Formula $R_{i}$
\end_inset

, il risultato comporterebbe un numero minimo di irraggiamenti, ma ogni
 parte sarebbe irradiata correttamente?
\end_layout

\begin_layout Itemize
Fra le due situazioni precedenti, entrambe estreme, come raggiungere la
 situazione richiesta?
\end_layout

\begin_layout Itemize
Se è possibile sembra convenga irradiare ogni volta un intervallo il più
 ampio possibile, ma quali sono le condizioni per cui ciò porta a un risultato
 valido? 
\end_layout

\begin_layout Itemize
Esiste una rappresentazione grafica che può aiutare a comprendere meglio
 il problema?
\end_layout

\begin_layout Subsection
Soluzione
\end_layout

\begin_layout Standard
Un modo di rappresentare il problema che può aiutare a vedere la soluzione
 è quello di pensare ad ogni centimetro di osso come una 
\begin_inset Quotes eld
\end_inset

costruzione
\begin_inset Quotes erd
\end_inset

 composta da 
\begin_inset Formula $R_{i}$
\end_inset

 mattoncini sovrapposti e quindi arrivare a una rappresentazione come quella
 in figura 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:rappresentazione-osso"

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Float figure
placement h
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename ../materiali/problemi territoriali/2018_radioanalisi fossile/esempio.eps
	scale 50

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:rappresentazione-osso"

\end_inset

Come risulterebbe il primo esempio del testo
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Perchè una rappresentazione del genere può aiutare? Si pensi alle due situazioni
 estreme poste nei suggerimenti e si provi a rappresentarle con delle situazioni
 nelle quali producano dei risultati corretti, ottenendo ad esempio quanto
 si può vedere in figura 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:Due-casi-estremi"

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Float figure
placement h
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename /home/xubuntu/guida_territoriali/materiali/problemi territoriali/2018_radioanalisi fossile/casi.eps
	scale 50

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:Due-casi-estremi"

\end_inset

Due casi estremi
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Nel caso (
\emph on
a
\emph default
), la macchina a 
\emph on
raggi x
\emph default
 non può irraggiare dal primo all'ultimo centimetro per 4 volte, perchè
 altrimenti anche i centimetri 2 e 3 riceverebbero una dose non corretta,
 in quanto quelle parti non devono ricevere proprio nessuna dose: quindi
 l'unica possibilità è quella di irraggiare 4 volte il centimetro 1 e altre
 4 volte il centimetro 4, per un totale di 8 irraggiamenti.
 Invece nel caso (
\emph on
b
\emph default
), siccome ogni centimetro deve ricevere la stessa dose, si può irraggiare
 tutto l'osso per 4 volte, usando quindi solo 4 irraggiamenti.
 Sembra quindi evidente che:
\end_layout

\begin_layout Itemize
ogni centimetro di osso non può ricevere più irraggiamenti della quantità
 massima a lui assegnata
\end_layout

\begin_layout Itemize
se si riescono a raggruppare centimetri adiacenti che hanno necessità della
 stessa quantità di raggi x si risparmia sul numero di irraggiamenti, irraggiand
o per una lunghezza maggiore
\end_layout

\begin_layout Standard
Combinando queste due semplici informazioni si può realizzare un algoritmo
 che, per ogni 
\begin_inset Quotes eld
\end_inset


\emph on
livello
\emph default

\begin_inset Quotes erd
\end_inset

, cerchi tutti gli N intervalli contigui di osso che devono essere irraggiati
 con la stessa quantità di radiazioni e quindi effettui N irraggiamenti.
 Per 
\emph on
livello
\emph default
 si intende la quantità di radiazioni, come indicato nella figura
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:soluzione-x-ray"

\end_inset

: la figura rappresenta il caso d'esempio a cui è stato aggiunto un altro
 centimetro da irraggiare con tre unità, per renderlo più significativo.
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement h
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename ../materiali/problemi territoriali/2018_radioanalisi fossile/soluzione.eps
	scale 60

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:soluzione-x-ray"

\end_inset

Esempio grafico di algoritmo risolutivo
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Come si vede la macchina partirà dal livello 3, nel quale ci sono due intervalli
 da irraggiare, quello del centimetro 3 e del centimetro 5.
 Successivamente si 
\begin_inset Quotes eld
\end_inset

sposterà
\begin_inset Quotes erd
\end_inset

 al livello 2, dove gli intervalli sono ancora due, quelli dei centimetri
 2-3 e quello del centimetro 5.
 Infine si sposterà al livello 1, dove l'intervallo va dal centimetro 1
 al centimetro 5, arrivando quindi a un totale di 5 irraggiamenti, che è
 la soluzione, essendo il minimo possibile.
\end_layout

\begin_layout Standard
Volendo implementare l'algoritmo nel modo più simile a quanto mostrato in
 figura, si può utilizzare una matrice in cui le caselle vengano 
\begin_inset Quotes eld
\end_inset

colorate
\begin_inset Quotes erd
\end_inset

 per colonne come mostrato nelle figure e successivamente muoversi per livelli
 per implementare la ricerca di intervalli contigui che contengono caselle
 da irraggiare, ottenendo questo codice.
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "basicstyle={\small\ttfamily},frame=lr,language={C++},numbers=left,showstringspaces=false,tabsize=4"
inline false
status collapsed

\begin_layout Plain Layout

int osso[1001][1001];
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

void inizializza()
\end_layout

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

    for (int i = 0 ; i < 1001; i++)
\end_layout

\begin_layout Plain Layout

        for (int j = 0; j < 1001; j++)
\end_layout

\begin_layout Plain Layout

            osso[i][j] = 0;
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

void riempi_colonna(int c, int n)
\end_layout

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

    for (int i = 0; i < n; i++)
\end_layout

\begin_layout Plain Layout

        osso[i][c] = 1;
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

int intervalli(int r, int n)
\end_layout

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

    int i = 0;
\end_layout

\begin_layout Plain Layout

    int conta = 0;
\end_layout

\begin_layout Plain Layout

    while (osso[r][i] == 0) i++;
\end_layout

\begin_layout Plain Layout

    while (i < n)
\end_layout

\begin_layout Plain Layout

    {
\end_layout

\begin_layout Plain Layout

        while(i < n && osso[r][i] == 1) i++;
\end_layout

\begin_layout Plain Layout

        while(i < n && osso[r][i] == 0) i++;
\end_layout

\begin_layout Plain Layout

        if (i < n) conta++;
\end_layout

\begin_layout Plain Layout

    }
\end_layout

\begin_layout Plain Layout

    return conta + 1;
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

int main()
\end_layout

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

    ifstream in("input.txt");
\end_layout

\begin_layout Plain Layout

    ofstream out("output.txt");
\end_layout

\begin_layout Plain Layout

    int T;
\end_layout

\begin_layout Plain Layout

    in >> T;
\end_layout

\begin_layout Plain Layout

    for (int test = 1; test <= T; test++)
\end_layout

\begin_layout Plain Layout

    {
\end_layout

\begin_layout Plain Layout

        int n, massimo = 0;
\end_layout

\begin_layout Plain Layout

        out << "Case #" << test << ": ";
\end_layout

\begin_layout Plain Layout

        inizializza();
\end_layout

\begin_layout Plain Layout

        in >> n;
\end_layout

\begin_layout Plain Layout

        for (int i = 0; i < n; i++)
\end_layout

\begin_layout Plain Layout

        {
\end_layout

\begin_layout Plain Layout

            int temp;
\end_layout

\begin_layout Plain Layout

            in >> temp;
\end_layout

\begin_layout Plain Layout

            if (temp > massimo)
\end_layout

\begin_layout Plain Layout

                massimo = temp;
\end_layout

\begin_layout Plain Layout

            riempi_colonna(i, temp);
\end_layout

\begin_layout Plain Layout

        }
\end_layout

\begin_layout Plain Layout

        int movimenti = 0;
\end_layout

\begin_layout Plain Layout

        for (int i = 0; i < massimo; i++)
\end_layout

\begin_layout Plain Layout

            movimenti += intervalli(i,n);
\end_layout

\begin_layout Plain Layout

        out << movimenti << endl;
\end_layout

\begin_layout Plain Layout

    }
\end_layout

\begin_layout Plain Layout

    return 0;
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Standard
La funzione 
\emph on
inizializza
\emph default
 pone esplicitamente a zero tutti gli elementi della matrice globale 
\emph on
osso
\emph default
 e serve perchè la matrice deve essere resettata ad ogni nuovo caso di test.
 La funzione 
\emph on
riempi_colonna
\emph default
 si occupa invece di riempire la colonna 
\emph on
c
\emph default
 con 
\emph on
n
\emph default
 caselle poste a 1, che nelle figure sono rappresentate dai quadrati grigi.
 
\end_layout

\begin_layout Standard
L'algoritmo viene di fatto svolto interamente dalla funzione 
\emph on
intervalli
\emph default
, i cui due parametri 
\series bold
r 
\series default
e 
\series bold
n 
\series default
rappresentano rispettivamente la riga (livello) sulla quale viene conteggiato
 il numero di intervallo e la lunghezza della riga, cioè nel problema la
 lunghezza dell'osso.
 L'implementazione non è ottimizzata e segue quanto esposto sopra: come
 prima cosa, alla riga 20, si scorre fino ad arrivare al primo centimetro
 di osso che necessita di essere irradiato: nella figura 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:soluzione-x-ray"

\end_inset

, se stessimo analizzando il livello 2, corrisponderebbe al centimetro 2.
 Successivamente il ciclo 
\emph on
while
\emph default
 dalla riga 21 alla riga 26 contiene due ulteriori cicli, il primo per scorrere
 un intero intervallo di 1 adiacenti, il secondo per un intervallo di 0
 adiacenti, con lo scopo di trovare un intervallo e posizionare 
\emph on
i
\emph default
 in modo che sia pronto per la ricerca dell'intervallo successivo.
 Da notare che entrambi i cicli, oltre a contenere la condizione che verifica
 se la casella 
\emph on
i
\emph default
-esima contiene un 1 o uno 0, contengono anche il controllo sul non superamento
 della lunghezza massima 
\emph on
n
\emph default
: se così non fosse 
\emph on
i
\emph default
 potrebbe uscire dalla lunghezza massima della riga con risultati imprevedibili
 (nella migliore delle ipotesi terminazione del programma, nella peggiore
 risultati non corretti).
 È inoltre indispensabile notare che il controllo 
\emph on
i < n
\emph default
 deve essere inserito come prima condizione dell'operatore di AND, poichè
 in questo modo se la condizione fallisce non viene considerata l'altra
 condizione
\begin_inset Foot
status collapsed

\begin_layout Plain Layout
Questa caratteristica di alcuni operatori booleani in alcuni linguaggi di
 programmazione viene tecnicamente chiamata 
\emph on
short-circuit evaluation
\emph default
, e consiste nel valutare il secondo argomento solo se la valutazione del
 primo non è sufficiente a determinare il valore dell'intera espressione.
\end_layout

\end_inset

, che non avrebbe un valore corretto per valori di 
\emph on
i
\emph default
 maggiori o uguali a 
\emph on
n.

\emph default
 
\end_layout

\begin_layout Standard
Alla riga 25 si incrementa il contatore solo se 
\emph on
i
\emph default
 è minore di 
\emph on
n
\emph default
, questo per tenere conto del fatto che esiste almeno un intervallo (difatti
 la funzione ritorna 
\emph on
conta + 1
\emph default
) e che l'ultimo non deve essere contato, per evitare di dover differenziare
 tra righe che finiscono con 1 oppure con 0.
\end_layout

\begin_layout Standard
A questo punto il programma, dopo aver inizializzato la matrice che rappresenta
 le radiazioni che dovrà subire l'osso (righe 40-49), si limiterà a chiamare
 questa funzione su tutti i livelli dell'intervallo (righe 50-51), sommando
 i vari movimenti che dovrà fare per ogni livello.
\end_layout

\begin_layout Standard
Viene lasciato al lettore l'esercizio di sostituire la matrice con un vettore
 di interi, dove ogni valore rappresenta la quantità di radiazioni che deve
 subire l'
\emph on
i
\emph default
-esimo centimetro di osso, ottenendo un miglioramento nell'occupazione di
 memoria (da 
\begin_inset Formula $N^{2}$
\end_inset

a 
\begin_inset Formula $N$
\end_inset

) e anche delle prestazioni, che su dei test fatti permettono al programma
 con i vettori di essere circa tre volte più veloce, pur mantenendo la stessa
 complessità computazionale
\begin_inset Foot
status collapsed

\begin_layout Plain Layout
La versione qui mostrata comunque in gara permetteva di prendere l'intero
 punteggio
\end_layout

\end_inset

.
 
\end_layout

\begin_layout Section
Escursione - Territoriali 2018
\end_layout

\begin_layout Standard
\begin_inset Box Framed
position "t"
hor_pos "c"
has_inner_box 0
inner_pos "t"
use_parbox 0
use_makebox 0
width "100col%"
special "none"
height "1in"
height_special "totalheight"
thickness "0.4pt"
separation "3pt"
shadowsize "4pt"
framecolor "black"
backgroundcolor "none"
status open

\begin_layout Subsection*
Escursione (escursione)
\end_layout

\begin_layout Subsubsection*
Punteggio massimo: 27
\end_layout

\begin_layout Subsubsection*
\noindent
Descrizione del problema
\end_layout

\begin_layout Plain Layout
Mojito vuole pianificare un'escursione sulle colline di Volterra.
 Ha a disposizione una mappa rettangolare, in cui è indicata l'altitudine
 della zona.
 Mojito vuole fare un percorso che parte dall'angolo in alto a sinistra
 della mappa e raggiunge l'angolo in basso a destra, in modo tale che il
 dislivello massimo che è costretto a fare ad ogni spostamento sia il mimimo
 possibile.
 Aiuta Mojito a calcolare questo dislivello!
\end_layout

\begin_layout Plain Layout
La mappa è una tabella di numeri interi: ciascuno esprime l'altitudine in
 metri nel corrispondente punto della mappa.
 La tabella è composta di 
\emph on
H
\emph default
 righe e 
\emph on
W
\emph default
 colonne, numerate rispettivamente da 
\emph on
1
\emph default
 a 
\emph on
H
\emph default
 e da 
\emph on
1
\emph default
 a 
\emph on
W
\emph default
.
 Nella cella di coordinate 
\emph on
(i,j)
\emph default
, ovvero in corrispondenza della riga 
\emph on
i
\emph default
 e della colonna 
\emph on
j
\emph default
, è indicato il valore dell'altitudine 
\begin_inset Formula $A_{i,j}$
\end_inset

.
\end_layout

\begin_layout Plain Layout
Mojito inizia l'escursione dalla cella di coordinate (1,1), in alto a sinistra,
 ed arriva alla cella di coordinate (H,W), in basso a destra.
 Ogni minuto si sposta di esattamente una cella, in una della quattro possibili
 direzioni (in alto, in basso, a destra o a sinistra).
 Non può però uscire dalla mappa.
\end_layout

\begin_layout Plain Layout
Stabilito un percorso lungo la mappa, il 
\series bold
pericolo
\series default
 associato a quel percorso è 
\emph on
il massimo dislivello tra due celle consecutive lungo il percorso
\emph default
, ovvero la differenza di altitudine fra due celle consecutive: non cambia
 nulla se lo spostamento è in salita o in discesa.
\end_layout

\begin_layout Plain Layout
Calcola il pericolo minimo, fra tutti i percorsi possibili che partono dalla
 cella (1,1) e arrivano alla cella (H,W).
\end_layout

\begin_layout Subsubsection*
Dati di input
\end_layout

\begin_layout Plain Layout
La prima riga del file di input contiene un intero 
\emph on
T
\emph default
, il numero di casi di test.
 Seguono 
\emph on
T
\emph default
 casi di test, numerati da 1 a 
\emph on
T
\emph default
.
 Ogni caso di test è preceduto da una riga vuota.
\end_layout

\begin_layout Plain Layout
In ciascun caso di test, la prima riga contiene due interi 
\emph on
H
\emph default
 e 
\emph on
W
\emph default
 separati da uno spazio che corrispondono all'altezza, 
\emph on
H
\emph default
, e alla larghezza, 
\emph on
W
\emph default
, della mappa.
 Le successive 
\emph on
H
\emph default
 righe contengono ciascuna 
\emph on
W
\emph default
 interi separati da spazi, corrispondenti all'altitudine in metri lungo
 una riga della mappa.
 Ovvero, in ciascun caso di test, l'altitudine 
\emph on
Ai,j
\emph default
 alle coordinate 
\emph on
i
\emph default
 e 
\emph on
j
\emph default
 appare sulla riga (
\emph on
i
\emph default
+1)-esima, in posizione 
\emph on
j
\emph default
.
\end_layout

\begin_layout Subsubsection*
Dati di output
\end_layout

\begin_layout Plain Layout
Il file di output deve contenere la risposta ai casi di test che sei riuscito
 a risolvere.
 Per ogni caso di test che hai risolto, il file di output deve contenere
 una riga con la dicitura
\end_layout

\begin_layout Verbatim

Case #t: p
\end_layout

\begin_layout Plain Layout
dove 
\emph on
t
\emph default
 è il numero del caso di test (a partire da 1) e 
\emph on
p
\emph default
 è il minimo valore di pericolo trovato per quel test case.
\end_layout

\begin_layout Subsubsection*
Assunzioni
\end_layout

\begin_layout Itemize

\emph on
T
\emph default
=27, ci sono 27 casi di prova.
\end_layout

\begin_layout Itemize
1≤
\emph on
H,W
\emph default
≤100, la mappa ha dimensione massima 100×100.
\end_layout

\begin_layout Itemize
(1,1)≠(
\emph on
H,W
\emph default
), ovvero la mappa è abbastanza grande da avere partenza e arrivo in punti
 diversi.
\end_layout

\begin_layout Itemize
1≤
\emph on
Ai,j
\emph default
≤1.000.000, l'altitudine in ogni cella è compresa fra 1 e 1.000.000.
\end_layout

\begin_layout Plain Layout
\begin_inset Tabular
<lyxtabular version="3" rows="2" columns="2">
<features tabularvalignment="middle">
<column alignment="left" valignment="top" width="2.5in">
<column alignment="left" valignment="top" width="5cm">
<row>
<cell alignment="left" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
File input.txt
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
File output.txt
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none
3
\end_layout

\begin_layout Plain Layout
\begin_inset VSpace defskip
\end_inset


\end_layout

\begin_layout Plain Layout

\family typewriter
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none
2 2
\end_layout

\begin_layout Plain Layout

\family typewriter
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none
100 150
\end_layout

\begin_layout Plain Layout

\family typewriter
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none
110 130
\end_layout

\begin_layout Plain Layout
\begin_inset VSpace defskip
\end_inset


\end_layout

\begin_layout Plain Layout

\family typewriter
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none
4 4
\end_layout

\begin_layout Plain Layout

\family typewriter
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none
1 5 6 7
\end_layout

\begin_layout Plain Layout

\family typewriter
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none
2 4 3 8
\end_layout

\begin_layout Plain Layout

\family typewriter
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none
2 9 2 8
\end_layout

\begin_layout Plain Layout

\family typewriter
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none
3 3 2 9
\family default
\series default
\shape default
\size default
\emph default
\bar default
\strikeout default
\uuline default
\uwave default
\noun default
\color inherit

\begin_inset VSpace defskip
\end_inset


\family typewriter
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none
1 10
\end_layout

\begin_layout Plain Layout

\family typewriter
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none
2 4 6 8 10 12 14 16 18 20
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none
Case #1: 20 
\end_layout

\begin_layout Plain Layout

\family typewriter
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none
Case #2: 1 
\end_layout

\begin_layout Plain Layout

\family typewriter
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none
Case #3: 2
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Subsubsection*
Spiegazione
\end_layout

\begin_layout Plain Layout
\noindent
Nel primo caso d'esempio, Mojito sceglie il percorso:
\end_layout

\begin_layout Plain Layout
\begin_inset Graphics
	filename ../materiali/problemi territoriali/2018_escursione/percorso1.png
	scale 50

\end_inset


\end_layout

\begin_layout Plain Layout
ovvero, con i seguenti spostamenti:
\end_layout

\begin_layout Itemize

\emph on
in basso
\emph default
, da(1,1) a (2,1), con un dislivello pari a 110−100=10 
\end_layout

\begin_layout Itemize

\emph on
a destra
\emph default
, da (2,1) a (2,2)=(H,W), con un dislivello pari a 130−110=20.
\end_layout

\begin_layout Plain Layout
Il pericolo del percorso è 20 (il massimo fra i dislivelli, 10 e 20).
\end_layout

\begin_layout Plain Layout
Non ci sono percorsi migliori, quindi la risposta corretta è 20.
 
\end_layout

\begin_layout Plain Layout
L'altro percorso possibile è:
\end_layout

\begin_layout Plain Layout
\begin_inset Graphics
	filename ../materiali/problemi territoriali/2018_escursione/percorso2.png
	scale 50

\end_inset


\end_layout

\begin_layout Plain Layout
che ha dislivelli 50 e 20, e quindi ha pericolo 50.
\end_layout

\begin_layout Plain Layout
Nel secondo caso d'esempio, Mojito sceglie il percorso:
\end_layout

\begin_layout Plain Layout
\begin_inset Graphics
	filename ../materiali/problemi territoriali/2018_escursione/percorso3.png
	scale 50

\end_inset


\end_layout

\begin_layout Plain Layout
Gli spostamenti hanno tutti dislivello 0 o 1, quindi il pericolo del percorso
 è 1.
 Non ci sono percorsi di pericolo pari a 0, quindi la risposta corretta
 è 1.
\end_layout

\begin_layout Plain Layout
Nel terzo caso d'esempio c'è un solo percorso possibile.
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Suggerimenti
\end_layout

\begin_layout Itemize
Come in altri esercizi (ad esempio 
\begin_inset CommandInset ref
LatexCommand vref
reference "sec:Esempio:-Mappa-antica"

\end_inset

 e 
\begin_inset CommandInset ref
LatexCommand vref
reference "sec:Trova-la-parola"

\end_inset

) si ha una mappa che è una griglia rettangolare (eventualmente quadrata):
 quali sono le similitudini e quali le differenze?
\end_layout

\begin_layout Itemize
Possono essere utilizzati gli stessi approcci usati in quei problemi o bisogna
 aggiungere qualcosa di diverso?
\end_layout

\begin_layout Itemize
Considerando che il percorso può contenere una serie di svolte in una qualsiasi
 delle quattro direzioni, posso limitarmi a esplorare la griglia con due
 cicli 
\emph on
for
\emph default
 organizzati per righe e colonne?
\end_layout

\begin_layout Itemize
Se con la ricorsione e facendo 
\emph on
backtracking
\emph default
 esploro tutti i sentieri possibili, date le dimensioni del problema, è
 possibile che risolva tutti i casi di test in tempo ragionevole?
\end_layout

\begin_layout Itemize
Se il problema diventa il tempo impiegato e non più la soluzione in sè,
 è possibile migliorare l'algoritmo in modo da ottenere tutti i risultati
 in un tempo compatibile a quello di gara?
\end_layout

\begin_layout Subsection
Soluzione
\end_layout

\begin_layout Standard
Chiaramente il problema presenta delle similitudini con quelli indicati
 e quindi l'approccio utilizzato sarà simile e farà uso della ricorsione.
 Si vedrà adesso come arrivare a due diverse soluzioni: la prima, concettualment
e più semplice, non permetterà di prendere tutti i punti, la seconda, che
 non è altro che un'evoluzione 
\emph on
furba
\emph default
 della prima, invece farà punteggio pieno.
\end_layout

\begin_layout Standard
L'idea di base è quella di usare la ricorsione per 
\begin_inset Quotes eld
\end_inset

esplorare
\begin_inset Quotes erd
\end_inset

 tutti i percorsi possibili e, man mano che li si esplorano, si tiene traccia
 del salto più alto che si è costretti a fare.
 Quando un ramo della ricorsione arriva alla casella finale, quella in posizione
 H-1, W-1, allora si verifica se il salto più alto di quel percorso è più
 basso di quello finora migliore, se sì, si memorizza la nuova soluzione
 temporanea, e, in ogni caso, tramite 
\emph on
backtracking
\emph default
 si torna indietro e si esplorano altri percorsi.
\end_layout

\begin_layout Standard
Il grosso limite di questa soluzione, come si vedrà, è che il numero di
 percorsi ha una crescita esponenziale, quindi anche con una dimensione
 della griglia piuttosto piccola, non si riesce ad arrivare a una soluzione
 in tempi ragionevoli.
\end_layout

\begin_layout Standard
Il codice comunque è il seguente:
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "basicstyle={\small\ttfamily},frame=lr,language={C++},numbers=left,showstringspaces=false,tabsize=4"
inline false
status collapsed

\begin_layout Plain Layout

int mappa[100][100];
\end_layout

\begin_layout Plain Layout

int soluzione;
\end_layout

\begin_layout Plain Layout

int H, W;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

void visita(int r, int c, int salto)
\end_layout

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

    if (salto >= soluzione)
\end_layout

\begin_layout Plain Layout

        return;
\end_layout

\begin_layout Plain Layout

    if (r == H - 1 && c == W - 1)
\end_layout

\begin_layout Plain Layout

    {
\end_layout

\begin_layout Plain Layout

        soluzione = salto;
\end_layout

\begin_layout Plain Layout

        return;
\end_layout

\begin_layout Plain Layout

    }
\end_layout

\begin_layout Plain Layout

    int temp = mappa[r][c];
\end_layout

\begin_layout Plain Layout

    mappa[r][c] = -1;
\end_layout

\begin_layout Plain Layout

    struct {
\end_layout

\begin_layout Plain Layout

		int i, j;
\end_layout

\begin_layout Plain Layout

	} direzioni[] = {{1,0},{0,1},{-1,0},{0,-1}};
\end_layout

\begin_layout Plain Layout

    for (int d = 0; d < 4; d++)
\end_layout

\begin_layout Plain Layout

    {
\end_layout

\begin_layout Plain Layout

		int i = direzioni[d].i, j = direzioni[d].j;
\end_layout

\begin_layout Plain Layout

		if (r+i >= 0 && c+j >= 0 && r+i < H && c+j < W &&
\end_layout

\begin_layout Plain Layout

			mappa[r+i][c+j] != -1)
\end_layout

\begin_layout Plain Layout

			{
\end_layout

\begin_layout Plain Layout

				if (salto > abs(temp - mappa[r+i][c+j]))
\end_layout

\begin_layout Plain Layout

					visita(r+i,c+j, salto);
\end_layout

\begin_layout Plain Layout

				else
\end_layout

\begin_layout Plain Layout

					visita(r+i,c+j, abs(temp - mappa[r+i][c+j]));
\end_layout

\begin_layout Plain Layout

			}
\end_layout

\begin_layout Plain Layout

	}
\end_layout

\begin_layout Plain Layout

    mappa[r][c] = temp;
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

int main()
\end_layout

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

    ifstream in("input.txt");
\end_layout

\begin_layout Plain Layout

    ofstream out("output.txt");
\end_layout

\begin_layout Plain Layout

    int T;
\end_layout

\begin_layout Plain Layout

    in >> T;
\end_layout

\begin_layout Plain Layout

    for (int test = 1; test <= T; test++)
\end_layout

\begin_layout Plain Layout

    {
\end_layout

\begin_layout Plain Layout

        out << "Case #" << test << ": ";
\end_layout

\begin_layout Plain Layout

        in >> H >> W;
\end_layout

\begin_layout Plain Layout

        for (int i = 0 ; i < H; i++)
\end_layout

\begin_layout Plain Layout

            for (int j = 0; j < W; j++)
\end_layout

\begin_layout Plain Layout

                in >> mappa[i][j];
\end_layout

\begin_layout Plain Layout

        soluzione = 10000000;
\end_layout

\begin_layout Plain Layout

        visita(0,0,0);
\end_layout

\begin_layout Plain Layout

        out << soluzione << endl;
\end_layout

\begin_layout Plain Layout

        cout << "Case #" << test << " finished" << endl;
\end_layout

\begin_layout Plain Layout

    }
\end_layout

\begin_layout Plain Layout

    return 0;
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Standard
L'algoritmo è tutto contenuto nella funzione ricorsiva 
\emph on
visita
\emph default
, definita alla riga 5, i cui primi due parametri rappresentano le coordinate
 della casella che viene visitata dal percorso corrente, mentre il terzo
 è il valore attuale del salto maggiore contenuto nel percorso che si sta
 esplorando.
 Le prime due istruzioni (righe 7-8) sono fondamentali per poter prendere
 una serie cospicua di punti: il loro scopo è quello di fermare la soluzione
 una volta che, percorrendo un sentiero, si arriva a una situazione nella
 quale un salto contenuto nel percorso è più alto della migliore soluzione
 finora trovata.
 Questo chiaramente indica che è inutile andare avanti a esplorare quel
 percorso e quindi la ricorsione viene terminata.
 Senza quelle due righe il programma riuscirebbe a eseguire solo il primo
 caso di test, che è su una matrice 5x5, e inoltre il risultato non sarebbe
 corretto perchè in 
\emph on
soluzione
\emph default
 verrebbe scritta il costo dell'ultimo percorso esplorato, che poco probabilment
e sarebbe quello corretto.
 
\end_layout

\begin_layout Standard
Le righe dalla 9 alla 13 implementano invece la condizione di terminazione
 della ricorsione che viene raggiunta quando il percorso arriva sulla casella
 di destinazione.
 L'assegnamento di 
\emph on
salto 
\emph default
a 
\emph on
soluzione 
\emph default
è determinato dal fatto che nelle righe precedenti si controllava già se
 
\emph on
salto
\emph default
 era maggiore o uguale a 
\emph on
soluzione
\emph default
 e nel caso si usciva, quindi a questo punto 
\emph on
salto
\emph default
 è per forza la 
\emph on
soluzione 
\emph default
temporanea
\emph on
.
\end_layout

\begin_layout Standard
La ricorsione vera e propria viene fatta nelle righe successive: per permettere
 il 
\emph on
backtracking 
\emph default
si tiene da parte il valore contenuto nella cella attuale, che dovrà successivam
ente essere reinserito, e lo sostituisce con un -1, in modo da evitare percorsi
 che ripassino più volte sulla stessa casella.
 
\end_layout

\begin_layout Standard
La struttura definita tra le righe 16 e 17 serve solo a permettere al ciclo
 
\emph on
for
\emph default
 di esplorare le quattro direzioni, poichè ogni elemento del vettore 
\emph on
direzioni
\emph default
 contiene una direzione (basso, destra, alto, sinistra) e quindi è possibile
 iterare sulle direzioni.
\end_layout

\begin_layout Standard
Detta a parole questa ricorsione funziona così:
\end_layout

\begin_layout Itemize
per ognuna delle quattro direzioni (riga 19)
\end_layout

\begin_deeper
\begin_layout Itemize
se la casella si trova all'interno della matrice (riga 22) e non è già contenuta
 nel percorso corrente (riga 23)
\end_layout

\begin_deeper
\begin_layout Itemize
se il salto maggiore visto fino a questo momento è maggiore del salto per
 spostarsi dalla casella 
\emph on
r,c
\emph default
 a quella 
\emph on
r+i, c+j
\emph default
, allora ci si sposta ricorsivamente in quella casella passando il valore
 di 
\emph on
salto
\end_layout

\begin_layout Itemize
altrimenti ci si sposta ricorsivamente in quella casella passando il valore
 assoluto della differenza tra le due caselle, perchè da questo momento
 è quello il valore di salto maggiore trovato 
\end_layout

\end_deeper
\end_deeper
\begin_layout Standard
Infine viene reinserito (riga 31) nella casella 
\emph on
r,c
\emph default
 il valore che in precedenza era stato sostituito con il -1, in modo da
 permettere ad altri rami della ricorsione di poter usare quella casella
 (quindi operare in 
\emph on
backtracking
\emph default
).
\end_layout

\begin_layout Standard
Come si diceva, il problema di questa soluzione, che pure è corretta, sta
 nel tempo impiegato per risolvere i casi di test: provando su esempi reali
 forniti dal sistema di correzione si può affermare che si riescono a prendere
 i primi 13 punti associati alla soluzione dei primi 13 casi di test, ma
 non oltre quelli
\begin_inset Foot
status collapsed

\begin_layout Plain Layout
Sulla mia macchina i primi 13 casi vengono risolti in meno di un secondo,
 mentre dopo 16 minuti il programma è stato terminato perchè ancora non
 si vedeva la soluzione del 14-esimo caso.
\end_layout

\end_inset

.
 
\end_layout

\begin_layout Standard
Si può notare nel codice che alla riga 50 è stata inserita un'istruzione
 per tenere traccia dei casi man mano che vengono risolti dal programma.
 Perchè questo può essere utile? Perchè, in un caso come questo, senza istruzion
i di stampa a video, potrebbe essere difficile capire se il programma sta
 risolvendo alcuni casi ma è lento, oppure contiene semplicemente un errore
 che lo porta a un ciclo infinito.
 Avendo invece questo input a video si può decidere di lasciare proseguire
 il programma e terminarlo solo quando si decide che non abbia più possibilità
 di risolvere altri casi di test.
 La terminazione del programma non 
\begin_inset Quotes eld
\end_inset

distrugge
\begin_inset Quotes erd
\end_inset

 la parte di file che contiene le soluzioni dei casi risolti, quindi poi
 lo si potrà sottoporre per prendere i punti meritati, e il sistema di correzion
e farà solo notare che mancano delle soluzioni, ma darà comunque un punteggio
 a quelle presenti.
\end_layout

\begin_layout Standard
Come ottenere tutti i 27 punti? L'idea è che, mentre si cerca la soluzione,
 ci si continua a imbattere in soluzioni parziali (ed eventualmente temporanee)
 del problema, che però possono essere usate per eliminare la maggior parte
 delle ricerche successive, in modo da rendere il tempo di risoluzione accettabi
le.
 
\end_layout

\begin_layout Standard
Ma cos'è una soluzione parziale? Definito il nostro problema generale come
 quello che prevede che il percorso finisca in 
\emph on
H-1, W-1
\emph default
 e che può essere scritto come 
\begin_inset Formula $P(H-1,W-1)$
\end_inset

, possiamo definire come sottoproblema quello che prevede che il percorso
 finisca in una generica casella 
\emph on
r, c
\emph default
, con 
\begin_inset Formula $r<H$
\end_inset

 e 
\begin_inset Formula $c<W$
\end_inset

, che quindi può essere scritto come 
\begin_inset Formula $P(r,c)$
\end_inset

.
 Siccome la soluzione del problema è solo un numero, si potrebbe pensare
 di memorizzare queste soluzioni ai vari sottoproblemi all'interno di una
 matrice 
\begin_inset Formula $HxW$
\end_inset

, dove nella casella in posizione 
\emph on
r, c
\emph default
 si trova la soluzione del sottoproblema 
\begin_inset Formula $P(r,c)$
\end_inset

, che può essere scritta come 
\begin_inset Formula $Sol(r,c)$
\end_inset

.
 Il vantaggio rispetto alla soluzione precedente è che, prima, la ricorsione
 veniva interrotta solo quando un percorso arrivava ad avere un salto maggiore
 o uguale alla migliore soluzione trovata fino a quel momento, adesso si
 può invece interrompere la ricorsione sul singolo percorso molto presto:
 basta che il percorso passi per una casella 
\emph on
r,c
\emph default
 il cui valore, che si ricorda essere il migliore finora trovato per il
 sottoproblema 
\begin_inset Formula $P(r,c)$
\end_inset

, sia inferiore a quello del percorso che si sta analizzando.
 Cerchiamo di chiarire con un esempio: siano H=20 e W = 20 e sia 
\begin_inset Formula $Sol(7,9)=17$
\end_inset

 la soluzione del sottoproblema 
\begin_inset Formula $P(7,9)$
\end_inset

 (cioè quella in cui un percorso termina in 7,9) e invece la soluzione globale
 migliore finora trovata sia 
\begin_inset Formula $Sol(19,19)=43$
\end_inset

 (cioè è stato scoperto ricorsivamente un percorso che arriva alla destinazione
 il cui salto peggiore è 43).
 Se la ricorsione sul percorso attuale arriva alla casella 7,9 e in quel
 momento il salto di quel percorso fosse 22, in questo nuovo algoritmo si
 esce dalla ricorsione e si smette di esplorare quel percorso, poichè sappiamo
 già che si potrebbe arrivare alla casella 7,9 con un percorso migliore
 e quindi non avremmo nessun vantaggio a partire da lì con un percorso che
 già ha un valore peggiore.
 Viceversa, nel primo algoritmo, il valore verrebbe confrontato solo con
 la soluzione ottima fino a quel momento, che in questo esempio abbiamo
 ipotizzato essere 43.
 Quindi la ricorsione proseguirebbe, magari anche molto a lungo e sicuramente
 non esplorerebbe percorsi utili alla ricerca della soluzione, perchè ognuno
 di essi avrebbe costo pari ad almeno 22, che è peggio di 17.
 
\end_layout

\begin_layout Standard
Questo guadagno è notevolissimo, considerando che, quanto prima si ferma
 la ricorsione, tanto maggiore è il guadagno in termini di operazioni non
 fatte.
 Difatti, considerando che ogni chiamata ricorsiva genera fino a 4 diverse
 chiamate, risulta evidente che se riusciamo a fermare un percorso ad esempio
 10 passaggi prima, si potrebbero salvare fino a 
\begin_inset Formula $4^{10}=1048576$
\end_inset

 chiamate ricorsive.
\end_layout

\begin_layout Standard
Il codice risulta il seguente, che si potrà notare essere molto simile a
 quello del primo algoritmo:
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "basicstyle={\small\ttfamily},frame=lr,language={C++},numbers=left,showstringspaces=false,tabsize=4"
inline false
status open

\begin_layout Plain Layout

int mappa[100][100];
\end_layout

\begin_layout Plain Layout

int soluzione[100][100];
\end_layout

\begin_layout Plain Layout

int H, W;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

void visita(int r, int c, int salto)
\end_layout

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

	if (r == H - 1 && c == W - 1)
\end_layout

\begin_layout Plain Layout

        return;
\end_layout

\begin_layout Plain Layout

    struct {
\end_layout

\begin_layout Plain Layout

		int i, j;
\end_layout

\begin_layout Plain Layout

	} direzioni[] = {{1,0},{0,1},{-1,0},{0,-1}};
\end_layout

\begin_layout Plain Layout

   for (int d = 0; d < 4; d++)
\end_layout

\begin_layout Plain Layout

    {
\end_layout

\begin_layout Plain Layout

		int i = direzioni[d].i, j = direzioni[d].j;		
\end_layout

\begin_layout Plain Layout

		if (r+i >= 0 && c+j >= 0 && r+i < H && c+j < W)
\end_layout

\begin_layout Plain Layout

			{
\end_layout

\begin_layout Plain Layout

				if (salto < abs(mappa[r][c] - mappa[r+i][c+j]))
\end_layout

\begin_layout Plain Layout

					salto = abs(mappa[r][c] - mappa[r+i][c+j]);
\end_layout

\begin_layout Plain Layout

				if (salto < soluzione[r+i][c+j])
\end_layout

\begin_layout Plain Layout

				{
\end_layout

\begin_layout Plain Layout

					soluzione[r+i][c+j] = salto;
\end_layout

\begin_layout Plain Layout

					visita(r+i,c+j, salto);
\end_layout

\begin_layout Plain Layout

				}
\end_layout

\begin_layout Plain Layout

			}
\end_layout

\begin_layout Plain Layout

	}
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

int main()
\end_layout

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

    ifstream in("input.txt");
\end_layout

\begin_layout Plain Layout

    ofstream out("output.txt");
\end_layout

\begin_layout Plain Layout

    int T;
\end_layout

\begin_layout Plain Layout

    in >> T;
\end_layout

\begin_layout Plain Layout

    for (int test = 1; test <= T; test++)
\end_layout

\begin_layout Plain Layout

    {
\end_layout

\begin_layout Plain Layout

        out << "Case #" << test << ": ";
\end_layout

\begin_layout Plain Layout

        in >> H >> W;
\end_layout

\begin_layout Plain Layout

        for (int i = 0 ; i < H; i++)
\end_layout

\begin_layout Plain Layout

            for (int j = 0; j < W; j++){
\end_layout

\begin_layout Plain Layout

                in >> mappa[i][j];
\end_layout

\begin_layout Plain Layout

				soluzione[i][j] = 10000000;
\end_layout

\begin_layout Plain Layout

			}
\end_layout

\begin_layout Plain Layout

        visita(0,0,0);
\end_layout

\begin_layout Plain Layout

        out << soluzione[H-1][W-1] << endl;
\end_layout

\begin_layout Plain Layout

        cout << "Case #" << test << " finished" << endl;
\end_layout

\begin_layout Plain Layout

    }
\end_layout

\begin_layout Plain Layout

    return 0;
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
La prima differenza è che sono scomparse le righe che controllano il salto
 corrente rispetto alla migliore soluzione finora trovata, poichè questo
 controllo avverrà qualche riga dopo, effettuando la verifica rispetto alla
 soluzione del sottoproblema 
\begin_inset Formula $P(r,c)$
\end_inset

.
\end_layout

\begin_layout Standard
La condizione di terminazione, se si è arrivati fino alla destinazione,
 prevede semplicemente che la ricorsione si fermi.
 Nella parte dove si esplorano le quattro caselle vicine (riga 12), evitando
 ovviamente di uscire dalla matrice (riga 15), prima si verifica se il nuovo
 salto da fare per arrivare alla casella 
\emph on
r+i, c+j
\emph default
 peggiora la situazione e, nel caso, si aggiorna il valore di 
\emph on
salto
\emph default
.
 Successivamente si prosegue con la ricorsione solo se il percorso attuale
 migliora 
\begin_inset Formula $Sol(r+i,c+j)$
\end_inset

, che è memorizzata nella matrice 
\emph on
soluzione[r+i][c+j]
\emph default
.
 Se si prosegue, solo allora si aggiorna anche 
\emph on
soluzione[r+i][c+j],
\emph default
 che, come detto in precedenza, è una soluzione parziale e temporanea e
 si continua con la ricorsione.
\end_layout

\begin_layout Standard
Quando la funzione 
\emph on
visita
\emph default
 avrà finito la ricorsione, la matrice 
\emph on
soluzione 
\emph default
conterrà in ogni casella 
\begin_inset Formula $Sol(r,c)$
\end_inset

, che è la soluzione del problema 
\begin_inset Formula $P(r,c)$
\end_inset

, quindi basterà stampare il contenuto della casella in posizione 
\emph on
H-1, W-1,
\emph default
 che è la soluzione del problema originale.
\end_layout

\begin_layout Standard
Così codificata questa soluzione, su una macchina virtuale appoggiata su
 un host Core i7, impiega 9 secondi per risolvere tutti e 27 i casi di test.
\end_layout

\end_body
\end_document
