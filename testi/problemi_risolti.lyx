#LyX 2.0 created this file. For more info see http://www.lyx.org/
\lyxformat 413
\begin_document
\begin_header
\textclass book
\begin_preamble
\date{}
\end_preamble
\use_default_options false
\master guida.lyx
\maintain_unincluded_children true
\language italian
\language_package default
\inputencoding auto
\fontencoding global
\font_roman palatino
\font_sans helvet
\font_typewriter courier
\font_default_family default
\use_non_tex_fonts false
\font_sc false
\font_osf false
\font_sf_scale 100
\font_tt_scale 100

\graphics default
\default_output_format default
\output_sync 0
\bibtex_command default
\index_command default
\paperfontsize default
\spacing single
\use_hyperref false
\papersize a4paper
\use_geometry true
\use_amsmath 1
\use_esint 1
\use_mhchem 1
\use_mathdots 1
\cite_engine basic
\use_bibtopic false
\use_indices false
\paperorientation portrait
\suppress_date false
\use_refstyle 0
\index Indice
\shortcut idx
\color #008000
\end_index
\leftmargin 3cm
\topmargin 3cm
\rightmargin 3cm
\bottommargin 3cm
\secnumdepth 3
\tocdepth 3
\paragraph_separation indent
\paragraph_indentation default
\quotes_language english
\papercolumns 1
\papersides 1
\paperpagestyle default
\tracking_changes false
\output_changes false
\html_math_output 0
\html_css_as_file 0
\html_be_strict false
\end_header

\begin_body

\begin_layout Chapter
Problemi risolti
\end_layout

\begin_layout Standard
In questo capitolo sono inseriti tutti i problemi territoriali
\begin_inset Foot
status collapsed

\begin_layout Plain Layout
Non viene affrontato il problema denominato 
\begin_inset Quotes eld
\end_inset

La poltrona di Korrot
\begin_inset Quotes erd
\end_inset

 perché la formulazione risulta noiosa e complessa.
\end_layout

\end_inset

 non trattati negli esempi visti in precedenza, con suggerimenti per la
 soluzione e la soluzione stessa con spiegazioni.
 I suggerimenti vengono posti sotto forma di domande per sollecitare la
 riflessione e mostrare aspetti del problema che potrebbero non essere immediata
mente evidenti, oltre che per sviluppare osservazioni magari non direttamente
 applicabili al problema, ma che potrebbero essere d'aiuto in altri.
 Quindi si consiglia di leggere le domande una ad una, verificare mentalmente
 quanto proposto ed eventualmente implementarlo e solo alla fine procedere
 alla soluzione personale del problema, per poi sottoporlo al correttore
 automatico (vedi 
\begin_inset CommandInset ref
LatexCommand ref
reference "sec:Il-correttore"

\end_inset

) e infine passare ad un confronto con la soluzione proposta, individuandone
 le differenze per poterne trarre vantaggio in altri problemi.
\end_layout

\begin_layout Section
Codice segreto - territoriali 2005
\end_layout

\begin_layout Standard
\begin_inset Box Framed
position "t"
hor_pos "c"
has_inner_box 0
inner_pos "t"
use_parbox 0
use_makebox 0
width "100col%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout Subsection*
Codice segreto (codice) 
\end_layout

\begin_layout Subsubsection*
Difficoltà D = 1 
\end_layout

\begin_layout Subsubsection*
Descrizione del problema
\end_layout

\begin_layout Plain Layout
Chicco e Spillo comunicano con dei messaggi scritti in codice per non essere
 scoperti.
 Il loro codice funziona così: ogni vocale è rappresentata con la vocale
 successiva in ordine alfabetico, e ogni consonante con la consonante successiva.
 La Y, che è l'ultima vocale, è rappresentata in codice dalla A, che è la
 prima vocale.
 Allo stesso modo, la Z è rappresentata in codice dalla B.
 Per le cifre il discorso è simile: ogni cifra è rappresentata dalla successiva,
 e 9 è rappresentato da 0.
 
\end_layout

\begin_layout Plain Layout
Il codice mantiene la distinzione maiuscole/minuscole.
 Gli spazi e i segni d'interpunzione (compresi gli accenti) non sono modificati
 dal codice segreto.
\end_layout

\begin_layout Plain Layout
Aiutiamo Chicco e Spillo scrivendo un programma per codificare i loro messaggi!
\end_layout

\begin_layout Subsubsection*
Dati di input
\end_layout

\begin_layout Plain Layout
Il file input.txt contiene un intero N nella prima riga.
 Le successive N righe contengono del testo in chiaro, con al più 80 caratteri
 per riga.
 
\end_layout

\begin_layout Subsubsection*
Dati di output
\end_layout

\begin_layout Plain Layout
Il programma, leggendo il file di input, deve scrivere in output N righe
 contenenti il corrispondente testo in codice.
 
\end_layout

\begin_layout Subsubsection*
Assunzioni
\end_layout

\begin_layout Itemize
Il testo in input è composto soltanto da lettere, cifre e segni d'interpunzione.
 
\end_layout

\begin_layout Itemize
Non ci sono caratteri accentati: al posto degli accenti, si usano gli apostrofi.
 
\end_layout

\begin_layout Itemize
Ogni riga di testo contiene al più 80 caratteri in formato ASCII.
 
\end_layout

\begin_layout Itemize
L'alfabeto è quello esteso a 26 lettere: A B C D E F G H I J K L M N O P
 Q R S T U V W X Y Z.
 
\end_layout

\begin_layout Itemize
Le vocali sono A E I O U Y.
 Tutte le altre lettere sono consonanti.
 
\end_layout

\begin_layout Subsubsection*
Esempi di input/output
\end_layout

\begin_layout Plain Layout
\begin_inset Tabular
<lyxtabular version="3" rows="2" columns="2">
<features tabularvalignment="middle">
<column alignment="center" valignment="top" width="2.5in">
<column alignment="center" valignment="top" width="2.7in">
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
File input.txt
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
File output.txt
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\align left
2 
\end_layout

\begin_layout Plain Layout
\align left
Il cellulare di Elena e' 338-4189961.
 
\end_layout

\begin_layout Plain Layout
\align left
Ti aspetta alla stazione alle 8, VAI!
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\align left
Om dimmymesi fo Imipe i' 449-5290072.
 
\end_layout

\begin_layout Plain Layout
\align left
Vo etqivve emme tveboupi emmi 9, WEO!
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Suggerimenti
\end_layout

\begin_layout Standard
Il problema chiede di ricodificare una stringa di caratteri secondo certe
 regole spiegate nel testo.
\end_layout

\begin_layout Itemize
Sai come sono rappresentati i caratteri a basso livello (ti dice qualcosa
 il termine codice ASCII)?
\end_layout

\begin_layout Itemize
Sai leggere una stringa di caratteri in input (non capita spesso in questi
 problemi)?
\end_layout

\begin_layout Itemize
Sai come memorizzare una stringa di caratteri in C o in C++?
\end_layout

\begin_layout Itemize
Conviene leggere le strighe una a una e effettuare le trasformazioni alla
 fine di ogni lettura o farle carattere per carattere?
\end_layout

\begin_layout Itemize
É possibile applicare una banale trasformazione a tutti i caratteri 
\begin_inset Quotes eld
\end_inset

spostandoli
\begin_inset Quotes erd
\end_inset

 di una posizione in avanti per ottenere il codice desiderato? Sembrerebbe
 di no.
\end_layout

\begin_layout Itemize
Se non è possibile applicare la semplice trasformazione indicata sopra è
 perchè ogni gruppo di caratteri (vocali, consonanti, numeri e altri segni)
 deve essere trattato in maniera separata.
 Sai come è possibile discriminare un carattere di un gruppo dagli altri?
 Esistono delle funzioni di libreria che possono aiutare?
\end_layout

\begin_layout Itemize
Il codice deve mantenere la distinzione tra maiuscole e minuscole: conviene
 fare due codifiche diverse a seconda che il carattere sia minuscolo o maiuscolo
 oppure si può fare in un altro modo?
\end_layout

\begin_layout Subsection
Soluzione
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "basicstyle={\small\ttfamily},breaklines=true,frame=lr,language=C,numbers=left,showstringspaces=false,tabsize=4"
inline false
status open

\begin_layout Plain Layout

int N; 
\end_layout

\begin_layout Plain Layout

char buffer[100]; 
\end_layout

\begin_layout Plain Layout

char vocali[]="aeiouy"; 
\end_layout

\begin_layout Plain Layout

char vocaliCambiate[]="eiouya"; 
\end_layout

\begin_layout Plain Layout

char consonanti[]="bcdfghjklmnpqrstvwxz"; 
\end_layout

\begin_layout Plain Layout

char consonantiCambiate[]="cdfghjklmnpqrstvwxzb";
\end_layout

\begin_layout Plain Layout

int vocale(char c) {     
\end_layout

\begin_layout Plain Layout

return (c=='a' || c=='e' || c=='i' || c=='o' || c=='u' || c=='y'); 
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

char traduciVocali(char c) {     
\end_layout

\begin_layout Plain Layout

	int i;     
\end_layout

\begin_layout Plain Layout

	for (i=0; i<6; i++)         
\end_layout

\begin_layout Plain Layout

		if (c==vocali[i]) return vocaliCambiate[i]; 
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

char traduciConsonanti(char c) {     
\end_layout

\begin_layout Plain Layout

	int i;     
\end_layout

\begin_layout Plain Layout

	for (i=0; i<20; i++)         
\end_layout

\begin_layout Plain Layout

		if (c==consonanti[i]) return consonantiCambiate[i]; 
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

int main() 
\end_layout

\begin_layout Plain Layout

{     
\end_layout

\begin_layout Plain Layout

	FILE *in, *out; 	
\end_layout

\begin_layout Plain Layout

	int i,j;     
\end_layout

\begin_layout Plain Layout

	in=fopen("input.txt","r");     
\end_layout

\begin_layout Plain Layout

	out=fopen("output.txt","w");     
\end_layout

\begin_layout Plain Layout

	fscanf(in,"%d",&N); 	
\end_layout

\begin_layout Plain Layout

	fgets(buffer,81,in);     
\end_layout

\begin_layout Plain Layout

	for (j=0; j<N; j++)     
\end_layout

\begin_layout Plain Layout

	{         
\end_layout

\begin_layout Plain Layout

		fgets(buffer,81,in);         
\end_layout

\begin_layout Plain Layout

		for (i=0;buffer[i]!='
\backslash
0';i++)         
\end_layout

\begin_layout Plain Layout

		{             
\end_layout

\begin_layout Plain Layout

			int flag=0;             
\end_layout

\begin_layout Plain Layout

			char temp, c=tolower(buffer[i]);
\end_layout

\begin_layout Plain Layout

            if (c!=buffer[i]) flag=1;             
\end_layout

\begin_layout Plain Layout

			if (isalpha(c))             
\end_layout

\begin_layout Plain Layout

			{                 
\end_layout

\begin_layout Plain Layout

				if (vocale(c)) temp=traduciVocali(c);                
\end_layout

\begin_layout Plain Layout

				else temp=traduciConsonanti(c);
\end_layout

\begin_layout Plain Layout

				if (flag) temp=toupper(temp);
\end_layout

\begin_layout Plain Layout

				fprintf(out,"%c",temp);             
\end_layout

\begin_layout Plain Layout

			}             
\end_layout

\begin_layout Plain Layout

			else if (isdigit(c)) fprintf(out,"%d",((c-'0')+1)%10);   
\end_layout

\begin_layout Plain Layout

			else fprintf(out,"%c",c);         
\end_layout

\begin_layout Plain Layout

		}     
\end_layout

\begin_layout Plain Layout

	}                 
\end_layout

\begin_layout Plain Layout

	return 0; 
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
La soluzione è piuttosto semplice, in questo esercizio forse le difficoltà
 maggiori risiedono nella lettura dell'input: il creatore del testo fornendo
 l'input in quel modo, con l'intero che indica il numero di righe, ha forse
 pensato di rendere più semplice la successiva lettura, ma a causa del modo
 in cui il C gestisce l'input questo causa più problemi che altro.
 Dopo aver letto con la 
\emph on
fscanf
\emph default
 (riga 26) il numero di righe, rimane nel buffer di input un 
\begin_inset Quotes eld
\end_inset

a capo
\begin_inset Quotes erd
\end_inset

, che deve essere tolto per permettere la lettura della riga successiva:
 a questo proposito viene usata la 
\emph on
fgets
\emph default

\begin_inset Foot
status collapsed

\begin_layout Plain Layout
Non viene usata la più usuale 
\emph on
fscanf
\emph default
, poichè nella lettura di stringhe lo spazio verrebbe interpretato come
 terminatore di lettura, spezzando le frasi prima del loro termine naturale.
\end_layout

\end_inset

, che alla riga 27 ha l'unico scopo di eliminare il ritorno a capo e che
 successivamente verrà invece usata per leggere ogni riga.
 Una volta letta una riga e inserita in un buffer si tratta semplicemente
 di scorrerla e applicare le regole del problema ad ogni singolo carattere.
 
\end_layout

\begin_layout Standard
Per le trasformazioni delle lettere sono state create delle stringhe (righe
 3-6) che fungono da 
\begin_inset Quotes eld
\end_inset

mappa
\begin_inset Quotes erd
\end_inset

 per passare dalla lettera originale a quella codificata, in modo molto
 semplice: si cerca nella stringa originale la posizione della lettera da
 convertire e poi si cerca nella stringa che rappresenta la codifica la
 lettera in quella stessa posizione.
 Per i numeri non si fa altro che sommare 1, avendo l'accortezza di usare
 l'operatore di modulo per gestire la trasformazione della cifra 9 e tutto
 quello che avanza viene ristampato così com'è (tra le altre cose anche
 il ritorno a capo viene letto dalla 
\emph on
gets
\emph default
 e ristampato in output).
\end_layout

\begin_layout Standard
La complessità in questo esercizio non costituisce un problema, perché è
 evidente che si tratta di un algoritmo lineare, in quanto scorre ogni riga
 senza mai tornare indietro, e quindi potrebbe gestire senza problemi anche
 input molto grossi.
\end_layout

\begin_layout Section
Il nobile chimico - territoriali 2005
\end_layout

\begin_layout Standard
\begin_inset Box Framed
position "t"
hor_pos "c"
has_inner_box 0
inner_pos "t"
use_parbox 0
use_makebox 0
width "100col%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout Subsection*
Il nobile chimico (chimico) 
\end_layout

\begin_layout Subsubsection*
Difficoltà  D = 2 
\end_layout

\begin_layout Plain Layout
Il problema Il nobile chimico Alfredo produce nel suo laboratorio due sostanze
 liquide potenzialmente inquinanti: l'Aminozalina e il Brinofulo.
 A fine giornata le deve smaltire in appositi contenitori, dislocati lungo
 il tragitto che parte dal laboratorio e arriva alla sua abitazione.
 Per limitare le possibilità  d'inquinamento, Alfredo deve distribuire l'Aminoza
lina nel maggior numero possibile di contenitori mentre deve dividere il
 Brinofulo nel minor numero possibile di contenitori.
 Tuttavia Aminozalina e Brinofulo non possono essere assolutamente mescolati
 nel medesimo contenitore, altrimenti la loro miscela esplode.
 Ogni volta che raggiunge un contenitore per lo smaltimento dei liquidi,
 Alfredo deve eseguire una sola delle tre seguenti azioni: 
\end_layout

\begin_layout Plain Layout
(i) versare Aminozalina fino al riempimento del contenitore; 
\end_layout

\begin_layout Plain Layout
(ii) versare Brinofulo fino al riempimento del contenitore; 
\end_layout

\begin_layout Plain Layout
(iii) non versare nulla nel contenitore.
 
\end_layout

\begin_layout Plain Layout
Data la quantità  A di litri di Aminozalina e la quantità  B di litri di
 Brinofulo da smaltire, e conoscendo l'elenco degli N contenitori (con rispettiv
a capacità) nell'ordine secondo cui sono incontrati lungo il tragitto dal
 laboratorio alla sua abitazione, Alfredo deve decidere se e quale sostanza
 versare in ciascun contenitore.
 
\end_layout

\begin_layout Subsubsection*
Dati di input 
\end_layout

\begin_layout Plain Layout
Il file input.txt contiene nella prima riga gli interi A e B (rispettivamente
 i litri di Aminozalina e di Brinofulo da smaltire) e il numero N di contenitori
 disponibili.
 Tali valori sono separati da uno spazio.
 Nelle successive N righe (usando una riga per ogni contenitore) è contenuto
 un numero per riga: tali numeri rappresentano le capacità  dei singoli
 contenitori elencati nell'ordine in cui vengono incontrati da Alfredo.
 
\end_layout

\begin_layout Subsubsection*
Dati di output 
\end_layout

\begin_layout Plain Layout
Il file output.txt deve contenere N righe, una per ogni contenitore.
 Ogni riga contiene due numeri separati da uno spazio, rispettivamente il
 numero di litri di Aminozalina e di Brinofulo smaltiti nel corrispondente
 contenitore.
 Si noti che ogni riga deve contenere uno zero nei casi (i) e (ii) descritti
 sopra, e due zeri nel caso (iii).
 
\end_layout

\begin_layout Subsubsection*
Assunzioni 
\end_layout

\begin_layout Itemize
1 < A, B < 10000 
\end_layout

\begin_layout Itemize
1 < N < 100 
\end_layout

\begin_layout Itemize
Le singole capacità  dei contenitori sono degli interi positivi di valore
 inferiore a 10000.
 
\end_layout

\begin_layout Itemize
Le capacità  dei contenitori sono sicuramente sufficienti per smaltire tutta
 l'Aminozalina e il Brinofulo prodotti.
 
\end_layout

\begin_layout Itemize
I dati in input garantiscono l'esistenza di una (e una sola) soluzione ottima,
 quindi Alfredo ha un unico modo ottimo per smaltire le sostanze.
 
\end_layout

\begin_layout Itemize
La soluzione ottima prevede che tutti i contenitori utilizzati vengano riempiti
 completamente (non puo' succedere che l'Aminozalina o il Brinofulo terminino
 prima che i contenitori effettivamente usati per lo smaltimento siano tutti
 completamente riempiti).
 
\end_layout

\begin_layout Subsubsection*
Esempi di input/output 
\end_layout

\begin_layout Plain Layout
\begin_inset Tabular
<lyxtabular version="3" rows="2" columns="2">
<features tabularvalignment="middle">
<column alignment="left" valignment="top" width="1in">
<column alignment="left" valignment="top" width="1.5in">
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
File input.txt
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
File output.txt 
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
20 25 7 
\end_layout

\begin_layout Plain Layout
1 
\end_layout

\begin_layout Plain Layout
13 
\end_layout

\begin_layout Plain Layout
4 
\end_layout

\begin_layout Plain Layout
5 
\end_layout

\begin_layout Plain Layout
8 
\end_layout

\begin_layout Plain Layout
2 
\end_layout

\begin_layout Plain Layout
12
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
1 0 
\end_layout

\begin_layout Plain Layout
0 13 
\end_layout

\begin_layout Plain Layout
4 0 
\end_layout

\begin_layout Plain Layout
5 0 
\end_layout

\begin_layout Plain Layout
8 0 
\end_layout

\begin_layout Plain Layout
2 0 
\end_layout

\begin_layout Plain Layout
0 12 
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Suggerimenti
\end_layout

\begin_layout Standard
Il problema richiede di scorrere un vettore di numeri e vedere se soddisfano
 alcune condizioni.
\end_layout

\begin_layout Itemize
Ti sembra un problema greedy?
\end_layout

\begin_layout Itemize
Puoi provare che lo è?
\end_layout

\begin_layout Itemize
La prova vale sia per l'Aminozalina che per il Brinofulo, solo per uno dei
 due o per entrambi?
\end_layout

\begin_layout Itemize
Supposto che il problema sia greedy, ti basta un solo ordinamento o sono
 necessari due ordinamenti diversi per le due sostanze?
\end_layout

\begin_layout Itemize
Se riordini i bidoni, sei poi in grado di stampare la soluzione?
\end_layout

\begin_layout Subsection
Soluzione
\end_layout

\begin_layout Standard
C'è un consenso unanime da parte dei responsabili territoriali
\begin_inset Foot
status open

\begin_layout Plain Layout
Almeno questo è ciò che ricordo, ma la discussione sul problema è avvenuta
 nel 2011, il problema è del 2005 e questa revisione che sto facendo è del
 2013, quindi potrei ricordare cose sbagliate.
 Nel caso, come per tutto quello che scrivo, gli eventuali errori sono solo
 da imputarsi a me.
\end_layout

\end_inset

 che la stesura del testo non rispecchi esattamente l'intenzione dell'ideatore,
 che voleva si usasse un approccio greedy, cosa che è dimostrata dal fatto
 che il correttore da il massimo punteggio alle soluzioni di tipo greedy.
 Siccome però non c'è nessuna evidenza sicura che sia così se non i risultati
 che da il correttore, si mostreranno due soluzioni, una semplice che usa
 un approccio greedy, ma che in generale potrebbe dare risultati scorretti,
 l'altra, più complessa, che dovrebbe dare risultati giusti.
 
\end_layout

\begin_layout Subsubsection*
Soluzione greedy
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "basicstyle={\small\ttfamily},breaklines=true,frame=lr,language={C++},numbers=left,showstringspaces=false,tabsize=4"
inline false
status collapsed

\begin_layout Plain Layout

int A; //Aminozalina 
\end_layout

\begin_layout Plain Layout

int B; //Brinofulo 
\end_layout

\begin_layout Plain Layout

int N; //numero di contenitori
\end_layout

\begin_layout Plain Layout

struct bidone {     
\end_layout

\begin_layout Plain Layout

	int posizione;     
\end_layout

\begin_layout Plain Layout

	int capacita;     
\end_layout

\begin_layout Plain Layout

	int riempito; //0 = vuoto, 1 = Aminozalina 2 = Brinofulo 
\end_layout

\begin_layout Plain Layout

};
\end_layout

\begin_layout Plain Layout

bidone bidoni[100];
\end_layout

\begin_layout Plain Layout

int compare_posizione(const void *a, const void *b) {   
\end_layout

\begin_layout Plain Layout

	bidone ba = *(const bidone *) a;   
\end_layout

\begin_layout Plain Layout

	bidone bb = *(const bidone *) b;
\end_layout

\begin_layout Plain Layout

	return (ba.posizione > bb.posizione) - (ba.posizione < bb.posizione);
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

int compare_capacita(const void *a, const void *b) {   
\end_layout

\begin_layout Plain Layout

	bidone ba = *(const bidone *) a;   
\end_layout

\begin_layout Plain Layout

	bidone bb = *(const bidone *) b;
\end_layout

\begin_layout Plain Layout

	return (ba.capacita > bb.capacita) - (ba.capacita < bb.capacita); 
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

int main() 
\end_layout

\begin_layout Plain Layout

{     
\end_layout

\begin_layout Plain Layout

	fstream in,out;     
\end_layout

\begin_layout Plain Layout

	in.open("input.txt",ios::in);     	out.open("output.txt",ios::out);     
\end_layout

\begin_layout Plain Layout

	in >> A >> B >> N;     
\end_layout

\begin_layout Plain Layout

	for (int i=0; i<N; i++){         
\end_layout

\begin_layout Plain Layout

		bidoni[i].posizione=i;         
\end_layout

\begin_layout Plain Layout

		in >> bidoni[i].capacita;         
\end_layout

\begin_layout Plain Layout

		bidoni[i].riempito=0;     
\end_layout

\begin_layout Plain Layout

	}
\end_layout

\begin_layout Plain Layout

	qsort(bidoni,N,sizeof(bidone),compare_capacita);     
\end_layout

\begin_layout Plain Layout

	for (int i=0; i<N && A > 0;i++){         
\end_layout

\begin_layout Plain Layout

		A-=bidoni[i].capacita;         
\end_layout

\begin_layout Plain Layout

		bidoni[i].riempito=1;     
\end_layout

\begin_layout Plain Layout

	}
\end_layout

\begin_layout Plain Layout

	for (int i=N-1; i>=0 && B > 0; i--){         
\end_layout

\begin_layout Plain Layout

		if (B >= bidoni[i].capacita){             
\end_layout

\begin_layout Plain Layout

			B-=bidoni[i].capacita;             
\end_layout

\begin_layout Plain Layout

			bidoni[i].riempito=2;         
\end_layout

\begin_layout Plain Layout

		}     
\end_layout

\begin_layout Plain Layout

	}      
\end_layout

\begin_layout Plain Layout

	qsort(bidoni,N,sizeof(bidone),compare_posizione);     
\end_layout

\begin_layout Plain Layout

	for (int i=0; i<N ; i++)         
\end_layout

\begin_layout Plain Layout

		if (bidoni[i].riempito == 0)             
\end_layout

\begin_layout Plain Layout

			out << "0 0" << endl;         
\end_layout

\begin_layout Plain Layout

		else if(bidoni[i].riempito == 1)
\end_layout

\begin_layout Plain Layout

        	out << bidoni[i].capacita << " 0" << endl;         
\end_layout

\begin_layout Plain Layout

		else             
\end_layout

\begin_layout Plain Layout

			out << "0 " << bidoni[i].capacita << endl;     
\end_layout

\begin_layout Plain Layout

	return 0; 
\end_layout

\begin_layout Plain Layout

} 
\end_layout

\end_inset

Sia per l'Aminozalina che per il Brinofulo, date le condizioni del problema,
 non è detto che iniziando a svuotarli in modo greedy, a partire cioè dal
 contenitore meno capiente per l'Aminozalina o dal più capiente per il Brinofulo
 si arrivi alla soluzione ottima.
 Volendo vedere un controesempio supponiamo di avere 30 litri di Brinofluoro
 e avere la sequenza di contenitori, già ordinati, fatta così: 21 10 10
 10 3 3 3.
 Svuotando il Brinofulo nel primo contenitore dovrei poi usare i tre contenitori
 con capienza 3 litri, non potendo riempire completamente quelli da 10,
 arrivando così ad usare 4 recipienti.
 Se invece non avessi svuotato il Brinofulo nel primo contenitore, poi avrei
 potuto svuotarlo nei tre successivi, usando complessivamente solo 3 contenitori.
\end_layout

\begin_layout Standard
Chiarito questo fatto guardiamo la soluzione greedy, che come già detto
 permette di arrivare al punteggio massimo.
 almeno sul correttore online.
 Il primo passo per affrontare il problema consiste nell'ordinare la sequenza
 dei contenitori in base alla loro capacità, per poi svuotare il Brinofulo
 a partire da quello più grande e l'Aminozalina a partire da quello più
 piccolo.
 Il problema è che, per come viene richiesto di stampare l'output, abbiamo
 necessità di ricordarci la loro collocazione originale: un modo per risolvere
 questo problema è quello di memorizzare all'interno di una struttura (righe
 4-8) sia la capacità del bidone, che la sua posizione originale, che il
 tipo di sostanza che eventualmente è stata versata dentro.
 In questo modo possiamo ordinare il vettore dei contenitori per capienza
 così da poter applicare l'algoritmo greedy nei due sensi e successivamente
 riordinare per posizione originale, avendo salvato nella variabile 
\emph on
riempito
\emph default
 il tipo di sostanza che vi è stata versata dentro (oppure se non vi è stato
 versato nulla).
 A questo proposito basta semplicemente definire due funzioni, 
\emph on
compare_posizione
\emph default
 (riga 10) e 
\emph on
compare_capacita
\emph default
 (riga 15) che se utilizzate nell'algoritmo 
\emph on
qsort
\emph default
 riordinano il vettore o per capienza (riga 31) o per posizione originale
 (riga 42).
\end_layout

\begin_layout Standard
La parte greedy della soluzione è poi semplice: per l'Aminozalina è sufficiente
 scorrere i contenitori a partire dal più piccolo e riempirli finché c'è
 della sostanza da smaltire (righe 32-35), mentre per il Brinofulo bisogna
 anche controllare se la sostanza da smaltire riempie completamente il contenito
re (riga 37), altrimenti bisogna passare al bidone successivo (potrebbe
 anche essere che questo passaggio non serva a niente, dipende da come sono
 stati creati i dati in ingresso).
\end_layout

\begin_layout Standard
Infine, dopo aver riordinato i bidoni per rimetterli nella sequenza originale,
 si scorrono tutti per stampare il loro stato attuale (righe 43-49).
\end_layout

\begin_layout Subsubsection*
Soluzione dinamica
\end_layout

\begin_layout Standard
La soluzione dinamica è decisamente più complessa
\begin_inset Foot
status open

\begin_layout Plain Layout
Decisamente troppo complessa a mio modo di vedere per il livello del problema,
 il che supporta la tesi che l'autore del problema volesse portare gli studenti
 a implementare la versione greedy.
\end_layout

\end_inset

, ma come idea fondamentale si basa sullo stesso principio che era già stato
 illustrato nel problema di Lino il giornalaio (vedi 
\begin_inset CommandInset ref
LatexCommand ref
reference "sec:Esempio:-Lino"

\end_inset

): dopo aver ordinato i bidoni si costruiscono le sottosoluzioni per ogni
 quantità possibile di sostanza, considerando che se conosco la soluzione
 per una data quantità 
\emph on
k
\emph default
 ottima avendo a disposizione i barili da 
\emph on
0
\emph default
 a 
\emph on
j-1
\emph default
, aggiungendo il barile 
\emph on
j-esim
\emph default
o avrò la soluzione ottima per la quantità 
\emph on
k + capacità del barile j-esimo.
\end_layout

\begin_layout Standard
Ovviamente questo approccio si può usare sia per l'Aminozalina che per il
 Brinofulo, modificando opportunamente il controllo che viene fatto per
 verificare la soluzione ottima, dal momento che in un caso interessa usare
 meno bidoni possibili, mentre nell'altro il numero maggiore possibile.
 Premetto che in tutto quello che si dirà di seguito si suppone che le due
 soluzioni, per l'Aminozalina e il Brinofulo, siano disgiunte, cioè non
 ci sono bidoni che fanno parte della soluzione ottima sia per una sostanza
 che per l'altra: nel testo questo non è detto, ma sembra una supposizione
 ragionevole, considerando anche il fatto che se si verificasse ciò il testo
 del problema non definisce cosa sia l'ottimo.
\end_layout

\begin_layout Standard
Per comprendere la soluzione meglio analizziamo tramite dei grafici alcuni
 casi d'esempio, partendo da una situazione semplice per poi complicarla
 in modo da renderla più generale.
 Gli esempi prenderanno in considerazione solo il problema di avere meno
 bidoni possibile, ma come si vedrà nel codice proposto l'idea è esattamente
 la stessa se si volesse avere il maggior numero di bidoni.
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement h
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename ../materiali/problemi territoriali/2005_chimico/dinamica.eps
	display false
	scale 50

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:Esempio-1-chimico"

\end_inset

Esempio con 4 bidoni diversi
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
La figura 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:Esempio-1-chimico"

\end_inset

 mostra un caso con quattro bidoni, di capacità rispettivamente 1, 2, 3
 e 4.
 Per ogni sottoproblema viene aggiornata la tabella, dove nella prima riga
 compare la casella da cui si è partiti per arrivare alla soluzione (serve
 per poi poter ricostruire la soluzione), nella seconda il numero di bidoni
 che occorrono per arrivare a quella soluzione e nella terza la quantità
 di liquido che si riesce a smaltire.
 Aggiornare la tabella è semplice, almeno apparentemente: 
\end_layout

\begin_layout Itemize
dato il bidone 
\emph on
j
\emph default
 di capacità 
\emph on
k
\emph default
,
\end_layout

\begin_deeper
\begin_layout Itemize
per ogni casella a partire dalla quantità 
\emph on
k
\emph default
 fino alla somma di tutti i bidoni visti in precedenza, compreso l'attuale,
 si aggiorna la soluzione della casella corrente 
\emph on
i
\emph default
 verificando se porta a una soluzione migliore, cioè se (soluzione per il
 problema
\emph on
 i-k
\emph default
) + 1 è migliore di quando già scoperto per la casella 
\emph on
i
\emph default
 (nel caso non ci fosse niente è sicuramente migliore)
\end_layout

\end_deeper
\begin_layout Standard
Guardiamo ad esempio la terza tabella, quella per il sottoproblema con 3
 bidoni, in cui si parte dalla casella 3 (capacità del nuovo bidone) e si
 arriva fino alla casella 6 (somma delle capacità di tutti i bidoni)
\end_layout

\begin_layout Itemize
casella 3: fino a questo momento la soluzione era con 2 bidoni (la somma
 del primo con il secondo), però vedo che la soluzione per la casella 0
 (cioè i-k) + 1 è migliore e quindi scrivo 1 nella casella 3.
\end_layout

\begin_layout Itemize
casella 4: non è stata ancora esplorata, quindi la soluzione è sicuramente
 ottima e vale (soluzione della casella 1) + 1, cioè 2
\end_layout

\begin_layout Itemize
casella 5: come sopra
\end_layout

\begin_layout Itemize
casella 6: come sopra (ma attenzione...)
\end_layout

\begin_layout Standard
A differenza del problema di Lino, in questo problema i bidoni possono essere
 usati esattamente una volta, il che può portare a dei problemi, come evidenziat
o in figura e nella discussione appena fatta sull'esempio.
 Davvero la quantità di liquido 6 può essere smaltita con due bidoni, nel
 sottoproblema di dimensione 3? In realtà no, perchè il risultato della
 casella 3 è stato ottenuto usando il bidone 3, che non può essere riutilizzato
 una seconda volta.
 Come risolvere, dal momento che comunque esiste una soluzione per la quantità
 6 nel sottoproblema con 3 bidoni? Potrei verificare che se il barattolo
 usato in una soluzione precedente ha la stessa dimensione di quello con
 cui sto aggiornando allora non posso usarlo, a meno che non esistesse in
 precedenza una soluzione peggiore che però non faceva uso di quel barattolo,
 come in effetti succede in questo esempio.
 
\end_layout

\begin_layout Standard
Da qui in poi entro in quella che solitamente con i miei allievi chiamo
 la modalità 
\begin_inset Quotes eld
\end_inset

ginepraio
\begin_inset Quotes erd
\end_inset

, cioè il problema inizia a sfuggire di mano e non si sa dove possa andare
 a finire, quindi quello che dirò va un po' preso con le molle.
 
\end_layout

\begin_layout Standard
La soluzione potrebbe essere quella di ricordare non solo la soluzione ottima
 ma anche, se presente, la soluzione precedente (non ne servono altre perchè
 per come viene fatto l'aggiornamento se non posso usare un bidone perchè
 è già stato usato sicuramente l'altra soluzione non lo usa).
 Quindi, se in ogni casella tengo la soluzione ottima e quella precedente,
 in una situazione come quella descritta faccio questo controllo:
\end_layout

\begin_layout Enumerate
se la soluzione ottima non contiene il bidone che sto aggiornando, uso quella
\end_layout

\begin_layout Enumerate
se la soluzione ottima contiene il bidone che sto aggiornando, ma ne esiste
 un'altra, allora posso usare l'altra.
\end_layout

\begin_layout Standard
Così, a patto di complicare la struttura dati di supporto, posso gestire
 situazioni come quelle mostrate.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename ../materiali/problemi territoriali/2005_chimico/dinamica-2.eps
	display false
	scale 50

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:Esempio-con-barili-doppi"

\end_inset

Esempio con barili doppi
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
C'è però un altro problema evidenziato dalla figura 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:Esempio-con-barili-doppi"

\end_inset

: ci possono essere più barili con la stessa capacità, quindi se faccio
 un controllo come spiegato al punto 2, nel sottoproblema con due bidoni
 non riuscirei a aggiornare la soluzione con la capacità 6, perchè troverei
 che la soluzione con capacità 3 usa già un bidone della stessa capacità
 e non ha una soluzione alternativa: per risolvere questo problema è stato
 usato un flag che memorizza se lo specifico bidone, al di là della sua
 capacità, è già stato usato un'altra volta e questo permette di gestire
 anche la presenza di casi con barili che si ripetono n-volte.
\end_layout

\begin_layout Standard
Si riporta di seguito solo la parte di codice che si occupa della generazione
 della tabella dinamica, con il dubbio che possa essere utile a qualcuno...
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "basicstyle={\footnotesize\ttfamily},breaklines=true,frame=lr,language={C++},numbers=left,showstringspaces=false,tabsize=4"
inline false
status open

\begin_layout Plain Layout

void costruisci_vettore(nodo *a, int (*cmp)(int,int)) { 	
\end_layout

\begin_layout Plain Layout

	int somma_precedenti = 0;     
\end_layout

\begin_layout Plain Layout

	for (int i=0; i<N;i++){ 		
\end_layout

\begin_layout Plain Layout

		int inizio = bidoni[i].capacita; 		
\end_layout

\begin_layout Plain Layout

		int fine = bidoni[i].capacita + somma_precedenti;         
\end_layout

\begin_layout Plain Layout

		for (int j = inizio; j <= fine; j++) 			
\end_layout

\begin_layout Plain Layout

		if (a[j - bidoni[i].capacita].raggiungibile)
\end_layout

\begin_layout Plain Layout

			{
\end_layout

\begin_layout Plain Layout

				int flag = 0; 				
\end_layout

\begin_layout Plain Layout

				if (cmp(a[j - bidoni[i].capacita].soluzioni[0].quanti + 1,   						a[j].soluzion
i[0].quanti) ||  
\end_layout

\begin_layout Plain Layout

						a[j].soluzioni[0].quanti == 0)
\end_layout

\begin_layout Plain Layout

						{
\end_layout

\begin_layout Plain Layout

							if(a[j-bidoni[i].capacita].soluzioni[0].precedente
\end_layout

\begin_layout Plain Layout

								!= bidoni[i].capacita)
\end_layout

\begin_layout Plain Layout

							{
\end_layout

\begin_layout Plain Layout

								a[j].soluzioni[1] = a[j].soluzioni[0]; 
\end_layout

\begin_layout Plain Layout

								a[j].soluzioni[0].quanti =
\end_layout

\begin_layout Plain Layout

								a[j - bidoni[i].capacita].soluzioni[0].quanti + 1;
\end_layout

\begin_layout Plain Layout

								a[j].soluzioni[0].precedente = bidoni[i].capacita;
\end_layout

\begin_layout Plain Layout

								a[j].raggiungibile = true;
\end_layout

\begin_layout Plain Layout

							} 							 							
\end_layout

\begin_layout Plain Layout

						if((a[j - bidoni[i].capacita].soluzioni[0].precedente ==
\end_layout

\begin_layout Plain Layout

							bidoni[i].capacita &&
\end_layout

\begin_layout Plain Layout

							a[j - bidoni[i].capacita].soluzioni[1].quanti != 0)
\end_layout

\begin_layout Plain Layout

							|| flag == 0) 
\end_layout

\begin_layout Plain Layout

						{
\end_layout

\begin_layout Plain Layout

							if(a[j-bidoni[i].capacita].soluzioni[0].precedente ==
\end_layout

\begin_layout Plain Layout

								bidoni[i].capacita &&
\end_layout

\begin_layout Plain Layout

								a[j - bidoni[i].capacita].soluzioni[1].quanti != 0)
\end_layout

\begin_layout Plain Layout

								{ 									
\end_layout

\begin_layout Plain Layout

									a[j].soluzioni[0].quanti = 
\end_layout

\begin_layout Plain Layout

									a[j - bidoni[i].capacita].soluzioni[1].quanti + 1;
\end_layout

\begin_layout Plain Layout

									a[j].soluzioni[0].precedente = bidoni[i].capacita;
\end_layout

\begin_layout Plain Layout

									a[j].raggiungibile = true; 								
\end_layout

\begin_layout Plain Layout

								} 								
\end_layout

\begin_layout Plain Layout

							else 								 								
\end_layout

\begin_layout Plain Layout

								{ 									
\end_layout

\begin_layout Plain Layout

									a[j].soluzioni[0].quanti = 
\end_layout

\begin_layout Plain Layout

									a[j - bidoni[i].capacita].soluzioni[0].quanti + 1;
\end_layout

\begin_layout Plain Layout

									a[j].soluzioni[0].precedente = bidoni[i].capacita;
\end_layout

\begin_layout Plain Layout

									a[j].raggiungibile = true;
\end_layout

\begin_layout Plain Layout

									flag = 1;
\end_layout

\begin_layout Plain Layout

								} 						
\end_layout

\begin_layout Plain Layout

						} 						
\end_layout

\begin_layout Plain Layout

					} 			
\end_layout

\begin_layout Plain Layout

		}         
\end_layout

\begin_layout Plain Layout

		somma_precedenti += bidoni[i].capacita;     
\end_layout

\begin_layout Plain Layout

	} 
\end_layout

\begin_layout Plain Layout

}  
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Si possono individuare le parti principali:
\end_layout

\begin_layout Itemize

\emph on
for
\emph default
 alla riga 3: scansione di tutti i sottoproblemi di dimensione 
\emph on
i
\end_layout

\begin_layout Itemize
riga 4-5: inizializzazione dell'intervallo di aggiornamento del bidone 
\emph on
i-esimo
\end_layout

\begin_layout Itemize

\emph on
for
\emph default
 alla riga 6: scorrimento l'intervallo appena inizializzato per aggiornare
 la tabella dinamica
\end_layout

\begin_layout Itemize

\emph on
if
\emph default
 alla riga 10: controllo se si otteiene una soluzione migliore o se è la
 prima volta che si esplora la casella
\end_layout

\begin_layout Itemize

\emph on
if
\emph default
 alla riga 13: controllo se la soluzione ottima precedente non contiene
 un bidone con la capacità dell'attuale
\end_layout

\begin_layout Itemize

\emph on
if
\emph default
 alla riga 22: controllo se la soluzione ottima precedente contiene un bidone
 con la capacità dell'attuale, ma c'è un'altra soluzione subottima oppure
 è la prima volta che uso il bidone corrente
\end_layout

\begin_layout Itemize

\emph on
if
\emph default
 alla riga 27 e 
\emph on
else
\emph default
 alla riga 36: distinzione tra i casi gestiti dall'
\emph on
if
\emph default
 precedente, altra soluzione o prima volta che si usa il bidone corrente.
\end_layout

\begin_layout Standard
Può essere interessante notare che, essendo le soluzioni per Aminolazina
 e Brinofulo equivalenti a meno di un controllo, viene passata come parametro
 la funzione che si occupa del controllo (riga 10), in modo da evitare di
 dover scrivere due funzioni esattamente uguali tranne che per una riga.
\end_layout

\begin_layout Standard
Per il resto il codice è simile a quello visto per la soluzione greedy,
 con l'ordinamento iniziale dei bidoni e l'ordinamento successivo dei bidoni
 per stampare la soluzione nell'ordine in cui i bidoni vengono incontrati.
\end_layout

\begin_layout Section
Torero Escamillo - territoriali 2007
\end_layout

\begin_layout Standard
\begin_inset Box Framed
position "t"
hor_pos "c"
has_inner_box 0
inner_pos "t"
use_parbox 0
use_makebox 0
width "100col%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout Subsection*
Torero Escamillo (torero) 
\end_layout

\begin_layout Subsubsection*
Difficoltà D = 2 (tempo limite 1 sec) 
\end_layout

\begin_layout Subsubsection*
Descrizione del problema
\end_layout

\begin_layout Plain Layout
Il celebre torero Escamillo deve indossare il proprio costume prima di entrare
 nell'arena.
 Egli è costretto a rispettare un dato numero di precedenze, indossando
 certi indumenti prima di altri, mentre alcuni indumenti possono essere
 liberamente indossati in un ordine qualsiasi.
 Per esempio, le "medias" (calze) vanno indossate prima delle "zapatillas"
 (scarpe), ma non vi è alcun vincolo sull'ordine con cui indossare la "chaquetil
la" (giacca) e la "montera" (cappello).
 Il costume di Escamillo è particolarmente raffinato ed elaborato e si compone
 di N indumenti.
 Sfortunatamente, Carmen non ha ancora consegnato uno degli N indumenti
 necessari alla vestizione di Escamillo.
 Aiutalo a vestirsi il più possibile, calcolando il massimo numero di indumenti
 che può indossare in attesa che Carmen gli consegni l'indumento mancante.
 
\end_layout

\begin_layout Subsubsection*
Dati di input
\end_layout

\begin_layout Plain Layout
Il file input.txt contiene nella prima riga una tripla di interi, separati
 da uno spazio: l'intero positivo N che indica il numero di indumenti per
 la vestizione di Escamillo, dove gli indumenti sono numerati da 1 a N;
 l'intero positivo M che indica il numero di precedenze tra coppie di indumenti
 da rispettare durante la vestizione; l'intero Q, compreso tra 1 e N, che
 indica l'indumento non ancora consegnato da Carmen.
 Ognuna delle successive M righe contiene una coppia di interi, compresi
 tra 1 e N, separati da uno spazio.
 Tale coppia di interi I e J rappresenta la precedenza in cui l'indumento
 numero I deve essere indossato prima dell'indumento numero J.
 
\end_layout

\begin_layout Subsubsection*
Dati di output
\end_layout

\begin_layout Plain Layout
Il file output.txt è composto da una riga contenente un solo intero, che
 rappresenta il massimo numero di indumenti che Escamillo riesce a indossare
 in attesa dell'indumento Q che Carmen deve ancora consegnargli.
 
\end_layout

\begin_layout Subsubsection*
Assunzioni
\end_layout

\begin_layout Plain Layout
1 < N < 100000 1 < M < 100000 1 ≤ Q ≤ N
\end_layout

\begin_layout Subsubsection*
Esempi di input/output
\end_layout

\begin_layout Plain Layout
\begin_inset Tabular
<lyxtabular version="3" rows="2" columns="2">
<features tabularvalignment="middle">
<column alignment="center" valignment="top" width="1in">
<column alignment="left" valignment="top" width="0">
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
File input.txt
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
File output.txt
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\align left
4 5 3 
\end_layout

\begin_layout Plain Layout
\align left
1 3 
\end_layout

\begin_layout Plain Layout
\align left
1 4 
\end_layout

\begin_layout Plain Layout
\align left
3 2 
\end_layout

\begin_layout Plain Layout
\align left
3 4 
\end_layout

\begin_layout Plain Layout
\align left
4 2 
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
1 
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Suggerimenti
\end_layout

\begin_layout Standard
Il problema, di semplice comprensione, chiede di individuare in una serie
 di regole di precedenza, quelle che vengono implicate una volta che una
 di esse viene a mancare.
\end_layout

\begin_layout Itemize
Qual è la struttura dati appropriata per rappresentare la struttura dei
 dati in input (in particolre qual è l'elemento che dovrebbe condurre subito
 a individuare quella corretta)?
\end_layout

\begin_layout Itemize
Supponendo che tu abbia risposto 
\begin_inset Quotes eld
\end_inset

Un grafo!
\begin_inset Quotes erd
\end_inset

 alla domanda precedente (che fra l'altro è la risposta corretta) puoi pensare
 se saresti in grado di usare un vettore per rappresentarlo (magari un vettore
 di strutture)?
\end_layout

\begin_layout Itemize
Che struttura useresti per rappresentare una regola di precedenza?
\end_layout

\begin_layout Itemize
Se ordini il vettore delle regole di precedenza e continui a ciclare su
 di esso togliendo di volta in volta le regole che non possono essere soddisfatt
e, hai la sicurezza di arrivare alla soluzione del problema? Quand'è che
 ti devi fermare? É importante ordinare il vettore prima di ciclare su di
 esso o è indifferente?
\end_layout

\begin_layout Itemize
Siccome le dimensioni dell'input sono dell'ordine di n=100000 sia nel numero
 di nodi (i vestiti) che nel numero di archi (le regole di precedenza) qual
 è la massima complessità computazionale accettabile dell'algoritmo risolutivo?
\end_layout

\begin_layout Itemize
Indipendentemente dal tipo di soluzione che intendi adottare, sei in grado
 di garantire che la complessità sia di tipo lineare?
\end_layout

\begin_layout Subsection
Soluzione
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "basicstyle={\small\ttfamily},breaklines=true,frame=lr,language={C++},numbers=left,showstringspaces=false,tabsize=4"
inline false
status open

\begin_layout Plain Layout

struct indumento{ 	
\end_layout

\begin_layout Plain Layout

	bool indossabile; 	
\end_layout

\begin_layout Plain Layout

	vector<int> lista; 	
\end_layout

\begin_layout Plain Layout

	indumento():indossabile(true){} 
\end_layout

\begin_layout Plain Layout

};
\end_layout

\begin_layout Plain Layout

int N,M,Q,non_indossabili; 
\end_layout

\begin_layout Plain Layout

indumento indumenti[100000]; 
\end_layout

\begin_layout Plain Layout

void propaga(int n) { 	
\end_layout

\begin_layout Plain Layout

	if (indumenti[n].indossabile == false) return; 
\end_layout

\begin_layout Plain Layout

	indumenti[n].indossabile = false;	
\end_layout

\begin_layout Plain Layout

	non_indossabili++;
\end_layout

\begin_layout Plain Layout

	for (int j = 0; j < indumenti[n].lista.size(); j++)
\end_layout

\begin_layout Plain Layout

		propaga(indumenti[n].lista[j]); 	 
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

int main(int argc, char** argv) 
\end_layout

\begin_layout Plain Layout

{ 	
\end_layout

\begin_layout Plain Layout

	ifstream in("input.txt"); 	
\end_layout

\begin_layout Plain Layout

	ofstream out("output.txt"); 	
\end_layout

\begin_layout Plain Layout

	in >> N >> M >> Q; 	
\end_layout

\begin_layout Plain Layout

	for (int i=0; i < M; i++) { 		
\end_layout

\begin_layout Plain Layout

		int r,s; 		
\end_layout

\begin_layout Plain Layout

		in >> r >> s; 		
\end_layout

\begin_layout Plain Layout

		indumenti[r].lista.push_back(s); 	
\end_layout

\begin_layout Plain Layout

	} 
\end_layout

\begin_layout Plain Layout

	propaga(Q); 	
\end_layout

\begin_layout Plain Layout

	out << N - non_indossabili << endl; 	
\end_layout

\begin_layout Plain Layout

	return 0; 
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Anche in questo caso un'opportuna scelta della struttura dati e un procedimento
 ricorsivo ci permettono di arrivare velocemente alla soluzione
\begin_inset Foot
status collapsed

\begin_layout Plain Layout
Alla data della stesura di questo paragrafo, nonostante una serie di prove
 che inducono a pensare che la soluzione sia corretta, il correttore ufficiale
 indica che tutte i casi di test producono risposte sbagliate.
 L'impressione è che siano sbagliati i casi del correttore, oppure mi sfugga
 qualcosa di essenziale nella comprensione del test.
 Successive versioni di questo manuale potranno risolvere la questione.
\end_layout

\end_inset

.
 Il fatto che il grafo sia la struttura più adatta è evidente dalla non
 linearità delle relazioni tra vestiti, per cui uno stesso vestito può essere
 necessario per indossare altri vestiti e a sua volta abbia bisogno di altri
 vestiti per poter essere indossato.
 Alle righe 1-5 viene definita la struttura che rappresenta un indumento,
 dove la variabile booleana 
\emph on
indossabile
\emph default
 (settata a 
\emph on
true
\emph default
 dal costruttore) indica se quell'indumento è indossabile e un vettore di
 interi che contiene gli indumenti che devono essere indossati dopo questo.
 In questa soluzione è stato usato un 
\emph on
vector
\emph default
 al posto della 
\emph on
list
\emph default
 già usata in altre soluzioni per mostrare che, nella rappresentazione di
 questo tipo di problemi, di fatto non ci sono differenze significative
 e la sintassi nella scansione di un vettore potrebbe risultare più naturale
 a chi è abituato ad utilizzare il C.
 La lettura e l'inserimento dei dati (righe 17-24) è molto semplice, poichè
 si usa l'indice del vettore degli indumenti come numero dell'indumento
 e si aggiungono in 
\emph on
lista
\emph default
 gli indumenti di cui esso è precedenza.
\end_layout

\begin_layout Standard
A questo punto la funzione ricorsiva 
\emph on
propaga
\emph default
 non deve far altro che una visita (in profondità o in ampiezza è in questo
 caso indifferente) del grafo ottenuto partendo dal nodo che rappresenta
 l'indumento mancante: la visita si concluderà dopo che tutte le precedenze
 sono state propagate e alcuni nodi potrebbero rimanerne esclusi, ma in
 questo caso non si prosegue con la visita in quanto essi sono proprio l'insieme
 degli indumenti indossabili, perchè nessuna regola di precedenza li riguarda.
 Siccome il problema chiedeva la loro quantità, è stata usata la variabile
 globale 
\emph on
non_indossabili
\emph default
, incrementata ogni volta che un indumento si aggiungeva all'insieme degli
 elementi non indossabili durante l'esplorazione (riga 11), per ottenere
 come differenza il numero di indumenti indossabili.
\end_layout

\begin_layout Standard
A questo punto ci si potrebbe domandare se la soluzione proposta rientra
 nei vincoli di complessità imposti dalle dimensioni dell'input del problema,
 dal momento che, come sappiamo, alcuni algoritmi ricorsivi possono comportare
 costi di tipo esponenziale: in questo caso invece è evidente che l'algoritmo
 è lineare nel numero di nodi, dal momento che una volta che un nodo risulta
 visitato viene escluso da eventuali visite successive e quindi ogni nodo
 verrà visitato al più una volta.
\end_layout

\begin_layout Section
Codici e pizzini - territoriali 2008
\end_layout

\begin_layout Standard
\begin_inset Box Framed
position "t"
hor_pos "c"
has_inner_box 0
inner_pos "t"
use_parbox 0
use_makebox 0
width "100col%"
special "none"
height "1in"
height_special "totalheight"
status collapsed

\begin_layout Subsection*
Codici e pizzini (pizzini) 
\end_layout

\begin_layout Subsubsection*
Difficoltà D = 1.
 
\end_layout

\begin_layout Subsubsection*
Descrizione del problema
\end_layout

\begin_layout Plain Layout
Il Commissario Basettoni è riuscito a localizzare il nascondiglio del pericoloso
 Gambadilegno.
 Facendo irruzione nel covo, Basettoni trova una serie di foglietti (detti
 "pizzini") che riportano, cifrati, i codici di accesso ai conti correnti
 del gruppo di malavitosi capeggiato da Gambadilegno.
\end_layout

\begin_layout Plain Layout
Il Commissario Basettoni chiede aiuto a Topolino per interpretare questi
 pizzini.
 Dopo approfondite analisi, Topolino scopre le seguenti cose:
\end_layout

\begin_layout Itemize
ogni pizzino contiene N righe e ciascuna riga è una sequenza di cifre decimali
 ('0', '1', ..., '9') concatenate senza spazi intermedi (quindi la sequenza
 0991, come tale, non va interpretata come il numero 991); 
\end_layout

\begin_layout Itemize
ogni pizzino riporta, cifrato, un codice di accesso a N cifre; 
\end_layout

\begin_layout Itemize
tale codice si ottiene concatenando una dopo l'altra, senza spazi intermedi,
 le cifre estratte dalle N sequenze scritte nel pizzino, più precisamente,
 una cifra per ogni sequenza; 
\end_layout

\begin_layout Itemize
la cifra da estrarre per ciascuna sequenza è quella in posizione p, dove
 p è il numero di anagrammi che, per tale sequenza, appaiono nel pizzino.
\end_layout

\begin_layout Plain Layout
Un anagramma di una sequenza S è ottenuto permutando le sue cifre (per esempio,
 1949 e 9419 sono anagrammi); inoltre, S è anagramma di se stessa.
 Quindi Topolino deduce che, per calcolare il numero p di anagrammi di S,
 deve includere S tra i suoi anagrammi contenuti nel pizzino.
 In questo modo, p = 1 indica che una sequenza non ha altri anagrammi, a
 parte se stessa, per cui va estratta la sua prima cifra.
\end_layout

\begin_layout Plain Layout
Per illustrare quanto descritto sopra a Basettoni, Topolino prende un pizzino
 che contiene i tre anagrammi 1949, 9419 e 9149 (e non ce ne sono altri)
 e ne estrae la loro terza cifra, ossia 4, 1 e 4, poiché p = 3; poi, prende
 un altro pizzino con due soli anagrammi 1949 e 9419, estraendone la seconda
 cifra, ossia 9 e 4, poiché p = 2.
 Utilizzando questo meccanismo di estrazione delle cifre, aiutate Topolino
 a decifrare i pizzini di Gambadilegno trovati da Basettoni.
 
\end_layout

\begin_layout Subsubsection*
Dati di input
\end_layout

\begin_layout Plain Layout
Il file input.txt è composto da N+1 righe.
\end_layout

\begin_layout Plain Layout
La prima riga contiene un intero positivo che rappresenta il numero N di
 sequenze contenute nel pizzino.
\end_layout

\begin_layout Plain Layout
Ciascuna delle successive N righe contiene una sequenza di cifre decimali
 ('0', '1', ..., '9') senza spazi intermedi.
 
\end_layout

\begin_layout Subsubsection*
Dati di output
\end_layout

\begin_layout Plain Layout
Il file output.txt è composto da una sola riga contenente una sequenza di
 N cifre decimali, senza spazi intermedi, ossia il codice di accesso cifrato
 nel pizzino.
\end_layout

\begin_layout Subsubsection*
Assunzioni
\end_layout

\begin_layout Itemize
1 ≤ N ≤ 100.
 
\end_layout

\begin_layout Itemize
Ogni sequenza contiene al massimo 80 cifre decimali.
 
\end_layout

\begin_layout Itemize
Le sequenze contenute in uno stesso pizzino sono tutte diverse tra di loro.
\end_layout

\begin_layout Itemize
Una sequenza di K cifre decimali presenta al massimo K anagrammi in uno
 stesso pizzino.
 Inoltre, tali anagrammi non necessariamente appaiono in righe consecutive
 del pizzino.
\end_layout

\begin_layout Subsubsection*
Esempi di input/output
\end_layout

\begin_layout Plain Layout
\begin_inset Tabular
<lyxtabular version="3" rows="2" columns="2">
<features tabularvalignment="middle">
<column alignment="left" valignment="top" width="1in">
<column alignment="left" valignment="top" width="0">
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
File input.txt
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
File output.txt
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
6 
\end_layout

\begin_layout Plain Layout
1949 
\end_layout

\begin_layout Plain Layout
21 
\end_layout

\begin_layout Plain Layout
9419 
\end_layout

\begin_layout Plain Layout
12 
\end_layout

\begin_layout Plain Layout
4356373
\end_layout

\begin_layout Plain Layout
9149
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
411244
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Suggerimenti
\end_layout

\begin_layout Standard
Il problema chiede di estrarre da una serie di stringhe una cifra secondo
 le regole spiegate nel testo.
\end_layout

\begin_layout Standard
Leggendo il testo ti è subito chiara qual è la regola da applicare per estrarre
 il messaggio dai pizzini? 
\end_layout

\begin_layout Standard
Qual è la struttura dati più adatta per contenere le singole cifre che compongon
o i pizzini (attenzione che ogni riga, pur contenendo cifre decimali, non
 rappresenta un numero decimale)? Se volessi usare una variabile intera
 per memorizzare una singola cifra, quali problemi avresti (leggere bene
 le assunzioni)?
\end_layout

\begin_layout Standard
Sei in grado di leggere le singole righe come stringhe?
\end_layout

\begin_layout Standard
Come faccio a controllare se due stringhe sono l'una l'anagramma dell'altra?
 Devo scorrere la prima stringa e per ogni lettera vedere se esiste nella
 seconda?
\end_layout

\begin_layout Standard
Esiste un modo più rapido e efficace di quello proposto sopra?
\end_layout

\begin_layout Subsection
Soluzione
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "basicstyle={\small\ttfamily},breaklines=true,frame=lr,language={C++},numbers=left,showstringspaces=false,tabsize=4"
inline false
status open

\begin_layout Plain Layout

struct riga{ 	
\end_layout

\begin_layout Plain Layout

	int numero_anagrammi; 	
\end_layout

\begin_layout Plain Layout

	string valore; 	
\end_layout

\begin_layout Plain Layout

	Riga():numero_anagrammi(0){} 
\end_layout

\begin_layout Plain Layout

};
\end_layout

\begin_layout Plain Layout

riga righe[100]; 
\end_layout

\begin_layout Plain Layout

string ordinate[100];
\end_layout

\begin_layout Plain Layout

int main() 
\end_layout

\begin_layout Plain Layout

{ 	
\end_layout

\begin_layout Plain Layout

	fstream in, out; 	
\end_layout

\begin_layout Plain Layout

	in.open("input.txt",ios::in); 	out.open("output.txt",ios::out); 	
\end_layout

\begin_layout Plain Layout

	in >> N; 	
\end_layout

\begin_layout Plain Layout

	for (int i=0;i< N;i++) 	
\end_layout

\begin_layout Plain Layout

	{ 		
\end_layout

\begin_layout Plain Layout

		in >> righe[i].valore; 		
\end_layout

\begin_layout Plain Layout

		ordinate[i] = righe[i].valore;
\end_layout

\begin_layout Plain Layout

		sort(ordinate[i].begin(), ordinate[i].end()); 	
\end_layout

\begin_layout Plain Layout

	} 	
\end_layout

\begin_layout Plain Layout

	for (int i=0;i< N;i++) 		
\end_layout

\begin_layout Plain Layout

		for (int j=0;j< N;j++) 			 
\end_layout

\begin_layout Plain Layout

			if (ordinate[i]==ordinate[j])
\end_layout

\begin_layout Plain Layout

				 righe[j].numero_anagrammi++; 	
\end_layout

\begin_layout Plain Layout

	for (int i=0;i< N;i++) 		
\end_layout

\begin_layout Plain Layout

		out << righe[i].valore.at(righe[i].numero_anagrammi-1);
\end_layout

\begin_layout Plain Layout

	return 0; 
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
La parte fondamentale è quella che ci permette di verificare quando due
 stringhe sono una l'anagramma dell'altra.
 Per esperienza con gli studenti la prima idea in genere è quella di scorrere
 la prima stringa carattere per carattere e vedere se ogni carattere è anche
 presente nella seconda, eliminandoli di volta in volta in modo da non usare
 lo stesso carattere più volte.
 Quest'idea, non difficile ma nemmeno banale da implementare, richiede una
 certa attenzione per evitare piccoli errori che potrebbero invalidare il
 resto del programma.
 Un'idea decisamente migliore, simile a quella presente nella soluzione
 del problema 
\begin_inset Quotes eld
\end_inset

Teste di serie
\begin_inset Quotes erd
\end_inset

 (vedi paragrafo 
\begin_inset CommandInset ref
LatexCommand ref
reference "sec:Esempio:Serie"

\end_inset

), è quella di ordinare le stringhe: così facendo otteniamo per ogni stringa
 una 
\begin_inset Quotes eld
\end_inset

firma
\begin_inset Quotes erd
\end_inset

, che è composta dalle lettere ordinate e di conseguenza due stringhe sono
 anagrammi l'una dell'altra se presentano la stessa 
\begin_inset Quotes eld
\end_inset

firma
\begin_inset Quotes erd
\end_inset

.
 Questo approccio ha almeno due vantaggi:
\end_layout

\begin_layout Itemize
possiamo usare la funzione di libreria 
\emph on
sort
\emph default
 per ordinare scrivendo in questo modo una sola riga di codice, sicuramente
 corretto.
\end_layout

\begin_layout Itemize
l'ordinamento con la funzione 
\emph on
sort
\emph default
 è decisamente più veloce della prima idea sui confronti delle lettere (compless
ità 
\begin_inset Formula $NlogN$
\end_inset

 contro 
\begin_inset Formula $N^{2}$
\end_inset

)
\end_layout

\begin_layout Standard
Tutto quello che segue a questo punto risulta piuttosto ovvio: si procede
 a confrontare ogni stringa ordinata con ogni altra stringa (i due cicli
 
\emph on
for
\emph default
 alle righe 19-20) e ogni volta che si incontra una corrispondenza si incrementa
 il contatore degli anagrammi contenuto nella struttura riga, in modo che
 alla fine ogni riga contenga quante volte essa è l'anagramma di altre righe
 (se la riga non è anagramma di nessun altra comunque il contatore verrà
 incrementato una volta quando la riga viene confrontata con se stessa).
\end_layout

\begin_layout Standard
A questo punto basta scorrere tutte le righe ed estrarre la cifra nella
 posizione indicata dal numero di anagrammi, ricordandosi di sottrarre 1
 all'indice della stringa (riga 24), poichè l'indice di stringa parte da
 0 e il numero di anagrammi parte invece da 1.
\end_layout

\begin_layout Standard
In questo caso il problema della complessità computazionale non sembra determina
nte, in quanto le stringhe in input sono al massimo 100.
 Un calcolo approssimativo del costo indica che l'ordinamento iniziale ha
 un costo di tipo 
\begin_inset Formula $NLlogL$
\end_inset

, con L lunghezza della stringa da ordinare, poiché abbiamo N stringhe da
 ordinare e il costo dell'ordinamento abbiamo già detto essere quello del
 
\emph on
sort
\emph default
, mentre i cicli di confronto hanno un costo di tipo 
\begin_inset Formula $N^{2}L$
\end_inset

, dove la componente quadratica è dovuta ai due cicli e quella lineare in
 L al costo del confronto tra stringhe.
 Anche con i valori massimi di N e L si vede quindi che il costo totale
 non arriva al milione di operazioni e quindi abbondantemente entro i limiti.
\end_layout

\begin_layout Section
Essenza di profumi - territoriali 2009
\end_layout

\begin_layout Standard
\begin_inset Box Framed
position "t"
hor_pos "c"
has_inner_box 0
inner_pos "t"
use_parbox 0
use_makebox 0
width "100col%"
special "none"
height "1in"
height_special "totalheight"
status collapsed

\begin_layout Subsection*
Essenza per profumi (essenza) 
\end_layout

\begin_layout Subsubsection*
Difficoltà D = 1.
 
\end_layout

\begin_layout Subsubsection*
Descrizione del problema
\end_layout

\begin_layout Plain Layout
L'essenza di un fiore raro è molto ricercata tra i profumieri.
 Il prezzo di mercato viene fissato giornalmente dal CGE, il Consorzio dei
 Grossisti di Essenze.
 Inoltre, essendo di natura organica, l'essenza acquistata da un profumiere
 deperisce dopo un certo periodo e quindi può essere rivenduta soltanto
 entro K giorni dall'acquisto (data di scadenza).
\end_layout

\begin_layout Plain Layout
Un profumiere è venuto a conoscenza del prezzo di mercato dell'essenza che
 il CGE prevede per i prossimi N giorni (N ≥ K), per semplicità numerati
 da 1 a N.
 Ritenendo molto affidabili le previsioni del CGE, il profumiere intende
 comprare una certa quantità di essenza il giorno i per rivenderla il giorno
 j, tenendo presente però che non può andare oltre la data di scadenza (quindi
 deve essere i ≤ j ≤ i+K).
 Il profumiere intende fare un solo acquisto e una sola vendita successiva
 all'acquisto.
\end_layout

\begin_layout Plain Layout
Aiutate il profumiere a calcolare il massimo guadagno che può ottenere,
 calcolato come la differenza tra il prezzo dell'essenza al giorno j e quello
 al giorno i.
 Notate che è permesso scegliere j=i: in questo modo, anche se il prezzo
 di mercato dell'essenza fosse in discesa per tutto il periodo considerato,
 sarebbe possibile evitare perdite.
 
\end_layout

\begin_layout Subsubsection*
Dati di input
\end_layout

\begin_layout Plain Layout
Il file input.txt è composto da due righe.
\end_layout

\begin_layout Plain Layout
La prima riga contiene due interi positivi separati da uno spazio, rispettivamen
te il numero K di giorni per la data di scadenza e il numero N di prossimi
 giorni.
\end_layout

\begin_layout Plain Layout
La seconda riga contiene N interi positivi separati da uno spazio, i quali
 rappresentano il prezzo di vendita dell'essenza nei prossimi N giorni.
 
\end_layout

\begin_layout Subsubsection*
Dati di output
\end_layout

\begin_layout Plain Layout
Il file output.txt è composto da una sola riga contenente un intero che rappresen
ta il massimo guadagno del profumiere, con le regole descritte sopra.
 
\end_layout

\begin_layout Subsubsection*
Assunzioni
\end_layout

\begin_layout Plain Layout
1 ≤ N ≤ 1000, 1 ≤ K ≤ N .
\end_layout

\begin_layout Subsubsection*
Esempi di input/output
\end_layout

\begin_layout Plain Layout
\begin_inset Tabular
<lyxtabular version="3" rows="2" columns="2">
<features tabularvalignment="middle">
<column alignment="left" valignment="top" width="1in">
<column alignment="left" valignment="top" width="0">
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
File input.txt
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
File output.txt
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
2 6 
\end_layout

\begin_layout Plain Layout
3 6 2 6 9 6
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
7
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Suggerimenti 
\end_layout

\begin_layout Standard
Il problema si riduce alla ricerca di un intervallo all'interno di un vettore
 la cui differenza dei valori agli estremi sia massima.
 
\end_layout

\begin_layout Itemize
Sai trovare la differenza tra due valori distanti una sola posizione all'interno
 di un vettore? 
\end_layout

\begin_layout Itemize
Puoi fare la stessa cosa per i tutti gli intervalli di distanza uno e trovare
 quale differenza tra gli estremi dell'intervallo è massima? 
\end_layout

\begin_layout Itemize
Se l'intervallo al posto di avere distanza 1 avesse distanza K come modificheres
ti il programma precedente? 
\end_layout

\begin_layout Itemize
Se vuoi controllare partendo dal primo elemento del vettore tutte le differenze
 da uno fino a K cosa devi usare? 
\end_layout

\begin_layout Itemize
Puoi riapplicare lo stesso principio a differenze "mobili", cioè in cui
 al posto di partire dal primo elemento del vettore parti da quello in posizione
 
\emph on
i
\emph default
? 
\end_layout

\begin_layout Itemize
Se hai seguito le idee presentate dovresti essere arrivato a una soluzione
 meccanica del problema, di complessità 
\begin_inset Formula $KN$
\end_inset

.
 Anche se in questo problema non è necessario, riusciresti a trovare un'altra
 idea completamente diversa che possa far diminuire il costo? 
\end_layout

\begin_layout Subsection
Soluzione 
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "basicstyle={\small\ttfamily},breaklines=true,frame=lr,language={C++},numbers=left,showstringspaces=false,tabsize=4"
inline false
status collapsed

\begin_layout Plain Layout

int K,N; 
\end_layout

\begin_layout Plain Layout

int vettore[1000];
\end_layout

\begin_layout Plain Layout

int main() 
\end_layout

\begin_layout Plain Layout

{ 	
\end_layout

\begin_layout Plain Layout

	ifstream in("input.txt"); 	
\end_layout

\begin_layout Plain Layout

	ofstream out("output.txt"); 	
\end_layout

\begin_layout Plain Layout

	in >> K >> N; 	
\end_layout

\begin_layout Plain Layout

	for (int i=0; i<N; i++) 		
\end_layout

\begin_layout Plain Layout

		in >> vettore[i]; 	
\end_layout

\begin_layout Plain Layout

	int max=0; 	
\end_layout

\begin_layout Plain Layout

	for (int i=0; i<N; i++) 		
\end_layout

\begin_layout Plain Layout

		for (int j=0; j<=K; j++) 			
\end_layout

\begin_layout Plain Layout

			if (i+j<N && vettore[i+j] - vettore[i] > max)
\end_layout

\begin_layout Plain Layout

				max = vettore[i+j] - vettore[i]; 	
\end_layout

\begin_layout Plain Layout

		out << max << endl; 	
\end_layout

\begin_layout Plain Layout

	return 0; 
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Standard

\end_layout

\begin_layout Standard
La soluzione più ovvia di questo problema è piuttosto banale: dopo aver
 letto tutte quotazioni delle essenze e averle messe in un vettore, si scorrono
 tutti i giorni in cui può essere acquistata l'essenza (ciclo esterno alla
 riga 11) e si prova a fare la differenza con i valori nei giorni successivi
 fino a un massimo di K giorni, stando anche attenti a non uscire dal vettore.
 É interessante notare che il controllo sula non uscita dal vettore (
\begin_inset Formula $i+j<N$
\end_inset

) deve essere messo in  
\emph on
AND
\emph default
 come primo termine, in modo che se non fosse verificato non verrà eseguito
 il secondo controllo, che contenendo una lettura del vettore alla posizione
 
\begin_inset Formula $i+j$
\end_inset

, potrebbe far terminare il programma nel caso di lettura esterna ai limiti.
\end_layout

\begin_layout Standard
Essendo la ricerca di un massimo, ci sarà una variabile per contenere il
 nuovo massimo che viene trovato e che inizialmente vale 0 per indicare
 che, nel caso peggiore, sarà comunque possibile avere un guadagno 0.
 Come detto nei suggerimenti, questo approccio ha un costo 
\begin_inset Formula $KN$
\end_inset

 e se i due valori sono paragonabili diventa di tipo quadratico.
 
\end_layout

\begin_layout Section
Treno di container - territoriali 2009
\end_layout

\begin_layout Standard
\begin_inset Box Framed
position "t"
hor_pos "c"
has_inner_box 0
inner_pos "t"
use_parbox 0
use_makebox 0
width "100in"
special "width"
height "1in"
height_special "totalheight"
status collapsed

\begin_layout Subsection*
Treno di container (treno) 
\end_layout

\begin_layout Subsubsection*
Difficoltà D = 2.
 
\end_layout

\begin_layout Subsubsection*
Descrizione del problema
\end_layout

\begin_layout Plain Layout
Al porto sono arrivati N container della sostanza chimica di tipo A e N
 container della sostanza chimica di tipo B.
 I container sono stati caricati, uno dietro l'altro, su di un treno che
 ne può contenere 2N+2.
 Le posizioni dei container sul treno sono numerate da 1 a 2N+2.
 Il carico è stato fatto in modo che gli N container di tipo A occupino
 le posizioni da 1 a N, mentre quelli di tipo B da N+1 a 2N; le rimanenti
 due posizioni 2N+1 e 2N+2 sono vuote.
\end_layout

\begin_layout Plain Layout
Per motivi connessi all'utilizzo delle sostanze chimiche nella fabbrica
 alla quale sono destinate, i container vanno distribuiti sul treno a coppie:
 ciascun container per la sostanza di tipo A deve essere seguito da uno
 di tipo B.
 Occorre quindi che nelle posizioni dispari (1, 3, 5, ..., 2N-1) vadano sistemati
 esclusivamente i container di tipo A mentre in quelle pari (2, 4, 6, ...,
 2N) quelli di tipo B, lasciando libere le ultime due posizioni 2N+1 e 2N+2.
\end_layout

\begin_layout Plain Layout
A tal fine, viene impiegata una grossa gru, che preleva due container alla
 volta, in posizioni consecutive i, i+1, e li sposta nelle uniche due posizioni
 consecutive j, j+1 libere nel treno (inizialmente, j = 2N+1).
 Tale operazione è univocamente identificata dalla coppia (i,j), dove entrambe
 le posizioni i e i+1 devono essere occupate da container mentre j e j+1
 devono essere entrambe vuote.
\end_layout

\begin_layout Plain Layout
Per esempio, con N = 4, abbiamo inizialmente la configurazione A A A A B
 B B B * *, dove le due posizioni vuote sono indicate da un asterisco *:
\end_layout

\begin_layout Itemize
Il primo spostamento della gru è (4,9) e porta alla configurazione:
\end_layout

\begin_deeper
\begin_layout Plain Layout

\family typewriter
A A A * * B B B A B
\end_layout

\begin_layout Plain Layout

\family typewriter
1 2 3 4 5 6 7 8 9 10 
\end_layout

\end_deeper
\begin_layout Itemize
Il secondo spostamento è (6, 4) e porta alla configurazione:
\end_layout

\begin_deeper
\begin_layout Plain Layout

\family typewriter
A A A B B * * B A B
\end_layout

\begin_layout Plain Layout

\family typewriter
1 2 3 4 5 6 7 8 9 10 
\end_layout

\end_deeper
\begin_layout Itemize
Il terzo spostamento è (2, 6) e porta alla configurazione:
\end_layout

\begin_deeper
\begin_layout Plain Layout

\family typewriter
A * * B B A A B A B
\end_layout

\begin_layout Plain Layout

\family typewriter
1 2 3 4 5 6 7 8 9 10 
\end_layout

\end_deeper
\begin_layout Itemize
Il quarto spostamento è (5,2) e porta alla configurazione:
\end_layout

\begin_deeper
\begin_layout Plain Layout

\family typewriter
A B A B * * A B A B
\end_layout

\begin_layout Plain Layout

\family typewriter
1 2 3 4 5 6 7 8 9 10
\family default
 
\end_layout

\end_deeper
\begin_layout Itemize
Il quinto e ultimo spostamento è (9,5) e porta alla configurazione desiderata:
\end_layout

\begin_deeper
\begin_layout Plain Layout

\family typewriter
A B A B A B A B * *
\end_layout

\begin_layout Plain Layout

\family typewriter
1 2 3 4 5 6 7 8 9 10
\end_layout

\end_deeper
\begin_layout Plain Layout
Notare che per N=4 è possibile, con cinque spostamenti, sistemare i 2N container
 nell'ordine giusto.
 Scrivere quindi un programma che determini la successione degli spostamenti
 eseguiti dalla gru per ottenere un analogo risultato nel caso in cui 3
 ≤ N ≤ 1000.
 Si richiede inoltre che il numero K di tali spostamenti non superi il valore
 3N.
 
\end_layout

\begin_layout Subsubsection*
Dati di input
\end_layout

\begin_layout Plain Layout
Il file input.txt è composto da una sola riga, contenente l'intero N che
 rappresenta il numero di container per ciascuna delle due sostanze.
 
\end_layout

\begin_layout Subsubsection*
Dati di output
\end_layout

\begin_layout Plain Layout
Il file output.txt è composto da K+1 righe.
\end_layout

\begin_layout Plain Layout
La prima riga contiene due interi positivi separati da uno spazio, rispettivamen
te il numero K di spostamenti operati dalla gru e il numero N di container
 per ciascuna delle due sostanze
\end_layout

\begin_layout Plain Layout
Le righe successive contengono la sequenza di K spostamenti del tipo (i,j),
 tali che partendo dalla sequenza AAA...ABBB...B**, si arrivi alla sequenza ABABAB...AB**
 con le regole descritte sopra.
 Ciascuna delle righe contiene una coppia di interi positivi i e j separati
 da uno spazio a rappresentare lo spostamento (i,j).
 
\end_layout

\begin_layout Subsubsection*
Assunzioni
\end_layout

\begin_layout Plain Layout
3 ≤ N ≤ 1000, 1 ≤ i,j ≤ 2N+1, K ≤ 3 N.
\end_layout

\begin_layout Subsubsection*
Esempi di input/output
\end_layout

\begin_layout Plain Layout
\begin_inset Tabular
<lyxtabular version="3" rows="2" columns="2">
<features tabularvalignment="middle">
<column alignment="left" valignment="top" width="0">
<column alignment="left" valignment="top" width="1in">
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
File input.txt
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
File output.txt
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
3
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
4 3 
\end_layout

\begin_layout Plain Layout
2 7 
\end_layout

\begin_layout Plain Layout
6 2 
\end_layout

\begin_layout Plain Layout
4 6 
\end_layout

\begin_layout Plain Layout
7 4 
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Suggerimenti
\end_layout

\begin_layout Standard
Si tratta di modificare le posizioni degli elementi in un vettore per raggiunger
e una particolare configurazione finale utilizzando regole prestabilite.
\end_layout

\begin_layout Itemize
Qual è la struttura dati adatta (attenzione perchè la risposta più ovvia
 è sbagliata)?
\end_layout

\begin_layout Itemize
Hai realmente bisogno di un vettore?
\end_layout

\begin_layout Itemize
Se usi un vettore, sei capace di spostare coppie di elementi da un punto
 all'altro?
\end_layout

\begin_layout Itemize
Se non usi un vettore, cosa ti interessa realmente?
\end_layout

\begin_layout Itemize
Riesci a ridurre il problema in un problema uguale a quello di partenza,
 solo di dimensione inferiore?
\end_layout

\begin_layout Subsection
Soluzione
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "basicstyle={\small\ttfamily},breaklines=true,frame=lr,language={C++},numbers=left,showstringspaces=false,tabsize=4"
inline false
status collapsed

\begin_layout Plain Layout

int K,N; 
\end_layout

\begin_layout Plain Layout

ifstream in("input.txt"); 
\end_layout

\begin_layout Plain Layout

ofstream out("output.txt");
\end_layout

\begin_layout Plain Layout

void calcola(int j) {     
\end_layout

\begin_layout Plain Layout

	if (j==10){ 	
\end_layout

\begin_layout Plain Layout

		out << (j-2)/2 << " " << j-1 << endl; 		
\end_layout

\begin_layout Plain Layout

		return; 	
\end_layout

\begin_layout Plain Layout

	}     
\end_layout

\begin_layout Plain Layout

	out << (j-2)/2 << " " << j-1 << endl;     
\end_layout

\begin_layout Plain Layout

	out << j-3 << " " << (j-2)/2 << endl; 	
\end_layout

\begin_layout Plain Layout

	calcola(j-2); 
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

int main() 
\end_layout

\begin_layout Plain Layout

{ 	
\end_layout

\begin_layout Plain Layout

	in >> N; 	
\end_layout

\begin_layout Plain Layout

	K = 2*N-3; 	
\end_layout

\begin_layout Plain Layout

	out << K << " " << N << endl; 	
\end_layout

\begin_layout Plain Layout

	calcola(2*N+2); 	
\end_layout

\begin_layout Plain Layout

	out << 6 << " " << 4 << endl; 	
\end_layout

\begin_layout Plain Layout

	out << 2 << " " << 6 << endl; 	
\end_layout

\begin_layout Plain Layout

	out << 5 << " " << 2 << endl; 	
\end_layout

\begin_layout Plain Layout

	out << 2*N+1 << " " << 5 << endl; 	
\end_layout

\begin_layout Plain Layout

	return 0; 
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Siccome non è così evidente quale sia il punto d'attacco del problema e
 l'esempio che viene mostrato penso sia di proposito elusivo, bisogna cercare
 di vedere se sono presenti delle regolarità e nel caso sfruttarle per arrivare
 alla soluzione.
 Guardando l'esempio
\begin_inset Foot
status collapsed

\begin_layout Plain Layout
Personalmente ho utilizzato dei bigliettini contrassegnati con le lettere
 A e B e gli asterischi, per poter visualizzare meglio gli spostamenti e
 verificare la correttezza di quanto pensato.
\end_layout

\end_inset

 si può vedere che esiste già una coppia di vagoni di tipo AB che si trova
 al centro del treno, quindi senza scombinare questa configurazione già
 corretta posso spostarla nei posti vuoti, creando due vuoti al suo posto.
 Ciò che si presenta a questo punto dovrebbe suggerire il modo di procedere:
 se nei buchi che si sono creati vado a sostituire due vagoni di tipo BB
 presi dal fondo, escludendo gli ultimi due che sono già corretti, mi ritrovo
 nella stessa situazione di partenza, solo che il problema adesso ha una
 dimensione inferiore di 2, come si può vedere in figura 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:Treno-ricorsiva"

\end_inset

.
 
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement h
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename ../materiali/problemi territoriali/2009_treno/treno.eps
	scale 50

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:Treno-ricorsiva"

\end_inset

Idea ricorsiva
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Quando da un problema riusciamo a riportarci allo stesso problema, ma con
 una dimensione inferiore, dovrebbe subito venirci in mente la possibilità
 di poter applicare un approccio ricorsivo.
 Come da figura 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:Treno-ricorsiva"

\end_inset

 infatti posso applicare lo stesso ragionamento al secondo livello e ridurre
 ancora il problema di 2 unità, passando dal problema di dimensione 10 a
 quello di dimensione 8 (quando parlo di dimensione 10 intendo dire la dimension
e del treno, che in funzione di N risulta 
\begin_inset Formula $2N+2$
\end_inset

).
 Tutto molto bello, c'è solo un problema: quando si arriva al problema di
 dimensione 8 (cioè N=3), il procedimento così come applicato a tutti i
 livelli precedenti, non funziona più a causa delle dimensioni ridotte.
 Per risolverlo però basta osservare che nell'esempio ci veniva già data
 la soluzione del problema con N=4, quindi quando la ricorsione arriva alla
 dimensione 10 basta fermarsi e proseguire con le mosse già note.
\end_layout

\begin_layout Standard
Alla fine si arriverà a una situazione con tutte le coppie AB e basterà
 spostare l'ultima coppia in posizione 5-6 al posto dei buchi creati dal
 procedimento applicato e il problema sarà risolto.
\end_layout

\begin_layout Standard
É necessario usare un vettore per memorizzare il contenuto dei vagoni? No,
 poichè quello che interessa è solo di stampare gli spostamenti e quelli
 sono individuati a partire dagli estremi dell'intervallo da modificare,
 come si vede in figura 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:Treno-ricorsiva"

\end_inset

.
 Se chiamiamo gli estremi 
\emph on
i
\emph default
 e 
\emph on
j
\emph default
 (tra l'altro 
\emph on
i
\emph default
 in questo tipo di impostazione non interessa), si vede che a ogni spostamento
 devo spostare la coppia di vagoni all'indice 
\begin_inset Formula $(j-2)/2$
\end_inset

 in posizione 
\begin_inset Formula $j-1$
\end_inset

 e successivamente la coppia di vagoni all'indice 
\begin_inset Formula $j-3$
\end_inset

 in posizione 
\begin_inset Formula $(j-2)/2$
\end_inset

.
 Abbiamo quindi solo la necessità di stampare man mano gli spostamenti effettuat
i: l'unico problema potrebbe essere che il testo chiede di stampare prima
 il numero degli spostamenti che gli spostamenti stessi, ma anche questo
 può essere risolto facilmente sapendo che, dato questo procedimento, il
 numero di spostamenti è sempre 
\begin_inset Formula $2N-3$
\end_inset

, dove il 2N deriva dal fatto che per ogni livello facciamo 2 spostamenti
 e il -3 deriva dal fatto che quando arriviamo al caso N=4 gli spostamenti
 da fare sono solo 5 al posto di 8.
\end_layout

\begin_layout Standard
Questo ci garantisce inoltre di arrivare alla soluzione in meno di 3N mosse,
 come richiede il testo.
 Ci sono altre possibilità di effettuare gli spostamenti per ridurre il
 problema oltre a quella proposta, in ogni caso è possibile stare sotto
 a 3N.
\end_layout

\begin_layout Standard
Rimane infine da notare che questo problema, avendo non una ma una serie
 di possibili soluzioni, verrà valutato positivamente dal correttore solo
 nel caso produca la stessa soluzione inserita nel correttore: il codice
 qui proposto, pur essendo corretto, viene considerato errato dal correttore
 automatico.
\end_layout

\begin_layout Section
Quasi-palindromi - territoriali 2010
\end_layout

\begin_layout Standard
\begin_inset Box Framed
position "t"
hor_pos "c"
has_inner_box 0
inner_pos "t"
use_parbox 0
use_makebox 0
width "100in"
special "width"
height "1in"
height_special "totalheight"
status collapsed

\begin_layout Subsection*
Quasi-palindromi (quasipal) 
\end_layout

\begin_layout Subsubsection*
Difficoltà D = 1.
 
\end_layout

\begin_layout Subsubsection*
Descrizione del problema
\end_layout

\begin_layout Plain Layout
Un numero palindromo è un numero che letto da destra a sinistra o da sinistra
 a destra produce la stessa sequenza di cifre.
 Un numero N è quasi-palindromo se è palindromo oppure è tale che sostituendo
 alcune delle cifre 0 presenti in N con altre cifre diverse da 0 si ottiene
 un numero N' che è palindromo.
 Ad esempio N = 4504 è quasi-palindromo perché sostituendo 0 con 5 si ottiene
 il numero N’ = 4554 che è palindromo.
\end_layout

\begin_layout Plain Layout
Un insieme di M numeri con lo stesso numero di cifre forma un rettangolo
 quasi-palindromo (le cui righe sono i numeri) se le cifre nella stessa
 colonna formano sempre un numero quasi-palindromo.
 Ad esempio 120, 046 e 123 formano un rettangolo quasi-palindromo (notare
 che alcuni numeri possono iniziare con lo zero).
 È sufficiente porli nelle righe come segue, per verificarlo colonna per
 colonna:
\end_layout

\begin_layout Plain Layout
120
\end_layout

\begin_layout Plain Layout
046
\end_layout

\begin_layout Plain Layout
123
\end_layout

\begin_layout Plain Layout
Infatti, la cifra 0 in 120 va sostituita con 3 per ottenere un palindromo
 sulla terza colonna.
\end_layout

\begin_layout Plain Layout
Scrivere un programma che dati M numeri di N cifre ciascuno, li stampi in
 ordine (uno per riga) in modo tale che formino un rettangolo quasi-palindromo.
 
\end_layout

\begin_layout Subsubsection*
Dati di input
\end_layout

\begin_layout Plain Layout
Il file input.txt è composto da M+1 righe.
 La prima riga contiene due interi positivi M e N separati da uno spazio.
 Ciascuna delle successive M righe contiene una sequenza di N cifre decimali
 consecutive (senza separazione di spazi), che rappresenta uno degli M numeri.
 
\end_layout

\begin_layout Subsubsection*
Dati di output
\end_layout

\begin_layout Plain Layout
Il file output.txt è composto da M righe contenenti gli M numeri in ingresso
 ordinati in modo da formare un rettangolo quasi-palindromo.
 
\end_layout

\begin_layout Subsubsection*
Assunzioni
\end_layout

\begin_layout Plain Layout
2 ≤ N, M ≤ 8.
 Viene garantito che esiste sempre una soluzione.
 Alcuni numeri possono iniziare con una o più cifre 0.
\end_layout

\begin_layout Subsubsection*
Esempi di input/output
\end_layout

\begin_layout Plain Layout
\begin_inset Tabular
<lyxtabular version="3" rows="2" columns="2">
<features tabularvalignment="middle">
<column alignment="left" valignment="top" width="1in">
<column alignment="left" valignment="top" width="1in">
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
File input.txt
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
File output.txt
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
3 3 
\end_layout

\begin_layout Plain Layout
046 
\end_layout

\begin_layout Plain Layout
120 
\end_layout

\begin_layout Plain Layout
123
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
120 
\end_layout

\begin_layout Plain Layout
046 
\end_layout

\begin_layout Plain Layout
123 
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Suggerimenti
\end_layout

\begin_layout Standard
Il problema richiede di trovare delle permutazioni di un insieme di cifre
 che rispondano a un certo criterio, chiamato 
\emph on
quasi palindromia
\emph default
.
\end_layout

\begin_layout Itemize
Data una stringa di caratteri sei in grado di verificare se è palindroma
 o no?
\end_layout

\begin_layout Itemize
Su una stringa lunga N quanti controlli devono essere fatti per verificarne
 la palindromia o meno?
\end_layout

\begin_layout Itemize
Cosa cambia al controllo di palindromia se il carattere 0 può essere usato
 come 
\begin_inset Quotes eld
\end_inset

jolly
\begin_inset Quotes erd
\end_inset

?
\end_layout

\begin_layout Itemize
Una volta stabilito come verificare la 
\emph on
quasi palindromia
\emph default
, verificare se un rettangolo di caratteri è 
\emph on
quasi palindromo
\emph default
 non è altro che la ripetizione dello stesso controllo fatto su ogni colonna.
 Cambia qualcosa il fatto che il controllo debba essere fatto sulle colonne
 e non sulle righe?
\end_layout

\begin_layout Itemize
Come è possibile ottenere tutte le permutazioni di N interi? (se non lo
 ricordi vedi esempio 
\begin_inset CommandInset ref
LatexCommand ref
reference "sec:Esempio:-Domino-massimale"

\end_inset

)
\end_layout

\begin_layout Itemize
É necessario permutare realmente le righe del rettangolo, spostando ogni
 riga nella sua nuova posizione, con i costi computazionali che questo comporta?
 Oppure è possibile ottenere lo stesso risultato senza muovere righe di
 caratteri?
\end_layout

\begin_layout Itemize
Riesci a scomporre questo problema in una serie di funzionalità, in modo
 da non avere un unico grosso programma soggetto a errori, ma una serie
 di funzioni specializzate nel risolvere un solo compito?
\end_layout

\begin_layout Subsection
Soluzione
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "basicstyle={\small\ttfamily},breaklines=true,frame=lr,language={C++},numbers=left,showstringspaces=false,tabsize=4"
inline false
status collapsed

\begin_layout Plain Layout

int M, N;
\end_layout

\begin_layout Plain Layout

int cifre[8], presente[8]; 
\end_layout

\begin_layout Plain Layout

char rettangolo[8][8]; 
\end_layout

\begin_layout Plain Layout

FILE *in,*out;
\end_layout

\begin_layout Plain Layout

bool verifica_rettangolo() { 	
\end_layout

\begin_layout Plain Layout

	int i,j; 	
\end_layout

\begin_layout Plain Layout

	for (i=0;i<N;i++) 		 		
\end_layout

\begin_layout Plain Layout

		for (j=0;j<M/2;j++){ 			
\end_layout

\begin_layout Plain Layout

			int is = cifre[j]; 			
\end_layout

\begin_layout Plain Layout

			int id = cifre[M-j-1]; 			
\end_layout

\begin_layout Plain Layout

			if ((rettangolo[is][i] != rettangolo[id][i]) && (rettangolo[is][i] !=
 '0' && rettangolo[id][i]!='0'))
\end_layout

\begin_layout Plain Layout

	 		return false; 		
\end_layout

\begin_layout Plain Layout

		} 	
\end_layout

\begin_layout Plain Layout

	return true; 
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

void stampa() {	 	
\end_layout

\begin_layout Plain Layout

	int i,j; 	
\end_layout

\begin_layout Plain Layout

	for (i=0;i<M;i++) 	
\end_layout

\begin_layout Plain Layout

	{ 		
\end_layout

\begin_layout Plain Layout

		int riga = cifre[i]; 		
\end_layout

\begin_layout Plain Layout

		for (j=0;j<N;j++)
\end_layout

\begin_layout Plain Layout

			fprintf(out,"%c",rettangolo[riga][j]); 		fprintf(out,"
\backslash
n"); 	
\end_layout

\begin_layout Plain Layout

	} 
\end_layout

\begin_layout Plain Layout

} 
\end_layout

\begin_layout Plain Layout

void calcola_permutazioni(int inizio, int fine) { 	
\end_layout

\begin_layout Plain Layout

	int i; 	
\end_layout

\begin_layout Plain Layout

	if (inizio >= fine){ 		
\end_layout

\begin_layout Plain Layout

		if (verifica_rettangolo()){ 			
\end_layout

\begin_layout Plain Layout

			stampa(); 			
\end_layout

\begin_layout Plain Layout

			exit(0); 		
\end_layout

\begin_layout Plain Layout

		} 		
\end_layout

\begin_layout Plain Layout

	return; 	
\end_layout

\begin_layout Plain Layout

	} 	
\end_layout

\begin_layout Plain Layout

	for (i = 0; i < fine; i++){ 		
\end_layout

\begin_layout Plain Layout

		if (presente[i]){
\end_layout

\begin_layout Plain Layout

			cifre[inizio] = i; 
\end_layout

\begin_layout Plain Layout

			presente[i] = 0; 
\end_layout

\begin_layout Plain Layout

			calcola_permutazioni(inizio+1,fine);
\end_layout

\begin_layout Plain Layout

			presente[i]=1;  		
\end_layout

\begin_layout Plain Layout

		} 	
\end_layout

\begin_layout Plain Layout

	} 
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

int main() 
\end_layout

\begin_layout Plain Layout

{ 	
\end_layout

\begin_layout Plain Layout

	int i,j; 	
\end_layout

\begin_layout Plain Layout

	in = fopen("input.txt","r"); 	
\end_layout

\begin_layout Plain Layout

	out = fopen("output.txt","w"); 	
\end_layout

\begin_layout Plain Layout

	fscanf(in,"%d %d",&M,&N); 	
\end_layout

\begin_layout Plain Layout

	for (i=0;i<M;i++){
\end_layout

\begin_layout Plain Layout

		char temp[10]; 		
\end_layout

\begin_layout Plain Layout

		fscanf(in,"%s",temp); 		
\end_layout

\begin_layout Plain Layout

		for (j=0;j<N;j++) 			
\end_layout

\begin_layout Plain Layout

			rettangolo[i][j] = temp[j];
\end_layout

\begin_layout Plain Layout

	}     
\end_layout

\begin_layout Plain Layout

	for (i = 0; i < M; i++){ 		
\end_layout

\begin_layout Plain Layout

		presente[i]=1; 		
\end_layout

\begin_layout Plain Layout

		cifre[i]=i; 	
\end_layout

\begin_layout Plain Layout

	} 	
\end_layout

\begin_layout Plain Layout

	calcola_permutazioni(0,M);     
\end_layout

\begin_layout Plain Layout

	return 0; 
\end_layout

\begin_layout Plain Layout

} 
\end_layout

\end_inset


\end_layout

\begin_layout Standard
La soluzione utilizza un approccio a 
\begin_inset Quotes eld
\end_inset

forza bruta
\begin_inset Quotes erd
\end_inset

, come già visto nell'esempio 
\begin_inset CommandInset ref
LatexCommand ref
reference "sec:Esempio:-Domino-massimale"

\end_inset

, che risulta fattibile poichè l'input presenta al massimo 8 righe e le
 permutazioni possibil di 8 righe risultano essere 8!, quindi ampiamente
 esplorabili nei tempi richiesti.
\end_layout

\begin_layout Standard
La strategia risolutiva essenzialmente consiste nel generare tutte le possibili
 permutazioni e per ognuna verificare se ci si trova in presenza di un rettangol
o quasi-palindromo, nel qual caso stamparlo e terminare il programma.
\end_layout

\begin_layout Standard
La generazione delle permutazioni (righe 34-41) è del tutto uguale a quella
 già vista nell'esempio 
\begin_inset CommandInset ref
LatexCommand ref
reference "sec:Esempio:-Domino-massimale"

\end_inset

, dove viene utilizzato il vettore 
\emph on
cifre
\emph default
 per contenere la permutazione da costruire e il vettore 
\emph on
presente
\emph default
 per tenere traccia delle righe già usate e poter fare backtracking su tutte
 le permutazioni.
\end_layout

\begin_layout Standard
Vengono poi definite una serie di funzioni ausiliare il cui compito è piuttosto
 ovvio, ma che risultano comode per strutturare meglio il codice:
\end_layout

\begin_layout Itemize

\emph on
verifica_rettangolo
\emph default
: data una permutazione di righe controlla se il rettangolo corrispondente
 è 
\emph on
quasi palindromo
\emph default
.
 Per farlo la funzione parte dalla prima colonna e, a cominciare dagli estremi,
 confronta le coppie di cifre in posizione opposta per vedere se sono uguali
 o almeno una delle due è 0, nel qual caso passa alla colonna successiva.
 Dopo aver controllato tutte le colonne, se ognuna è risultata essere palindroma
, ritorna 
\emph on
true
\emph default
, altrimenti appena si accorge della presenza di una colonna non palindroma
 ritorna immediatamente 
\emph on
false
\emph default
.
\end_layout

\begin_layout Itemize

\emph on
stampa
\emph default
: si occupa semplicemente di stampare il rettangolo secondo quanto richiesto
 dal testo del problema
\end_layout

\begin_layout Itemize

\emph on
calcola_permutazioni
\emph default
: è la funzione ricorsiva che genera tutte le permutazioni possibili delle
 righe, ognuna delle quali verrà usata da 
\emph on
verifica_rettangolo
\emph default
 per controllare la 
\emph on
quasi palindromia
\emph default
.
\end_layout

\begin_layout Standard
Il costo dell'algoritmo sarà, nel caso pessimo, di tipo 
\begin_inset Formula $N!$
\end_inset

 moltiplicato per il costo del controllo della palindromia, che risulta
 lineare in N, ma come già detto essendo N molto piccolo non avrà problemi
 a risolvere il problema nei tempi stabiliti.
\end_layout

\begin_layout Section
Sbarramento tattico - territoriali 2010
\end_layout

\begin_layout Standard
\begin_inset Box Framed
position "t"
hor_pos "c"
has_inner_box 0
inner_pos "t"
use_parbox 0
use_makebox 0
width "100col%"
special "none"
height "1in"
height_special "totalheight"
status collapsed

\begin_layout Subsection*
Sbarramento tattico (sbarramento) 
\end_layout

\begin_layout Subsubsection*
Difficoltà D = 2.
 
\end_layout

\begin_layout Subsubsection*
Descrizione del problema
\end_layout

\begin_layout Plain Layout
L'esercito di Orchi dell'Oscuro Signore degli Anelli marcia a ranghi serrati
 verso il Fosso di Helm.
 Per contrastarne la marcia, Re Theoden decide di richiamare tutte le sue
 N armate per creare uno sbarramento unico, con le seguenti regole.
\end_layout

\begin_layout Plain Layout
Campo di battaglia: è rappresentato da una tabella di dimensione NxN, le
 cui righe e colonne sono numerate da 1 a N.
 Posizione: ognuna delle N armate occupa una posizione distinta [i,j] nella
 tabella, all'incrocio tra la riga i e la colonna j.
 Movimento: permette di passare dalla posizione corrente [i,j] a una vicina
 con un giorno di marcia: nord [i-1,j] (se i > 1), sud [i+1,j] (se i < N),
 est [i,j+1] (se j < N) e ovest [i,j-1] (se j > 1).
 Una sola armata alla volta si sposta con un movimento.
 Sbarramento: si crea ponendo tutte le armate su un'unica riga R della tabella,
 attraverso una serie di movimenti.
\end_layout

\begin_layout Plain Layout
Theoden vuole calcolare il numero minimo di movimenti necessari per spostare
 tutte le armate in un unico sbarramento sulla riga R.
 Aiutate Theoden a calcolare tale numero minimo.
 
\end_layout

\begin_layout Subsubsection*
Dati di input
\end_layout

\begin_layout Plain Layout
Il file input.txt è composto da N+1 righe.
 La prima riga contiene due interi positivi N e R, separati da uno spazio:
 il numero N di righe e di colonne nella tabella (nonché il numero di armate)
 e l'indice R della riga su cui far convergere lo sbarramento delle armate.
 Ciascuna delle successive N righe contiene una coppia di interi i e j,
 separati da uno spazio, a indicare che un'armata è presente nella posizione
 [i,j] della tabella.
 
\end_layout

\begin_layout Subsubsection*
Dati di output
\end_layout

\begin_layout Plain Layout
Il file output.txt è composto da una sola riga contenente un intero non negativo,
 il minimo numero di movimenti per posizionare tutte le armate sulla riga
 R della tabella, in posizioni distinte all'interno di tale riga.
 
\end_layout

\begin_layout Subsubsection*
Assunzioni
\end_layout

\begin_layout Itemize
2 ≤ N ≤ 500.
 
\end_layout

\begin_layout Itemize
Durante un movimento, due o più armate non possono mai occupare la stessa
 posizione intermedia.
\end_layout

\begin_layout Subsubsection*
Esempi di input/output
\end_layout

\begin_layout Plain Layout
\begin_inset Tabular
<lyxtabular version="3" rows="2" columns="2">
<features tabularvalignment="middle">
<column alignment="left" valignment="top" width="1in">
<column alignment="left" valignment="top" width="0">
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
File input.txt
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
File output.txt
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
8 3 
\end_layout

\begin_layout Plain Layout
5 5 
\end_layout

\begin_layout Plain Layout
1 6 
\end_layout

\begin_layout Plain Layout
2 2 
\end_layout

\begin_layout Plain Layout
6 5 
\end_layout

\begin_layout Plain Layout
3 2 
\end_layout

\begin_layout Plain Layout
7 1 
\end_layout

\begin_layout Plain Layout
1 2 
\end_layout

\begin_layout Plain Layout
8 1
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
31
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Suggerimenti
\end_layout

\begin_layout Standard
Il problema richiede di minimizzare la somma dei costi di una serie di spostamen
ti che portano degli elementi da una configurazione iniziale verso una configura
zione finale.
\end_layout

\begin_layout Itemize
Qual è la struttura dati da utilizzare?
\end_layout

\begin_layout Itemize
Se hai pensato a una matrice, sei sicuro che sia realmente necessaria?
\end_layout

\begin_layout Itemize
Sai calcolare il costo minimo di spostamento di un'armata dalla posizione
 
\emph on
i, j
\emph default
 alla posizione 
\emph on
r,s
\emph default
, con 
\emph on
i,j,r
\emph default
 e 
\emph on
s
\emph default
 qualsiasi?
\end_layout

\begin_layout Itemize
Gli spostamenti delle armate sono indipendenti tra di loro oppure per muovere
 un'armata ho bisogno di sapere dove si trovano tutte le altre per evitare
 di sovrapporle, come sembra indicare l'assunzione 2?
\end_layout

\begin_layout Itemize
Se hai risposto positivamente alla domanda precedente, pensaci meglio: siccome
 non viene richiesto di scrivere la sequenza di spostamenti ma solo il loro
 costo, è sempre possibile determinare una sequenza di mosse che permetta
 di spostare due armate qualsiasi in due punti qualsiasi, evitando che si
 sovrappongano? (ai fini della soluzione, non è necessario sapere quale
 sia la sequenza, basta stabilire che esista sempre)
\end_layout

\begin_layout Itemize
Presa un'armata qualsiasi, qual è il costo per spostarla in 
\begin_inset Quotes eld
\end_inset

verticale
\begin_inset Quotes erd
\end_inset

 dalla riga in cui si trova fino alla riga R, mantenendo la stessa colonna?
 
\end_layout

\begin_layout Itemize
Se tutte le armate fossero su colonne diverse il problema sarebbe di semplice
 soluzione, cosa succede invece quando due o più armate si trovano sulla
 stessa colonna? 
\end_layout

\begin_layout Itemize
Che strategia devo usare per poter minimizzare il costo dello spostamento
 di più armate che si trovano sulla stessa colonna? Ho necessità di tenere
 memoria delle posizioni sulla colonna R che sono già occupate da un'armata?
 Da che armata parto e che ordine seguo per spostarle tutte?
\end_layout

\begin_layout Itemize
Posso arrivare alla soluzione del problema senza necessità di mantenere
 un vettore che mi indichi quali sono le posizioni della riga R che sono
 già occupate?
\end_layout

\begin_layout Subsection
Soluzione
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "basicstyle={\small\ttfamily},breaklines=true,frame=lr,language={C++},numbers=left,showstringspaces=false,tabsize=4"
inline false
status collapsed

\begin_layout Plain Layout

struct armata{ 	
\end_layout

\begin_layout Plain Layout

int r,c; 
\end_layout

\begin_layout Plain Layout

};
\end_layout

\begin_layout Plain Layout

int N, R;
\end_layout

\begin_layout Plain Layout

armata armate[500]; 
\end_layout

\begin_layout Plain Layout

FILE *in,*out;
\end_layout

\begin_layout Plain Layout

int cmp(const void *a, const void *b) { 	
\end_layout

\begin_layout Plain Layout

	armata uno = *(armata *)a; 	
\end_layout

\begin_layout Plain Layout

	armata due = *(armata *)b; 	
\end_layout

\begin_layout Plain Layout

	if (uno.c > due.c) return 1; 	
\end_layout

\begin_layout Plain Layout

	if (uno.c < due.c) return -1; 	
\end_layout

\begin_layout Plain Layout

	return 0; 
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

int main() 
\end_layout

\begin_layout Plain Layout

{ 	
\end_layout

\begin_layout Plain Layout

	int i,j; 	
\end_layout

\begin_layout Plain Layout

	int mosse = 0; 	
\end_layout

\begin_layout Plain Layout

	in = fopen("input.txt","r"); 	
\end_layout

\begin_layout Plain Layout

	out = fopen("output.txt","w"); 	
\end_layout

\begin_layout Plain Layout

	fscanf(in,"%d %d",&N,&R); 	
\end_layout

\begin_layout Plain Layout

	for (i=0;i<N;i++) 		
\end_layout

\begin_layout Plain Layout

		fscanf(in,"%d %d",&armate[i].r,&armate[i].c);
\end_layout

\begin_layout Plain Layout

	qsort(armate,N,sizeof(armata),cmp); 	
\end_layout

\begin_layout Plain Layout

	for (i=0;i<N;i++) 		
\end_layout

\begin_layout Plain Layout

		mosse+=abs(armate[i].r-R) + abs(armate[i].c - (i+1));
\end_layout

\begin_layout Plain Layout

	fprintf(out,"%d
\backslash
n",mosse);     
\end_layout

\begin_layout Plain Layout

	return 0; 
\end_layout

\begin_layout Plain Layout

} 
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Questo problema in prima lettura può sembrare molto più complesso di quanto
 in realtà sia, soprattutto in considerazione della seconda assunzione,
 che porta a pensare che in qualche modo debba calcolarmi una precisa sequenza
 di mosse di cui successivamente calcolare il costo.
 In realtà, proprio perchè viene chiesto solo il costo e non le mosse necessarie
 a raggiungerlo, non bisogna preoccuparsi di quali mosse debbano fare le
 armate, ma calcolare il costo in maniera indipendente per ciascuna, come
 se fosse l'unica presente sul campo di battaglia, stando solo attenti a
 non metterle nella stessa posizione finale sulla riga R, poichè quello
 non è possibile.
\end_layout

\begin_layout Standard
Fatta questa osservazione il problema risulta molto semplice da affrontare
 e può essere risolto in due modi.
\end_layout

\begin_layout Standard
Nel primo modo possiamo osservare che il costo minimo di spostamento si
 ha se l'armata si sposta dalla riga in cui si trova fino alla riga R mantenendo
si sulla stessa colonna (possiamo dire che si sposta 
\begin_inset Quotes eld
\end_inset

ortogonalmente
\begin_inset Quotes erd
\end_inset

 alla riga).
 Poichè possono esserci più armate sulla stessa colonna e nella configurazione
 finale ogni armata dovrà essere in una colonna diversa da quella di tutte
 le altre, non è possibile spostare semplicemente ogni armata in modo ortogonale
, poichè potrebbe finire su una casella già occupata.
 Se però si tiene traccia delle caselle già occupate e ci si sposta nella
 prima casella libera della riga R a destra o a sinistra della colonna di
 partenza dell'armata, si ottiene il costo minimo complessivo.
 Da che armata si parte e in che ordine? Anche se potrebbe non sembrare
 così ovvio, l'ordine con cui si vanno a inserire le armate è indifferente,
 a patto di seguire esattamente quanto specificato sopra, poichè a ordini
 diversi corrispondono mosse diverse, ma ogni eventuale costo aggiuntivo
 per ogni armata che si deve spostare di colonna viene compensato dal guadagno
 fatto da altre armate e alla fine il costo è il medesimo.
\end_layout

\begin_layout Standard
Il secondo modo, quello proposto nel codice, sfrutta una specie di approccio
 
\emph on
greedy
\emph default
, partendo da questa osservazione: se ordino le armate per colonne crescenti,
 posso partire dalla prima e inserirla nella prima posizione della riga
 R, la seconda nella seconda posizione, fino ad arrivare all'ultima.
 Questo modo di procedere mi garantisce di avere il costo minimo per motivi
 analoghi a quelli visti nell'approccio precedente: ogni volta che inserisco
 un'armata, se anche il suo costo non sarà il minimo assoluto, verrà compensato
 dai vantaggi che avranno altre armate nei posizionamenti successivi.
 Perché ciò funzioni è necessario che si proceda prima all'ordinamento,
 altrimenti non è detto che gli svantaggi pagati da alcune armate vengano
 compensati con i vantaggi ricevuti da altre.
\end_layout

\begin_layout Standard
Rispetto al primo modo non serve aggiungere una struttura dati supplementare,
 un vettore, per tenere traccia dei posti che vengono via via occupati e
 questo rende il codice più semplice e veloce da implementare.
 Come infatti si vede bisogna solo definire la funzione per il confronto
 (righe 7-13) necessaria al 
\emph on
qsort
\emph default
, che servirà per ordinare gli elementi di tipo 
\emph on
armata
\emph default
 (righe 1-3).
 Una volta che il vettore di armate risulta ordinato per colonne crescenti
 è sufficiente scandirlo e calcolare la distanza di ogni armata dalla posizione
 i-esima della riga R (righe 24-25).
\end_layout

\begin_layout Standard
Volendo confrontare i due metodi in termini di complessità computazionale
 si pùò vedere che il primo metodo ha un costo N moltiplicato per il numero
 di confronti che devono essere fatti per stabilire in quale casella inserire
 l'armata e nel caso pessimo (tutte le armate nella prima colonna) il costo
 complessivo diventa di tipo quadratico.
 Nel secondo caso invece abbiamo il costo dell'ordinamento (
\begin_inset Formula $NlogN)$
\end_inset

 più il costo del calcolo che invece è di tipo lineare, che rimane tale
 anche nel caso pessimo.
 In ogni caso sono ambedue compatibili con la dimensione dell'input del
 problema.
\end_layout

\begin_layout Section
Sequenza per tamburello - territoriali 2010
\end_layout

\begin_layout Standard
\begin_inset Box Framed
position "t"
hor_pos "c"
has_inner_box 0
inner_pos "t"
use_parbox 0
use_makebox 0
width "100col%"
special "none"
height "1in"
height_special "totalheight"
status collapsed

\begin_layout Subsection*
Sequenza per tamburello (tamburello) 
\end_layout

\begin_layout Subsubsection*
Difficoltà D = 1.
 
\end_layout

\begin_layout Subsubsection*
Descrizione del problema
\end_layout

\begin_layout Plain Layout
Marco ha trovato alcune antiche sequenze in un manoscritto.
 Ogni sequenza è composta da N pallini pieni o vuoti e rappresenta un brano
 da suonare al tamburello in N istanti consecutivi di tempo: all'i-esimo
 istante, il tamburello viene percosso se l'i-esimo pallino è pieno e, invece,
 non viene percosso se tale pallino è vuoto (1 <= i <= N).
\end_layout

\begin_layout Plain Layout
Marco vuole capire se una data sequenza è periodica: in tal caso, vuole
 estrarne il periodo, ossia il più piccolo segmento iniziale che si ripete
 nel resto della sequenza.
 In altre parole, se P è la sequenza di pallini pieni e vuoti che rappresenta
 il periodo, allora la sequenza in input è periodica se può essere ottenuta
 concatenando P per due o più volte e tale P deve essere di lunghezza minima.
\end_layout

\begin_layout Plain Layout
Per esempio, rappresentando con 1 ogni pallino pieno e con 0 ogni pallino
 vuoto, la sequenza periodica 101010101010 ha 10 come periodo e la sequenza
 1010010100010100101000 ha 10100101000 come periodo.
 Invece, la sequenza 11011011 non è periodica.
 Aiutate Marco in questo compito, in modo che possa imparare a suonare velocemen
te tali brani per tamburello.
 
\end_layout

\begin_layout Subsubsection*
Dati di input
\end_layout

\begin_layout Plain Layout
Il file input.txt è composto da due righe.
 La prima riga contiene un intero positivo N, che indica il numero di pallini
 nella sequenza.
 La seconda riga contiene una sequenza di interi 0 e 1, separati da uno
 spazio, dove 1 rappresenta un pallino pieno e 0 un pallino vuoto.
 
\end_layout

\begin_layout Subsubsection*
Dati di output
\end_layout

\begin_layout Plain Layout
Il file output.txt è composto da una sola riga contenente l'intero 2 se la
 sequenza in input non è periodica.
 Altrimenti, se è periodica, la riga contiene la sequenza di 0 e 1, separati
 da uno spazio, che rappresenta il periodo P della sequenza fornita in input.
 
\end_layout

\begin_layout Subsubsection*
Assunzioni
\end_layout

\begin_layout Plain Layout
2 ≤ N ≤ 100000.
\end_layout

\begin_layout Subsubsection*
Esempi di input/output
\end_layout

\begin_layout Plain Layout
\begin_inset Tabular
<lyxtabular version="3" rows="2" columns="2">
<features tabularvalignment="middle">
<column alignment="left" valignment="top" width="1in">
<column alignment="left" valignment="top" width="0">
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
File input.txt
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
File output.txt
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
12 
\end_layout

\begin_layout Plain Layout
1 0 1 0 1 0 1 0 1 0 1 0
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
1 0 
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Suggerimenti per la soluzione
\end_layout

\begin_layout Standard
Il problema chiede di cercare la più piccola sottosequenza che si ripete
 integralmente su tutta la sequenza iniziale, che in altre parole può essere
 definito come il problema di trovare il periodo di un vettore.
\end_layout

\begin_layout Itemize
Qual è la struttura dati che bisogna utilizzare (piuttosto ovvio)?
\end_layout

\begin_layout Itemize
Prova a risolvere il problema per un caso più piccolo, in particolare il
 più piccolo possibile è quello in cui il periodo è lungo 
\begin_inset Formula $N/2$
\end_inset

 e si ripete due volte.
 Cosa bisogna utilizzare per risolvere questo problema (un ciclo 
\emph on
for
\emph default
, un 
\emph on
while
\emph default
, ecc.)?
\end_layout

\begin_layout Itemize
Sei in grado di riscrivere il problema per un periodo di lunghezza 
\begin_inset Formula $N/3$
\end_inset

?
\end_layout

\begin_layout Itemize
Confronta le soluzioni dei due problemi precedenti per 
\begin_inset Formula $N/2$
\end_inset

 e 
\begin_inset Formula $N/3$
\end_inset

: sei in grado di generalizzare la soluzione per un periodo 
\begin_inset Formula $N/k$
\end_inset

, con 
\begin_inset Formula $k$
\end_inset

 un valore intero qualsiasi?
\end_layout

\begin_layout Itemize
Se dai punti precedenti sei stato in grado di generalizzazione la soluzione
 al periodo 
\begin_inset Formula $N/k$
\end_inset

 puoi provare tutti i periodi per trovare il più piccolo?
\end_layout

\begin_layout Itemize
Conviene partire da 
\begin_inset Formula $k=2$
\end_inset

 e procedere con periodi decrescenti 
\begin_inset Formula $N/2,N/3,...,3,2,1$
\end_inset

 oppure conviene partire dal periodo più piccolo e aumentarne la grandezza
 per fermarsi al primo trovato?
\end_layout

\begin_layout Itemize
Ma 
\begin_inset Formula $k$
\end_inset

 può assumere qualsiasi valore o alcuni possono essere scartati a priori?
 In altri termini il periodo di una sequenza di lunghezza N può avere qualsiasi
 valore o è vincolato solo ad alcuni possibili?
\end_layout

\begin_layout Itemize
Ha senso escludere a priori le sequenze di lunghezza pari a un numero primo,
 provando solo se hanno periodo 1, oppure questo implicitamente è un controllo
 che si fa già se abbiamo risposto alla domanda precedente?
\end_layout

\begin_layout Subsection
Soluzione
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "basicstyle={\small\ttfamily},breaklines=true,frame=lr,language={C++},numbers=left,showstringspaces=false,tabsize=4"
inline false
status collapsed

\begin_layout Plain Layout

int sequenza[100000]; 
\end_layout

\begin_layout Plain Layout

int N;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

bool corrispondenza(int inizio, int periodo) { 	
\end_layout

\begin_layout Plain Layout

	int i; 	
\end_layout

\begin_layout Plain Layout

	for(i=0;i<periodo;i++) 		
\end_layout

\begin_layout Plain Layout

		if (sequenza[i]!=sequenza[i+inizio]) 			
\end_layout

\begin_layout Plain Layout

			return false; 	
\end_layout

\begin_layout Plain Layout

	return true; 
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

bool trova_periodo(int periodo) { 	
\end_layout

\begin_layout Plain Layout

	int i; 	
\end_layout

\begin_layout Plain Layout

	for (i=periodo;i<N;i+=periodo) 		
\end_layout

\begin_layout Plain Layout

		if (!corrispondenza(i,periodo)) 			
\end_layout

\begin_layout Plain Layout

			return false; 	
\end_layout

\begin_layout Plain Layout

	return true; 
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

int main() 
\end_layout

\begin_layout Plain Layout

{ 	
\end_layout

\begin_layout Plain Layout

	int i,j; 	
\end_layout

\begin_layout Plain Layout

	FILE *in = fopen("input.txt","r"); 	
\end_layout

\begin_layout Plain Layout

	FILE *out = fopen("output.txt","w"); 	
\end_layout

\begin_layout Plain Layout

	fscanf(in,"%d",&N); 	
\end_layout

\begin_layout Plain Layout

	for (i=0;i<N;i++) 		
\end_layout

\begin_layout Plain Layout

		fscanf(in,"%d",&sequenza[i]); 	
\end_layout

\begin_layout Plain Layout

	for (i=1;i<=N/2;i++) 		
\end_layout

\begin_layout Plain Layout

		if(N%i == 0) 
\end_layout

\begin_layout Plain Layout

			if (trova_periodo(i))
\end_layout

\begin_layout Plain Layout

			{ 				
\end_layout

\begin_layout Plain Layout

				for (j=0;j<i;j++) 					
\end_layout

\begin_layout Plain Layout

					fprintf(out,"%d ",sequenza[j]); 				
\end_layout

\begin_layout Plain Layout

				exit(0); 			
\end_layout

\begin_layout Plain Layout

			}	 	
\end_layout

\begin_layout Plain Layout

	fprintf(out,"2");     
\end_layout

\begin_layout Plain Layout

	return 0; 
\end_layout

\begin_layout Plain Layout

} 
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Dopo aver letto l'input (righe 23-27), il ciclo 
\emph on
for
\emph default
 di riga 28 scorre tutti i periodi possibili, a partire da quello di lunghezza
 1 fino a quello di lunghezza 
\begin_inset Formula $N/2$
\end_inset

, fermandosi (riga 34) e stampando direttamente il risultato al primo periodo
 incontrato, che quindi è sicuramente il più piccolo.
 Per verificare se esiste un periodo vengono utilizzate due funzioni: la
 funzione 
\emph on
trova_periodo
\emph default
 riceve come input il periodo da testare (riga 30), restituendo 
\emph on
true
\emph default
 o 
\emph on
false
\emph default
 se il periodo viene trovato o meno; questa funzione usa poi 
\emph on
corrispondenza
\emph default
 che verifica se i primi 
\emph on
periodo
\emph default
 elementi del vettore sono uguali a quelli spostati in avanti di una quantità
 
\emph on
inizio
\emph default
, multipla del periodo che si sta testando (righe 6-7).
 Dalla figura 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:Esempio-Tamburello"

\end_inset

 si può vedere l'idea sul test del periodo 4: 
\emph on
trova_periodo
\emph default
 verifica prima se i primi quattro elementi sono uno a uno uguali ai quattro
 elementi che partono dall'indice 4, poi ripete la stessa cosa confrontando
 i primi quattro elementi con i quattro che partono dall'indice 8.
 
\end_layout

\begin_layout Standard
Si può infine notare come alla riga 29 venga controllato se il periodo che
 si vuole testare è un sottomultiplo della lunghezza del vettore, poichè,
 se non lo è, si passa direttamente al candidato successivo, non essendo
 possibile che quello sia un periodo esatto del vettore.
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement h
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename ../materiali/problemi territoriali/2010_tamburello/tamburello.eps
	display false
	scale 55

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:Esempio-Tamburello"

\end_inset

Esempio di esecuzione
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Questa soluzione ha un costo computazionale che può essere approssimativamente
 calcolato in questo modo:
\end_layout

\begin_layout Itemize
ogni volta che testiamo un periodo vengono controllati tutti gli elementi
 del vettore, quindi questo passaggio richiede circa N confronti (nel caso
 vengano fatti tutti, altrimenti meno)
\end_layout

\begin_layout Itemize
quanti periodi vengono testati? Nel caso peggiore in cui la sequenza non
 è periodica e quindi devo testarli tutti primi di accorgemene, i periodi
 possibili sono solo quelli che dividono esattamente la lunghezza del vettore,
 quindi il numero dei suoi divisori.
 Sicuramente questo numero è minore di 
\begin_inset Formula $N/2$
\end_inset

, bisognerebbe poi vedere di quanto, il che è un problema di teoria dei
 numeri che esula dalla presente trattazione.
 Se il numero N fosse una potenza del 2 avremmo un numero di periodi possibili
 pari a 
\begin_inset Formula $log_{2}N$
\end_inset

, per situazioni diverse è molto più difficile da stimare, ma si può presumere
 che non cresca in modo lineare e quindi l'algoritmo nel complesso sia subquadra
tico.
\end_layout

\begin_layout Section
Eserciti galattici - territoriali 2011
\end_layout

\begin_layout Standard
\begin_inset Box Framed
position "t"
hor_pos "c"
has_inner_box 0
inner_pos "t"
use_parbox 0
use_makebox 0
width "100col%"
special "none"
height "1in"
height_special "totalheight"
status collapsed

\begin_layout Subsection*
Eserciti Galattici (galattici) 
\end_layout

\begin_layout Subsubsection*
Difficoltà D = 2 
\end_layout

\begin_layout Subsubsection*
Descrizione del problema 
\end_layout

\begin_layout Plain Layout
L'esercito della Signoria è riuscito a costruire un'arma segreta: il temibile
 Sarcofago Nero.
 Esso legge una parola segreta S costituita da lettere minuscole dell'alfabeto:
 a, b, c, ..., z (ogni lettera può comparire zero, una o più volte).
 Il Sarcofago Nero può assumere N configurazioni al suo interno, numerate
 da 1 a N.
 La parola segreta S viene accettata se raggiunge la configurazione finale
 (avente numero N) a partire dalla configurazione iniziale (avente numero
 1) dopo aver letto tutte le lettere in S una alla volta.
 Per ogni configurazione I del Sarcofago Nero, la tripletta (I,J,c) indica
 che la lettera c lo fa transitare dalla configurazione I alla configurazione
 J.
 L'esercito rivale ha carpito una parola segreta S, ma non sa se è quella
 del Sarcofago Nero.
 Il tuo compito è quello di trovare la configurazione interna Q che esso
 raggiunge, dopo aver letto S, a partire dalla configurazione iniziale.
 
\end_layout

\begin_layout Subsubsection*
Dati di input 
\end_layout

\begin_layout Plain Layout
Il file input.txt è composto da M+2 righe.
 La prima riga contiene tre interi positivi separati da uno spazio, che
 rappresentano il numero M delle triplette, il numero N di configurazioni
 e il numero K di lettere nella sequenza S.
 La seconda riga contiene K lettere separate da uno spazio, le quali formano
 la sequenza S.
 Ciascuna delle rimanenti M righe contiene due interi positivi I e J e una
 lettera c, separati da una spazio, che rappresentano la tripletta (I,J,c)
 per la transizione del Sarcofago Nero.
 
\end_layout

\begin_layout Subsubsection*
Dati di output 
\end_layout

\begin_layout Plain Layout
Il file output.txt è composto da una sola riga contenente il numero Q della
 configurazione raggiunta dal Sarcofago Nero a partire dalla sua configurazione
 iniziale (avente numero 1), dopo aver letto tutta la sequenza S.
 
\end_layout

\begin_layout Subsubsection*
Assunzioni 
\end_layout

\begin_layout Itemize
2 ≤ M ≤ 100.
 
\end_layout

\begin_layout Itemize
2 ≤ N ≤ 100.
 
\end_layout

\begin_layout Itemize
2 ≤ K ≤ 10.
 
\end_layout

\begin_layout Itemize
1 ≤ Q ≤ N.
 
\end_layout

\begin_layout Subsubsection*
Esempi di input/output 
\end_layout

\begin_layout Plain Layout
\begin_inset Tabular
<lyxtabular version="3" rows="2" columns="2">
<features tabularvalignment="middle">
<column alignment="left" valignment="top" width="1in">
<column alignment="left" valignment="top" width="0">
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
File input.txt 
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
File output.txt
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
5 3 6 
\end_layout

\begin_layout Plain Layout
a a a b a b 
\end_layout

\begin_layout Plain Layout
1 3 a 
\end_layout

\begin_layout Plain Layout
1 2 b 
\end_layout

\begin_layout Plain Layout
2 1 a 
\end_layout

\begin_layout Plain Layout
3 2 b 
\end_layout

\begin_layout Plain Layout
3 3 a
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
2
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Suggerimenti
\end_layout

\begin_layout Standard
Il problema richiede di applicare una serie di regole per spostarsi da uno
 stato iniziale conosciuto ad uno finale sconosciuto.
\end_layout

\begin_layout Itemize
Data una regola composta da uno stato iniziale e un input (la lettera della
 parola segreta) posso stabilire a che lettera andrò a finire tramite un
 
\emph on
if
\emph default
?
\end_layout

\begin_layout Itemize
Ma non sapendo al momento della stesura del codice quali saranno le regole
 che dovrò applicare posso rappresentarle tramite una serie di 
\emph on
if
\emph default
?
\end_layout

\begin_layout Itemize
Allora se l'approcio precedente non è possibile, come può essere rappresentata
 una regola?
\end_layout

\begin_layout Itemize
E un insieme di regole?
\end_layout

\begin_layout Itemize
Se riesco a rappresentare correttamente un insieme di regole posso iterare
 il procedimento su ogni singola lettera per arrivare alla lettera finale?
\end_layout

\begin_layout Subsection
Soluzione
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "basicstyle={\small\ttfamily},breaklines=true,frame=lr,language={C++},numbers=left,showstringspaces=false,tabsize=4"
inline false
status collapsed

\begin_layout Plain Layout

int M,N,K; 
\end_layout

\begin_layout Plain Layout

char parola[11]; 
\end_layout

\begin_layout Plain Layout

int I,J; 
\end_layout

\begin_layout Plain Layout

char c;
\end_layout

\begin_layout Plain Layout

struct transizione{ 	
\end_layout

\begin_layout Plain Layout

	int I,J; 	
\end_layout

\begin_layout Plain Layout

	char c; 
\end_layout

\begin_layout Plain Layout

};
\end_layout

\begin_layout Plain Layout

transizione t[100];
\end_layout

\begin_layout Plain Layout

int main() 
\end_layout

\begin_layout Plain Layout

{ 	
\end_layout

\begin_layout Plain Layout

	ifstream in("input.txt"); 	
\end_layout

\begin_layout Plain Layout

	ofstream out("output.txt"); 	
\end_layout

\begin_layout Plain Layout

	in >> M >> N >> K; 	
\end_layout

\begin_layout Plain Layout

	for(int i = 0; i < K; i++)
\end_layout

\begin_layout Plain Layout

		in >> parola[i]; 	
\end_layout

\begin_layout Plain Layout

	for(int i = 0; i < M; i++) 		
\end_layout

\begin_layout Plain Layout

		in >> t[i].I >> t[i].J >> t[i].c; 	 	
\end_layout

\begin_layout Plain Layout

	int stato_attuale = 1; 	
\end_layout

\begin_layout Plain Layout

	for(int i = 0; i < K; i++){ 		
\end_layout

\begin_layout Plain Layout

		int j = 0; 		
\end_layout

\begin_layout Plain Layout

		while (t[j].c != parola[i] || t[j].I != stato_attuale) 
\end_layout

\begin_layout Plain Layout

			j++; 		
\end_layout

\begin_layout Plain Layout

		stato_attuale = t[j].J; 	
\end_layout

\begin_layout Plain Layout

	}  	
\end_layout

\begin_layout Plain Layout

	out << stato_attuale; 	
\end_layout

\begin_layout Plain Layout

	return 0; 
\end_layout

\begin_layout Plain Layout

} 
\end_layout

\end_inset


\end_layout

\begin_layout Standard
La parte più difficile di questo problema è, a detta di molti tra cui io,
 la comprensione del testo, che risulta in alcuni punti disorientante.
 Se comunque, anche grazie all'esempio, si riesce a penetrarne il significato,
 ci si accorge di trovarsi di fronte all'implementazione di una semplice
 macchina a stati finiti, dove le regole descrivono le transizioni tra stati.
 Per capire meglio il funzionamento si può vedere la figura 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:Macchina-a-stati"

\end_inset

, dove è stata rappresentata la macchina che risulta dalle regole date nel
 caso di esempio.
 Gli stati della macchina sono rappresentati dai nodi del grafo, mentre
 ogni regola è un arco orientato: ad esempio la regola rappresentata dalla
 tripletta (1, 3, a) nel disegno è l'arco che esce dal nodo 1 e entra nel
 nodo 3 con segnata la 
\emph on
a
\emph default
.
 Partendo dal nodo 1 e seguendo il flusso delle regole come mostrato nella
 tabella in figura è evidente come si possa arrivare alla soluzione richiesta.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename ../materiali/problemi territoriali/2011_galattici/galattici.eps
	display false
	scale 50

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:Macchina-a-stati"

\end_inset

Macchina a stati finiti
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Ogni regola può essere rappresentata come una struttura contenente le informazio
ni su stato iniziale, stato finale e lettera (righe 5-8), in modo da poter
 creare poi il vettore contenente le regole (riga 9).
 Basterà a questo punto scandire tutte le lettere della parola segreta (riga
 20), che agiscono da input sulla macchina a stati e, scorrendo tutte le
 regole (riga 22), trovare quella corretta da applicare, in modo da avere
 una transizione di stato e poter reiterare il procedimento.
 Lo stato in cui si troverà la macchina alla fine della lettura della parola
 segreta sarà quindi il risultato cercato.
\end_layout

\begin_layout Section
Nanga Parbat - territoriali 2011
\end_layout

\begin_layout Standard
\begin_inset Box Framed
position "t"
hor_pos "c"
has_inner_box 0
inner_pos "t"
use_parbox 0
use_makebox 0
width "100col%"
special "none"
height "1in"
height_special "totalheight"
status collapsed

\begin_layout Subsection*
Nanga Parbat (nanga) 
\end_layout

\begin_layout Subsubsection*
Difficoltà D = 1 
\end_layout

\begin_layout Subsubsection*
Descrizione del problema 
\end_layout

\begin_layout Plain Layout
Durante la lunga scalata delle cime attorno al Nanga Parbat, Reinhold Messner
 riesce a trasmettere al campo base, a intervalli regolari, solo il dislivello
 percorso rispetto all'ultima trasmissione.
 Se invia un numero positivo P, allora è salito di P metri rispetto alla
 precedente trasmissione; se invia un numero negativo -P, allora è sceso
 di P metri rispetto alla precedente trasmissione; se infine invia P=0,
 non ha cambiato altitudine.
 Messner parte dal campo base a 5000 metri.
 I suoi collaboratori al campo base ricevono tali rilevamenti: aiutali a
 identificare l'altitudine che risulta più frequentemente rilevata in questo
 modo.
 
\end_layout

\begin_layout Plain Layout
Dati di input 
\end_layout

\begin_layout Plain Layout
Il file input.txt è composto da N+1 righe.
 La prima riga contiene l'intero positivo N, il numero dei rilevamenti trasmessi
 da Messner.
 Ciascuna delle successive N righe contiene un intero che rappresenta il
 dislivello percorso rispetto alla precedente trasmissione.
 
\end_layout

\begin_layout Subsubsection*
Dati di output 
\end_layout

\begin_layout Plain Layout
Il file output.txt è composto da una sola riga contenente l'altitudine che
 risulta più frequentemente rilevata in questo modo dal campo base.
 
\end_layout

\begin_layout Subsubsection*
Assunzioni 
\end_layout

\begin_layout Itemize
2 ≤ N ≤ 1000.
 
\end_layout

\begin_layout Itemize
-100 ≤ P ≤ 100.
 
\end_layout

\begin_layout Subsubsection*
Esempi di input/output 
\end_layout

\begin_layout Plain Layout
\begin_inset Tabular
<lyxtabular version="3" rows="2" columns="2">
<features tabularvalignment="middle">
<column alignment="left" valignment="top" width="1in">
<column alignment="left" valignment="top" width="0">
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
File input.txt
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
File output.txt
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
8 
\end_layout

\begin_layout Plain Layout
3 
\end_layout

\begin_layout Plain Layout
-1 
\end_layout

\begin_layout Plain Layout
6 
\end_layout

\begin_layout Plain Layout
-7 
\end_layout

\begin_layout Plain Layout
1 
\end_layout

\begin_layout Plain Layout
4 
\end_layout

\begin_layout Plain Layout
0 
\end_layout

\begin_layout Plain Layout
-4 
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
5002
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Subsubsection*
Nota/e 
\end_layout

\begin_layout Itemize
L'altitudine iniziale viene rilevata ai fini della risposta.
 
\end_layout

\begin_layout Itemize
Viene garantito nei dati di input che l'altitudine più frequentemente rilevata
 è unica.
 
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Suggerimenti
\end_layout

\begin_layout Standard
Il problema richiede di contare quante volte ogni numero è presente all'interno
 di un insieme e trovare il massimo numero di occorrenze.
\end_layout

\begin_layout Itemize
Dato un insieme di N numeri, che struttura useresti per memorizzare il numero
 di volte che compare ognuno di essi?
\end_layout

\begin_layout Itemize
Sapendo che i numeri sono interi, è possibile migliorare il modo in cui
 vengono memorizzati? 
\end_layout

\begin_layout Itemize
Se non fossero interi potresti fare le stesse cose?
\end_layout

\begin_layout Itemize
Usando il numero come indice del vettore e il valore come contatore del
 numero di volte che quel numero compare, lo spazio occupato dal vettore
 verrebbe sfruttato bene? In quali condizioni questo approcio non sarebbe
 più possibile?
\end_layout

\begin_layout Subsection
Soluzione
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "basicstyle={\small\ttfamily},breaklines=true,frame=lr,language={C++},numbers=left,showstringspaces=false,tabsize=4"
inline false
status collapsed

\begin_layout Plain Layout

int N; 
\end_layout

\begin_layout Plain Layout

int alt = 100000; 
\end_layout

\begin_layout Plain Layout

int quote[200001]; 
\end_layout

\begin_layout Plain Layout

int main() 
\end_layout

\begin_layout Plain Layout

{ 	
\end_layout

\begin_layout Plain Layout

	int temp; 	
\end_layout

\begin_layout Plain Layout

	ifstream in("input.txt"); 	
\end_layout

\begin_layout Plain Layout

	ofstream out("output.txt"); 	
\end_layout

\begin_layout Plain Layout

	in >> N; 	
\end_layout

\begin_layout Plain Layout

	for (int i = 0; i < N; i++){ 		
\end_layout

\begin_layout Plain Layout

		in >> temp; 		
\end_layout

\begin_layout Plain Layout

		alt += temp; 		
\end_layout

\begin_layout Plain Layout

		quote[alt]++; 
\end_layout

\begin_layout Plain Layout

	} 	
\end_layout

\begin_layout Plain Layout

	int max = 0, quanti = quote[0]; 	
\end_layout

\begin_layout Plain Layout

	for (int i = 0; i<200001 ; i++) 		
\end_layout

\begin_layout Plain Layout

		if (quote[i]>quanti){
\end_layout

\begin_layout Plain Layout

			max = i; 			
\end_layout

\begin_layout Plain Layout

			quanti = quote[i]; 		
\end_layout

\begin_layout Plain Layout

	} 	
\end_layout

\begin_layout Plain Layout

	out << max - 95000; 	
\end_layout

\begin_layout Plain Layout

	return 0; 
\end_layout

\begin_layout Plain Layout

} 
\end_layout

\end_inset


\end_layout

\begin_layout Standard
La prima soluzione si serve di un vettore in maniera 
\begin_inset Quotes eld
\end_inset

non standard
\begin_inset Quotes erd
\end_inset

, nel senso che al posto di memorizzare i dati in certe posizioni come avviene
 solitamente, usa gli indici del vettore come valore delle quote e i valori
 corrispondenti come numero delle volte che quella quota è stata raggiunta.
 In questo modo per ogni nuova lettura del dislivello è immediato calcolare
 la quota raggiunta e usare questo dato come indice nel vettore, incrementando
 di uno il valore corrispondente, per indicare che quella quota è stata
 raggiunta un'altra volta (righe 10-14).
\end_layout

\begin_layout Standard
Alla fine della lettura di tutti i dislivelli nel vettore delle quote si
 avranno una serie di valori ed è sufficiente trovare l'indice corrispondente
 al valore massimo per avere la soluzione del problema (righe 15-20).
\end_layout

\begin_layout Standard
Gli unici due aspetti a cui prestare attenzione sono i seguenti:
\end_layout

\begin_layout Itemize
per come sono le assunzioni, cioè massimo 1000 rilevazioni e ogni dislivello
 limitato a 100 in valore assoluto, la massima altezza che sarebbe possibile
 raggiungere è di 105000 e la minima di -95000 (poichè la quota di partenza
 è di 5000 metri).
 Quindi il vettore deve avere 200001 elementi per poter contenere tutti
 i casi possibili, anche se ovviamente la maggior parte dello spazio risulterà
 sprecata
\end_layout

\begin_layout Itemize
siccome gli indici del vettore sono solo positivi mentre le quote potrebbero
 anche essere negative, si suppone di partire da metà vettore, cioè a quota
 100000, si fanno tutti i calcoli e solo alla fine si va a rimettere a posto
 il risultato sottraendo 95000 (riga 21), che è l'
\emph on
offset
\emph default
 che è stato aggiunto all'inizio per evitare quote negative.
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "basicstyle={\small\ttfamily},breaklines=true,frame=lr,language={C++},numbers=left,showstringspaces=false,tabsize=4"
inline false
status collapsed

\begin_layout Plain Layout

int N; 
\end_layout

\begin_layout Plain Layout

map <int , int> m; 
\end_layout

\begin_layout Plain Layout

int alt = 5000; 
\end_layout

\begin_layout Plain Layout

pair<map<int,int>::iterator,bool> ret;
\end_layout

\begin_layout Plain Layout

int main(int argc, char** argv) 
\end_layout

\begin_layout Plain Layout

{ 	
\end_layout

\begin_layout Plain Layout

	int temp; 	
\end_layout

\begin_layout Plain Layout

	ifstream in("input.txt"); 	
\end_layout

\begin_layout Plain Layout

	ofstream out("output.txt"); 	
\end_layout

\begin_layout Plain Layout

	in >> N; 	
\end_layout

\begin_layout Plain Layout

	for (int i = 0; i < N; i++){ 		
\end_layout

\begin_layout Plain Layout

		in >> temp; 		
\end_layout

\begin_layout Plain Layout

		alt += temp; 		
\end_layout

\begin_layout Plain Layout

		ret = m.insert(pair<int,int>(alt,1)); 		
\end_layout

\begin_layout Plain Layout

		if (ret.second == false) 			
\end_layout

\begin_layout Plain Layout

			ret.first->second++; 	
\end_layout

\begin_layout Plain Layout

	} 	
\end_layout

\begin_layout Plain Layout

	int max = i->first; 	
\end_layout

\begin_layout Plain Layout

	int quanti = i->second; 	
\end_layout

\begin_layout Plain Layout

	for (map<int,int>::iterator i = m.begin(); i!=m.end();i++)
\end_layout

\begin_layout Plain Layout

		if (i->second > quanti){			
\end_layout

\begin_layout Plain Layout

			max = i->first; 			
\end_layout

\begin_layout Plain Layout

			quanti = i->second; 		
\end_layout

\begin_layout Plain Layout

		} 	
\end_layout

\begin_layout Plain Layout

	out << max; 	
\end_layout

\begin_layout Plain Layout

	return 0; 
\end_layout

\begin_layout Plain Layout

} 
\end_layout

\end_inset


\end_layout

\begin_layout Standard
La prima soluzione proposta è molto efficiente, ma avrebbe dei problemi
 nel caso che le assunzioni fossero diverse e costringessero ad avere vettori
 più grandi per memorizzare le quote visitate.
 Se ad esempio il dislivello massimo tra una trasmissione e la successiva
 fosse di 100000 al posto che di 100, avremmo bisogno di un vettore di 
\begin_inset Formula $100000\times1000\times2$
\end_inset

 elementi, cioè 200.000.000 di elementi, che è una dimensione enorme, in genere
 oltre il limite che viene posto nelle gare e questo nonostante i posti
 che poi verrebbero utilizzati sarebbero al massimo 999 (poichè per le ipotesi
 del problema almeno una quota doppia è presente).
\end_layout

\begin_layout Standard
Per risolvere il problema si potrebbe utilizzare una 
\emph on
map
\emph default
, uno dei contenitori standard del C++, chiamato anche 
\emph on
array associativo
\emph default
, che come un normale array serve a contenere una sequenza di valori omogenei,
 solo che al posto di poterli indirizzare solo tramite un indice numerico,
 permette di usare qualsiasi tipo di etichetta per contrassegnare una posizione
 nel vettore.
 
\end_layout

\begin_layout Standard
In questo caso verrebbe ancora utilizzato un indice numerico, solo che a
 differenza di un vettore normale, solo le caselle corrispondenti a una
 quota raggiunta verrebbero create e quindi la quantità di spazio utilizzata
 sarebbe sembre al massimo proporzionale a 999, indipendentemente dalla
 grandezza dei dislivelli massimi, come si può vedere nell'esempio di figura
 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:Vettore-mappa"

\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename ../materiali/problemi territoriali/2011_nanga/nanga.eps
	display false
	scale 50

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:Vettore-mappa"

\end_inset

Confronto tra vettore e mappa
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Le uniche difficoltà in questo tipo di soluzione risiedono nell'utilizzo
 della 
\emph on
map
\emph default
, che può risultare poco chiaro per chi non l'ha mai utilizzata.
 Come si vede nel codice per ogni dislivello letto viene creata una coppia
 tramite il container 
\emph on
pair
\emph default
, in cui il primo elemento è la quota attuale e il secondo viene messo a
 1, per indicare che la quota è stata raggiunta una volta, e questa coppia
 viene inserita nella 
\emph on
map
\emph default
 (riga 14).
 Il metodo 
\emph on
insert
\emph default
 ritorna a sua volta una coppia, il cui primo elemento è un iteratore all'elemen
to della mappa inserito e il secondo vale 
\emph on
true
\emph default
 se il 
\emph on
pair
\emph default
 è stato aggiunto correttamente (cioè se è la prima volta che la quota viene
 inserita nella mappa) oppure 
\emph on
false
\emph default
 se la quota è già presente nella mappa.
 In quest'ultimo caso bisogna quindi incrementare il valore indicizzato
 dalla quota (righe 15-16).
\end_layout

\begin_layout Standard
Terminato l'inserimento è necessario, come per il vettore della soluzione
 precedente, cercare il massimo: in questo caso non è possibile scandire
 la mappa utilizzando un indice, ma bisogna usare un iteratore (righe 20-24).
\end_layout

\begin_layout Section
Gran Prix - territoriali 2012
\end_layout

\begin_layout Standard
\begin_inset Box Framed
position "t"
hor_pos "c"
has_inner_box 0
inner_pos "t"
use_parbox 0
use_makebox 0
width "100col%"
special "none"
height "1in"
height_special "totalheight"
status collapsed

\begin_layout Subsection*
Gran Prix (granprix)
\end_layout

\begin_layout Subsubsection*
Difficoltà D = 1.
 
\end_layout

\begin_layout Subsubsection*
Descrizione del problema
\end_layout

\begin_layout Plain Layout
State assistendo a un Gran Premio di Formula 1.
 Prima dell'inizio, il tabellone riporta la griglia di partenza, ovvero
 l'ordine in cui le vetture partiranno dalla linea del traguardo.
 Non appena inizia il gran premio, per ogni sorpasso, il tabellone scrive
 due numeri: quello della vettura che ha effettuato il sorpasso, e quello
 della vettura che è stata superata.
 Il vostro compito è di scrivere un programma che, ricevuti in ingresso
 l'ordine di partenza e la lista dei sorpassi, calcoli chi ha vinto il gran
 premio.
\end_layout

\begin_layout Plain Layout
Per esempio, considerate il seguente gran premio, con 3 macchine e 4 sorpassi.
 L'ordine iniziale di partenza è stato: la vettura numero 2, poi la vettura
 numero 1 e infine la vettura numero 3.
 I sorpassi sono stati, nell'ordine:
\end_layout

\begin_layout Enumerate
la numero 3 ha superato la numero 1; 
\end_layout

\begin_layout Enumerate
la numero 3 ha superato la numero 2; 
\end_layout

\begin_layout Enumerate
la numero 1 ha superato la numero 2; 
\end_layout

\begin_layout Enumerate
la numero 2 ha superato la numero 1;
\end_layout

\begin_layout Plain Layout
In questo caso, è facile vedere che la vettura numero 3 ha vinto il gran
 premio.
 Come si può notare dall'esempio, i sorpassi avvengono sempre tra due vetture
 consecutive.
\end_layout

\begin_layout Subsubsection*
Dati di input
\end_layout

\begin_layout Plain Layout
Il file di input è costituito da 1+N+M righe di testo.
 La prima riga contiene due interi positivi separati da uno spazio: N che
 è il numero di vetture e M che è il numero di sorpassi.
 Le successive N righe contengono l'ordine di partenza: per ogni riga c'è
 un numero intero K che rappresenta una vettura, con 1 ≤ K ≤ N.
 La vettura che parte in i-esima posizione nell'ordine di partenza si trova
 quindi nella riga (i+1) del file.
 Le restanti M righe contengono tutti i sorpassi, nell'ordine in cui sono
 avvenuti, uno in ogni riga.
 Ogni riga contiene due interi separati da uno spazio: A, ovvero il numero
 della vettura che ha effettuato il sorpasso, e B, ovvero il numero della
 vettura che ha subito il sorpasso.
 
\end_layout

\begin_layout Subsubsection*
Dati di output
\end_layout

\begin_layout Plain Layout
Il file di output deve contenere un solo intero: il numero della vettura
 che ha vinto il gran premio.
 
\end_layout

\begin_layout Subsubsection*
Assunzioni
\end_layout

\begin_layout Itemize
2 ≤ N ≤ 30 
\end_layout

\begin_layout Itemize
1 ≤ M ≤ 100
\end_layout

\begin_layout Subsubsection*
Esempi di input/output 
\end_layout

\begin_layout Plain Layout
\begin_inset Tabular
<lyxtabular version="3" rows="2" columns="2">
<features tabularvalignment="middle">
<column alignment="left" valignment="top" width="1in">
<column alignment="left" valignment="top" width="0">
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
File input.txt
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
File output.txt
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
3 4 
\end_layout

\begin_layout Plain Layout
2 
\end_layout

\begin_layout Plain Layout
1 
\end_layout

\begin_layout Plain Layout
3 
\end_layout

\begin_layout Plain Layout
3 1 
\end_layout

\begin_layout Plain Layout
3 2 
\end_layout

\begin_layout Plain Layout
1 2 
\end_layout

\begin_layout Plain Layout
2 1
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
3
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Suggerimenti
\end_layout

\begin_layout Standard
Il problema è molto semplice, richiedendo a prima vista di lavorare su un
 vettore e applicando degli spostamenti ai suoi elementi, ma è istruttivo
 perchè si può migliorare la strategia risolutiva in maniera elegante e
 non immediatamente ovvia.
\end_layout

\begin_layout Itemize
Dato che ogni macchina è rappresentata da un numero, quale sarà la struttura
 dati più adatta a memorizzare la griglia di partenza? 
\end_layout

\begin_layout Itemize
Ogni sorpasso corrisponde a scambiare tra loro due elementi del vettore,
 solo che non so quali sono, quindi devo ogni volta scorrere il vettore
 per trovare le macchine, potrei evitare questa continua ricerca?
\end_layout

\begin_layout Itemize
E se al posto di memorizzare il numero di macchina come valore lo usassi
 come indice del vettore e nella casella corrispondente mettessi la posizione
 della macchina? Cosa cambierebbe? Avrei ancora bisogno di cercare le macchine
 o sarebbero immediatamente individuate dall'indice del vettore?
\end_layout

\begin_layout Itemize
Se uso il numero di macchina come indice e il valore corrispondente come
 posizione, cosa vuol dire in questo caso effettuare un sorpasso?
\end_layout

\begin_layout Itemize
Finora si è dato per scontato che sia necessario avere un vettore, ma è
 davvero necessario considerando che mi interessa solo il primo classificato?
\end_layout

\begin_layout Subsection
Soluzione
\end_layout

\begin_layout Standard
Per questo esercizio verranno presentate tre soluzioni, in quello che a
 me sembra l'ordine di intuitività, nel senso che verrà mostrata prima quella
 più intuitiva e via via quelle meno ovvie, il ché non vuole dire che qualcuno
 non possa trovare più intuitiva l'ultima presentata, ma solo che dai miei
 colloqui con alcuni alunni (e anche a mia impressione), di solito la soluzione
 che viene in mente è la prima, che adesso vedremo.
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "basicstyle={\small\ttfamily},frame=lr,language={C++},numbers=left,showstringspaces=false,tabsize=4"
inline false
status collapsed

\begin_layout Plain Layout

int vetture[31]; 
\end_layout

\begin_layout Plain Layout

int N,M; 
\end_layout

\begin_layout Plain Layout

void sorpasso(int A, int B) { 	
\end_layout

\begin_layout Plain Layout

	int i; 	
\end_layout

\begin_layout Plain Layout

	for (i=0;i < N;i++) 		
\end_layout

\begin_layout Plain Layout

		if (vetture[i] == A) break; 	
\end_layout

\begin_layout Plain Layout

	int temp = vetture[i]; 	
\end_layout

\begin_layout Plain Layout

	vetture[i] = vetture [i-1]; 	
\end_layout

\begin_layout Plain Layout

	vetture[i-1] = temp; 
\end_layout

\begin_layout Plain Layout

} 
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

int main() 
\end_layout

\begin_layout Plain Layout

{ 	
\end_layout

\begin_layout Plain Layout

	fstream in,out; 	
\end_layout

\begin_layout Plain Layout

	in.open("input.txt",ios::in); 	25).
\end_layout

\begin_layout Plain Layout

	out.open("output.txt",ios::out); 	
\end_layout

\begin_layout Plain Layout

	in >> N >> M; 	
\end_layout

\begin_layout Plain Layout

	for (int i=0;i < N;i++) 		
\end_layout

\begin_layout Plain Layout

		in >> vetture[i];     
\end_layout

\begin_layout Plain Layout

	for (int i=0;i < M;i++) { 		
\end_layout

\begin_layout Plain Layout

		int A, B; 		
\end_layout

\begin_layout Plain Layout

		in >> A >> B; 		
\end_layout

\begin_layout Plain Layout

		sorpasso(A,B); 	
\end_layout

\begin_layout Plain Layout

	} 	
\end_layout

\begin_layout Plain Layout

	out << vetture[0];	 	
\end_layout

\begin_layout Plain Layout

	return 0; 
\end_layout

\begin_layout Plain Layout

}	
\end_layout

\end_inset


\end_layout

\begin_layout Standard
La prima idea è quella di 
\begin_inset Quotes eld
\end_inset

mappare
\begin_inset Quotes erd
\end_inset

 direttamente il problema attraverso un vettore, poichè sembra naturale
 usare l'indice del vettore come posizione della macchina e nel valore corrispon
dente inserire il numero di macchina, come viene fatto nelle righe 18-19.
 A questo punto il sorpasso non è altro che lo scambio di posto tra due
 macchine, anche questo conseguenza diretta del modo naturale di modellare
 il problema.
 L'unica cosa da notare nella funzione 
\emph on
sorpasso
\emph default
 (righe 3-10) è che basta trovare la posizione della prima macchina per
 scambiarla con la macchina in posizione precedente, poichè nel problema
 si dice che il sorpasso avviene sempre tra macchine consecutive.
 Effettuati tutti i sorpassi non resta che stampare l'elemento in prima
 posizione (riga 25).La soluzione è molto semplice, però richiede ad ogni
 sorpasso di cercare nel vettore la macchina interessata e questo porta
 a una complessità computazionale di tipo quadratico: mediamente cercare
 un elemento in un vettore è proporzionale alla lunghezza del vettore e
 questa ricerca viene fatta tante volte quanti sono i sorpassi, perciò se
 numero di macchine e numero di sorpasso sono confrontabili e vicini a N,
 la complessità della soluzione sarà di tipo 
\begin_inset Formula $N^{2}$
\end_inset

.
\end_layout

\begin_layout Standard
Per evitare di fare la ricerca si può pensare di usare il numero di macchina
 come indice e di memorizzare nelle celle del vettore le posizioni in gara,
 ribaltando quanto fatto prima.
 Se ad esempio la macchina 4 è in sesta posizione, nel vettore l'elemento
 di indice 4 (numero della macchina) conterrà il valore 6 (posizione della
 macchina).
 Questo diverso modo di vedere il problema porta alla seguente soluzione:
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "basicstyle={\small\ttfamily},frame=lr,language={C++},numbers=left,showstringspaces=false,tabsize=4"
inline false
status collapsed

\begin_layout Plain Layout

int vetture[31]; 
\end_layout

\begin_layout Plain Layout

int N,M; 
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

int main() 
\end_layout

\begin_layout Plain Layout

{ 	
\end_layout

\begin_layout Plain Layout

	fstream in,out; 	
\end_layout

\begin_layout Plain Layout

	in.open("input.txt",ios::in); 	
\end_layout

\begin_layout Plain Layout

	out.open("output.txt",ios::out); 	
\end_layout

\begin_layout Plain Layout

	in >> N >> M; 	
\end_layout

\begin_layout Plain Layout

	for (int i=1;i <= N;i++) {	 		
\end_layout

\begin_layout Plain Layout

		int temp; 		
\end_layout

\begin_layout Plain Layout

		in >> temp; 		
\end_layout

\begin_layout Plain Layout

		vetture[temp] = i; 	
\end_layout

\begin_layout Plain Layout

	} 	
\end_layout

\begin_layout Plain Layout

	for (int i=0;i < M;i++) { 		
\end_layout

\begin_layout Plain Layout

		int A, B; 		
\end_layout

\begin_layout Plain Layout

		in >> A >> B; 		
\end_layout

\begin_layout Plain Layout

		vetture[A]--; 		
\end_layout

\begin_layout Plain Layout

		vetture[B]++; 	
\end_layout

\begin_layout Plain Layout

	} 	
\end_layout

\begin_layout Plain Layout

	for (int i=1;i <=N;i++) 		
\end_layout

\begin_layout Plain Layout

		if (vetture[i] == 1)	
\end_layout

\begin_layout Plain Layout

			out << i << endl;	 	 	
\end_layout

\begin_layout Plain Layout

	return 0; 
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Come si vede alle righe 10-14 il vettore viene costruito seguendo quanto
 detto e a questo punto il sorpasso non è altro che un decremento di posizione
 per la macchina che sorpassa (migliora di 1 la propria posizione) e un
 incremento per la macchina sorpassata (peggiora di 1 la propria posizione).
 Questo evita di dover ricercare nel vettore la macchina e quindi la complessità
 scende da 
\begin_inset Formula $N^{2}$
\end_inset

 a 
\begin_inset Formula $N$
\end_inset

.
 È vero che rispetto alla soluzione di prima adesso bisogna cercare nel
 vettore quale macchina ha posto 1, cioè ha vinto la gara, ma questo ha
 costo ancora N e quindi il costo totale della soluzione rimane N.
\end_layout

\begin_layout Standard
A questo punto però può sorgere il sospetto che forse, dovendo solo stampare
 la prima posizione, non serva tenere traccia realmente delle posizioni
 di tutte le macchine, ma basti sapere solo chi di volta in volta è in testa.
 In effetti, supponendo che alla partenza sia in testa la macchina A, l'unica
 cosa che ci interessa è se ci sono sorpassi in cui una qualsiasi macchina
 supera A, perchè se così è sarà quella macchina a guidare la gara.
 A questo punto si ripete lo stesso ragionamente solo che stavolta lo si
 applicherà alla nuova macchina che guida la gara e così via, fino ad avere
 esaminato tutti i sorpassi, ottenendo così il vincitore della gara.
 Questa idea porta al codice seguente:
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "basicstyle={\small\ttfamily},frame=lr,language={C++},numbers=left,showstringspaces=false,tabsize=4"
inline false
status collapsed

\begin_layout Plain Layout

int primo; 
\end_layout

\begin_layout Plain Layout

int N,M; 
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

int main() 
\end_layout

\begin_layout Plain Layout

{ 	
\end_layout

\begin_layout Plain Layout

	fstream in,out; 	
\end_layout

\begin_layout Plain Layout

	in.open("input.txt",ios::in); 	
\end_layout

\begin_layout Plain Layout

	out.open("output.txt",ios::out); 	
\end_layout

\begin_layout Plain Layout

	in >> N >> M; 	
\end_layout

\begin_layout Plain Layout

	in >> primo;
\end_layout

\begin_layout Plain Layout

	for (int i=2;i <= N;i++) {	 		
\end_layout

\begin_layout Plain Layout

		int temp; 		
\end_layout

\begin_layout Plain Layout

		in >> temp; 	
\end_layout

\begin_layout Plain Layout

	} 	
\end_layout

\begin_layout Plain Layout

	for (int i=0;i < M;i++) { 		
\end_layout

\begin_layout Plain Layout

		int A, B; 		
\end_layout

\begin_layout Plain Layout

		in >> A >> B; 		
\end_layout

\begin_layout Plain Layout

		if (B == primo) 			
\end_layout

\begin_layout Plain Layout

			primo = A; 	
\end_layout

\begin_layout Plain Layout

	} 	
\end_layout

\begin_layout Plain Layout

	out << primo << endl;	 	
\end_layout

\begin_layout Plain Layout

	return 0; 
\end_layout

\begin_layout Plain Layout

}	
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Alla riga 10 viene letta la macchina in 
\begin_inset Quotes eld
\end_inset

pole position
\begin_inset Quotes erd
\end_inset

, le successive letture (righe 11-14) sono necessarie solo per avanzare
 con la lettura, ma tutte le informazioni vengono 
\begin_inset Quotes eld
\end_inset

buttate via
\begin_inset Quotes erd
\end_inset

.
 Successivamente si controllano tutti i sorpassi e solo se viene superata
 la macchina che in quel momento è alla testa della gara si provvede a inserire
 il nuovo capoclassifica.
 Alla fine nella variabile 
\emph on
primo
\emph default
 ci sarà il vincitore della gara.
 Rispetto alla soluzione precedente questa è sostanzialmente comparabile
 dal punto di vista della complessità computazionale (entrambe sono di tipo
 lineare, sebbene quest'ultima preveda qualche operazione in meno), ma l'occupaz
ione della memoria passa da N (la lunghezza del vettore) a 1.
\end_layout

\begin_layout Standard
Dopo aver visto queste tre diverse soluzioni ci si potrebbe domandare se
 vale la pena durante la gara di 
\begin_inset Quotes eld
\end_inset

limare
\begin_inset Quotes erd
\end_inset

 l'idea risolutiva per passare da una soluzione di complessità quadratica
 e occupazione di memoria di tipo lineare a una con complessità lineare
 e occupazione di memoria unitaria.
 La risposta in questo caso è NO, poichè date le assunzioni del problema
 (massimo 30 macchine e 100 sorpassi) anche eventuali soluzioni di tipo
 cubico sarebbero andate più che bene.
 Diverso sarebbe stato il discorso se il numero massimo di macchine fosse
 stato ad esempio 1000000 con un numero di sorpassi anch'esso limitato a
 1000000: in questo caso la soluzione quadratica non sarebbe stata in grado
 di risolvere i casi con input grosso, mentre le ultime due sì.
 Si può ancora notare come informazioni non direttamente inerenti al problema
 (le assunzioni sulle dimensioni dell'input) possano aiutare a non perdere
 tempo durante la gara.
\end_layout

\begin_layout Section
Turni di guardia - territoriali 2012
\end_layout

\begin_layout Standard
\begin_inset Box Framed
position "t"
hor_pos "c"
has_inner_box 0
inner_pos "t"
use_parbox 0
use_makebox 0
width "100col%"
special "none"
height "1in"
height_special "totalheight"
status collapsed

\begin_layout Subsection*
Turni di guardia (turni)
\end_layout

\begin_layout Subsubsection*
Difficoltà D = 2.
 
\end_layout

\begin_layout Subsubsection*
Descrizione del problema
\end_layout

\begin_layout Plain Layout
La Banda Bassotti è stata rimessa in libertà.
 Zio Paperone, in partenza per un viaggio di K giorni, ha la necessità di
 far sorvegliare il deposito: quindi ha bisogno che sia sempre presente
 almeno una persona.
 Per risparmiare, decide di chiedere la disponibilità di amici e parenti,
 e ognuno di questi fornisce un intervallo di giorni in cui è disponibile
 per la sorveglianza.
 Paperone però sa che dovrà fare un regalo a ognuna delle persone che userà,
 e volendo risparmiare al massimo deve coinvolgere il minimo numero di persone,
 senza lasciare mai il deposito scoperto.
 In questo modo riuscirà a risparmiare sui regali.
\end_layout

\begin_layout Plain Layout
Per esempio, supponiamo che il viaggio di Zio Paperone sia di K=8 giorni,
 con partenza il giorno 0 e ritorno il giorno K-1=7 e che le disponibilità
 siano le seguenti (per ogni nome, tra parentesi si indicano il giorno iniziale
 e il giorno finale della disponibilità).
\end_layout

\begin_layout Plain Layout
Paperino (3,5) 
\end_layout

\begin_layout Plain Layout
Paperoga (0,2) 
\end_layout

\begin_layout Plain Layout
Battista (1,3) 
\end_layout

\begin_layout Plain Layout
Gastone (5,6) 
\end_layout

\begin_layout Plain Layout
Archimede (4,7)
\end_layout

\begin_layout Plain Layout
In questo caso, a Zio Paperone basta coinvolgere Paperoga, Paperino e Archimede
 per assicurarsi che il deposito sia sempre sorvegliato, e se la cava con
 tre regali.
\end_layout

\begin_layout Plain Layout
Sapendo il numero di giorni di viaggio, e le disponibilità di ognuno, il
 vostro compito è quello di aiutare Zio Paperone a calcolare il minimo numero
 di persone che servono ad assicurare una sorveglianza continua al deposito.
 
\end_layout

\begin_layout Subsubsection*
Dati di input
\end_layout

\begin_layout Plain Layout
Il file di input è costituito da 2+N righe.
 La prima riga contiene un intero positivo K, ovvero il numero di giorni
 del viaggio.
 La seconda riga contiene un intero positivo N, il numero di persone che
 hanno dato la disponibilità a Zio Paperone.
 Le restanti N righe contengono una coppia di interi A e B per ognuna delle
 N persone: questa coppia di interi rappresenta l'inizio e la fine della
 disponibilità della i-esima persona.
 
\end_layout

\begin_layout Subsubsection*
Dati di output
\end_layout

\begin_layout Plain Layout
Il file di output deve contenere un solo intero positivo R, che è il numero
 minimo di persone necessarie ad assicurare una sorveglianza continua al
 deposito.
 
\end_layout

\begin_layout Subsubsection*
Assunzioni
\end_layout

\begin_layout Plain Layout
1 ≤ K, N ≤ 50 Per ognuna delle N righe, si ha 0 ≤ A ≤ B ≤ K-1 Esiste sempre
 almeno una soluzione in ognuno dei casi di input.
\end_layout

\begin_layout Subsubsection*
Esempi di input/output 
\end_layout

\begin_layout Plain Layout
\begin_inset Tabular
<lyxtabular version="3" rows="2" columns="2">
<features tabularvalignment="middle">
<column alignment="left" valignment="top" width="1in">
<column alignment="left" valignment="top" width="0">
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
File input.txt
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
File output.txt
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
8 
\end_layout

\begin_layout Plain Layout
5 
\end_layout

\begin_layout Plain Layout
3 5 
\end_layout

\begin_layout Plain Layout
0 2 
\end_layout

\begin_layout Plain Layout
1 3 
\end_layout

\begin_layout Plain Layout
5 6 
\end_layout

\begin_layout Plain Layout
4 7
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
3
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Suggerimenti
\end_layout

\begin_layout Standard
Il problema assomiglia molto ai precedenti 
\begin_inset Quotes eld
\end_inset

Giri sulla scopa Nimbus 3000
\begin_inset Quotes erd
\end_inset

 (territoriali 2007 
\begin_inset CommandInset ref
LatexCommand vpageref
reference "sec:Esempio:Nimbus"

\end_inset

 e 
\begin_inset Quotes eld
\end_inset

Missioni segrete
\begin_inset Quotes erd
\end_inset

 (territoriali 2008 
\begin_inset CommandInset ref
LatexCommand vpageref
reference "sec:Esempio-Missioni"

\end_inset

), si tratta di vedere a che tipologia di problema appartiene, se è risolubile
 tramite un approccio 
\emph on
greedy
\emph default
 (più semplice) o necessita della 
\emph on
programmazione dinamica
\emph default
.
\end_layout

\begin_layout Itemize
Come possono essere rappresentati i turni?
\end_layout

\begin_layout Itemize
Nell'algoritmo risolutivo i turni possono essere trattati in un qualsiasi
 ordine oppure un ordinamento secondo qualche criterio può essere essenziale
 per arrivare alla soluzione del problema? 
\end_layout

\begin_layout Itemize
Se sì, secondo quale criterio (giorno di inizio, giorno di fine, durata)
 possono essere ordinati i turni?
\end_layout

\begin_layout Itemize
Una volta scelto che un turno fa parte dell'insieme minimo dei turni, questa
 scelta potrebbe in un secondo momento essere messa in discussione (e quindi
 si dovrebbe utilizzare la 
\emph on
programmazione dinamica
\emph default
) oppure no (e quindi il modo corretto di procedere sarebbe di quello di
 utilizzare una strategia 
\emph on
greedy
\emph default
)?
\end_layout

\begin_layout Subsection
Soluzione
\end_layout

\begin_layout Standard
In questo problema si può arrivare molto velocemente alla soluzione se si
 riesce a stabilire che si tratta di un problema di tipo greedy.
 Si arriva a mostrare che è così tramite le seguenti osservazioni:
\end_layout

\begin_layout Enumerate
gli intervalli dei turni di guardia devono coprire completamente tutti i
 giorni, come da testo del problema, quindi esiste almeno un intervallo
 che inizia dal primo giorno: 
\end_layout

\begin_deeper
\begin_layout Itemize
se è solo uno lo scelgo e questa scelta non può essere cambiata, perchè
 nessun altro intervallo potrebbe coprire il primo giorno
\end_layout

\begin_layout Itemize
se sono più di uno scelgo quello che ha la data di fine maggiore, perchè
 sceglierne un altro comporterebbe solo un numero minore di giorni di 
\begin_inset Quotes eld
\end_inset

copertura
\begin_inset Quotes erd
\end_inset

 e nessun vantaggio.
 Anche in questo caso la scelta non potrà essere modificata successivamente,
 perchè nessuna altra scelta potrebbe portarmi in una situazione migliore
\end_layout

\end_deeper
\begin_layout Enumerate
a questo punto la data di fine del turno scelto sarà la nuova data di inizio
 per scegliere i turni successivi, reiterando il procedimento dal punto
 1, fino a quando non verrà selezionato un turno che finisce l'ultimo giorno.
\end_layout

\begin_layout Standard
In questo modo si è arrivati alla conclusione che il problema è di tipo
 
\emph on
greedy
\emph default
, e quindi conviene ordinare i turni di guardia usando come parametro per
 l'ordinamento il giorno di inizio, in modo da poter implementare in maniera
 efficiente l'algoritmo appena descritto.
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "basicstyle={\small\ttfamily},frame=lr,language={C++},numbers=left,showstringspaces=false,tabsize=4"
inline false
status open

\begin_layout Plain Layout

class Turno {  	
\end_layout

\begin_layout Plain Layout

	public: 	
\end_layout

\begin_layout Plain Layout

	int inizio, fine;  	
\end_layout

\begin_layout Plain Layout

	bool operator< (const Turno& t) const { 
\end_layout

\begin_layout Plain Layout

	return inizio < t.inizio;} 
\end_layout

\begin_layout Plain Layout

};
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

Turno turni[50]; 
\end_layout

\begin_layout Plain Layout

int K,N;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

int main() { 	
\end_layout

\begin_layout Plain Layout

	ifstream in("input.txt"); 	
\end_layout

\begin_layout Plain Layout

	ofstream out("output.txt"); 	
\end_layout

\begin_layout Plain Layout

	in >> K >> N; 	
\end_layout

\begin_layout Plain Layout

	for (int i=0; i<N; i++) 		
\end_layout

\begin_layout Plain Layout

		in >> turni[i].inizio >> turni[i].fine;     
\end_layout

\begin_layout Plain Layout

	sort(turni, turni + N); 	
\end_layout

\begin_layout Plain Layout

	int fine = -1; 	
\end_layout

\begin_layout Plain Layout

	int i = 0; 	
\end_layout

\begin_layout Plain Layout

	int quanti = 0; 	
\end_layout

\begin_layout Plain Layout

	while (fine < K-1){
\end_layout

\begin_layout Plain Layout

		int max = turni[i].fine; 		
\end_layout

\begin_layout Plain Layout

		while (turni[i].inizio - 1 <= fine){
\end_layout

\begin_layout Plain Layout

			if (turni[i].fine > max) max = turni[i].fine; 			
\end_layout

\begin_layout Plain Layout

			i++; 		
\end_layout

\begin_layout Plain Layout

		} 		
\end_layout

\begin_layout Plain Layout

		fine = max; 		
\end_layout

\begin_layout Plain Layout

		quanti++; 	
\end_layout

\begin_layout Plain Layout

	} 	
\end_layout

\begin_layout Plain Layout

	out << quanti << endl; 	
\end_layout

\begin_layout Plain Layout

	return 0;              
\end_layout

\begin_layout Plain Layout

}	
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Alle righe 1-5 viene definita la classe Turno (si poteva anche fare con
 una struttura) per gestire i turni, avente come attributi il giorno iniziale
 e finale e viene ridefinito l'operatore di minore perchè necessario all'algorit
mo di ordinamento (vedi 
\begin_inset CommandInset ref
LatexCommand ref
reference "sub:L'algoritmo-sort-C++"

\end_inset

).
 Dopo aver letto l'input (rige 13-15) viene chiamato l'algoritmo 
\emph on
sort
\emph default
 per ordinare il vettore dei turni a partire da quello che inizia per primo
 fino a quello che inizia per ultimo.
 Alla riga 17 viene inizializzato il valore del primo giorno a -1, in modo
 che l'algoritmo possa gestire in maniera corretta il fatto che un turno,
 per avere una copertura completa, possa iniziare a ridosso del turno precedente
 (eventualmente anche prima).
 Alla riga 20 inizia il ciclo principale, che terminerà non appena verrà
 inserito un turno che ha come giorno finale l'ultimo giorno da coprire.
 All'interno di questo ciclo ci sarà un ulteriore 
\emph on
while
\emph default
 (riga 22) che si occuperà di scegliere, tra i vari turni che possono essere
 aggiunti perchè hanno il giorno iniziale che permette di non lasciare 
\begin_inset Quotes eld
\end_inset

buchi
\begin_inset Quotes erd
\end_inset

, quello che ha il giorno finale maggiore (riga 23).
 Una volta scelto il nuovo turno da inserire verrà aggiornato il valore
 del giorno a cui finora si è riusciti a dare copertura e verrà incrementato
 il contatore dei turni.
\end_layout

\begin_layout Section
Barbablù - territoriali 2012
\end_layout

\begin_layout Standard
\begin_inset Box Framed
position "t"
hor_pos "c"
has_inner_box 0
inner_pos "t"
use_parbox 0
use_makebox 0
width "100col%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout Subsection*
Il tesoro del Pirata Barbablù (barbablu) 
\end_layout

\begin_layout Subsubsection*
Difficoltà D = 2.
 
\end_layout

\begin_layout Subsubsection*
Descrizione del problema
\end_layout

\begin_layout Plain Layout
John Steam della compagnia "Oriental Steam Navigation" decide di organizzare
 una spedizione di recupero del tesoro del Pirata Barbablù, custodito nel
 relitto del galeone del pirata, affondato al largo di Gobal, che si trova
 adagiato su un fianco a 30 metri di profondità.
 L'unico punto di accesso al relitto è uno squarcio sulla fiancata, in corrispon
denza della cabina numero 1.
 Nel galeone sono presenti cabine e corridoi che le collegano.
 Tutti i corridoi sono totalmente sommersi dall'acqua a causa della rottura
 degli oblo mentre in alcune delle cabine sono rimaste delle sacche d'aria.
 A causa degli spazi angusti non è possibile, per i sommozzatori, esplorare
 la nave con le bombole d'aria; sono quindi costretti a nuotare in apnea,
 sfruttando le sacche d'aria presenti nel tragitto per respirare.
\end_layout

\begin_layout Plain Layout
Prima di procedere con le operazioni di recupero ti viene commissionata
 la realizzazione di un programma in grado di individuare il percorso più
 breve all'interno del galeone che permetta ai sommozzatori di raggiungere
 la cabina con il tesoro a partire dall'apertura.
 In alcune cabine sono presenti sacche d'aria che possono essere usate per
 respirare.
 Un sommozzatore riesce a nuotare senza aria per 20 metri al massimo prima
 di dover riprendere fiato.
\end_layout

\begin_layout Plain Layout
\begin_inset Graphics
	filename ../materiali/problemi territoriali/2012_barbablu/mappa.png
	lyxscale 50
	scale 60

\end_inset


\end_layout

\begin_layout Plain Layout
\align center
Figura 1
\end_layout

\begin_layout Plain Layout
In Figura 1 sono mostrati due possibili scenari.
 La cabina di ingresso è come detto la numero 1, mentre la cabina del tesoro
 (rappresentato da una T) è la numero 2 per l'esempio di sinistra, e la
 numero 4 per l'esempio di destra.
 Le cabine con la sacca d'aria sono quadrate, mentre quelle senza sacca
 sono tonde.
 A fianco di ogni corridoio è segnata la sua lunghezza in metri.
 L'esempio di sinistra ammette una sola soluzione, di lunghezza 29 metri,
 mentre quello di destra non ha soluzioni.
\end_layout

\begin_layout Plain Layout
Le cabine della nave sono numerate da 1 ad N e sono collegate tra loro da
 M corridoi.
 L'apertura è la numero 1 mentre il tesoro si trova nella cabina numero
 C (con 1 ≤ C ≤ N).
 Di ogni cabina si conosce l'eventuale presenza di aria e di ogni corridoio
 la lunghezza in metri.
\end_layout

\begin_layout Plain Layout
Il tuo compito è quello di trovare la lunghezza in metri del percorso più
 breve che permette ad un sommozzatore di partire dalla cabina con l'apertura
 e di raggiungere il tesoro, in apnea, sfruttando le eventuali sacche d'aria
 trovate nel percorso.
 La cabina del tesoro ha sempre una sacca d'aria, che consente al sommozzatore
 di recuperare il tesoro.
 
\end_layout

\begin_layout Subsubsection*
Dati di input
\end_layout

\begin_layout Plain Layout
Il file input.txt è composto da M+2 righe.
 La prima riga contiene quattro interi positivi separati da uno spazio,
 che rappresentano il numero N delle cabine, il numero M dei corridoi, il
 numero C che rappresenta la cabina del tesoro e il numero K che rappresenta
 quante cabine hanno sacche d'aria al loro interno.
 La seconda riga contiene K numeri separati da uno spazio che rappresentano
 i numeri (distinti) delle cabine che contengono aria.
 Ciascuna delle rimanenti M righe contiene tre interi I,J, L separati da
 uno spazio che indicano la presenza di un corridoio che collega le cabine
 I e J di lunghezza L (in metri).
 
\end_layout

\begin_layout Subsubsection*
Dati di output
\end_layout

\begin_layout Plain Layout
Il file output.txt è composto da una sola riga contenente la lunghezza in
 metri del percorso più breve che permetta, a partire dall'apertura, di
 raggiungere la cabina del tesoro in apnea.
 Riportare -1 se non esiste nessun percorso che soddisfa i vincoli.
 
\end_layout

\begin_layout Subsubsection*
Assunzioni
\end_layout

\begin_layout Itemize
2 ≤ N ≤ 30; 
\end_layout

\begin_layout Itemize
2 ≤ M ≤ 100 1 ≤ C ≤ N; 
\end_layout

\begin_layout Itemize
0≤ K ≤ N
\end_layout

\begin_layout Subsubsection*
Esempi di input/output 
\end_layout

\begin_layout Plain Layout
\begin_inset Tabular
<lyxtabular version="3" rows="2" columns="2">
<features tabularvalignment="middle">
<column alignment="left" valignment="top" width="1in">
<column alignment="left" valignment="top" width="0">
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
File input.txt
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
File output.txt
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
3 3 2 2 
\end_layout

\begin_layout Plain Layout
2 3 
\end_layout

\begin_layout Plain Layout
1 2 22 
\end_layout

\begin_layout Plain Layout
1 3 15 
\end_layout

\begin_layout Plain Layout
2 3 14
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
29
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset VSpace bigskip
\end_inset


\begin_inset Tabular
<lyxtabular version="3" rows="2" columns="2">
<features tabularvalignment="middle">
<column alignment="left" valignment="top" width="1in">
<column alignment="left" valignment="top" width="0">
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
File input.txt
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
File output.txt
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
4 5 4 2 
\end_layout

\begin_layout Plain Layout
3 4 
\end_layout

\begin_layout Plain Layout
1 2 11 
\end_layout

\begin_layout Plain Layout
1 3 7 
\end_layout

\begin_layout Plain Layout
1 4 23 
\end_layout

\begin_layout Plain Layout
2 4 14 
\end_layout

\begin_layout Plain Layout
3 4 21
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
-1
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Suggerimenti
\end_layout

\begin_layout Standard
Il problema, a una prima lettura, sembra potersi ricondurre a una ben precisa
 tipologia di algoritmi, anche se alcuni vincoli possono modificare la strategia
 risolutiva in maniera non ovvia.
\end_layout

\begin_layout Itemize
Qual è la struttura dati più adatta per rappresentare i dati in input, considera
ndo le figure mostrate nel testo?
\end_layout

\begin_layout Itemize
Quali sono i dati importanti che devono essere memorizzati e come inserirli
 all'interno della struttura dati proposta (oppure mantenerli come variabili
 esterne)?
\end_layout

\begin_layout Itemize
Che strategia risolutiva posso adottare considerando che mi viene chiesto
 di trovare un cammino minimo con certe condizioni (l'ossigeno) che limitano
 il numero di percorsi possibili?
\end_layout

\begin_layout Itemize
Le condizioni sull'ossigeno, oltre a limitare il numero di percorsi possibili,
 possono dare origine a dei casi particolari che l'algoritmo pensato in
 precedenza potrebbe non trattare?
\end_layout

\begin_layout Itemize
Se sì, esistono delle modifiche semplici che potrebbero portare a una soluzione
 sempre corretta?
\end_layout

\begin_layout Subsection
Soluzione
\end_layout

\begin_layout Standard
Già dalla prima lettura del testo si può intuire come questo problema possa
 essere affrontato avendo delle conoscenze di base sulla teoria dei grafi.
 Le figure mostrate chiariscono immediatamente che la rappresentazione naturale
 di questo problema è un grafo, dove i nodi sono le cabine e i corridoi
 sono gli archi: in particolare il problema risulta quello di trovare un
 cammino minimo che porta dal nodo di partenza al nodo dove è contenuto
 il tesoro.
 Come visto in questa guida esiste un algoritmo efficiente per raggiungere
 questo scopo (vedi pagina 
\begin_inset CommandInset ref
LatexCommand pageref
reference "sec: cammino_minimo"

\end_inset

), ma anche una visita in ampiezza (vedi pagina 
\begin_inset CommandInset ref
LatexCommand pageref
reference "sec:visite"

\end_inset

) opportunamente modificata può risolvere il problema, a fronte di una difficolt
à implementativa decisamente minore.
\end_layout

\begin_layout Standard
Adesso si vedrà come una visita in ampiezza può portare a una soluzione
 adeguata del problema, dove per adeguata si intende che è in grado di trovare
 il risultato corretto in buona parte dei casi proposti
\begin_inset Foot
status collapsed

\begin_layout Plain Layout
Al momento della stesura di questo paragrafo la soluzione proposta risolve
 correttamente tutti i casi di test presenti sul correttore del sito italiano
 delle Olimpiadi di Informatica.
\end_layout

\end_inset

, per poi discutere i limiti di questa soluzione.
 Rispetto a una visita 
\begin_inset Quotes eld
\end_inset

normale
\begin_inset Quotes erd
\end_inset

, in questo caso è necessario tenere traccia in ogni cabina della migliore
 distanza che si è trovata fino a quel momento e dell'aria rimasta al sub
 per arrivare fino ad essa.
 Man mano che la visita procede questi valori verranno aggiornati, fino
 a quando si arriverà ad avere per ogni nodo il minor costo possibile del
 cammino per raggiungerlo e a questo punto nella cabina del tesoro sarà
 contenuta la soluzione.
\end_layout

\begin_layout Standard
Una semplice implementazione di questa idea è quella mostrata nel codice
 sottostante.
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "basicstyle={\small\ttfamily},frame=lr,language={C++},numbers=left,showstringspaces=false,tabsize=4"
inline false
status collapsed

\begin_layout Plain Layout

#define INFINITO 1000000
\end_layout

\begin_layout Plain Layout

struct corridoio{ 	
\end_layout

\begin_layout Plain Layout

	int porta_a, lunghezza; 	
\end_layout

\begin_layout Plain Layout

	corridoio(int p, int l):porta_a(p), lunghezza(l){} 
\end_layout

\begin_layout Plain Layout

};
\end_layout

\begin_layout Plain Layout

struct cabina{ 	
\end_layout

\begin_layout Plain Layout

	bool aria; 	
\end_layout

\begin_layout Plain Layout

	list <corridoio> corridoi; 	
\end_layout

\begin_layout Plain Layout

	int distanza; 	
\end_layout

\begin_layout Plain Layout

	int ossigeno_rimasto; 	
\end_layout

\begin_layout Plain Layout

	cabina():aria(false), distanza(INFINITO),ossigeno_rimasto(20){} 
\end_layout

\begin_layout Plain Layout

};
\end_layout

\begin_layout Plain Layout

cabina cabine[31]; 
\end_layout

\begin_layout Plain Layout

int N,M,C,K;
\end_layout

\begin_layout Plain Layout

queue <int> coda;
\end_layout

\begin_layout Plain Layout

void visita() {	 	
\end_layout

\begin_layout Plain Layout

	while (!coda.empty()){
\end_layout

\begin_layout Plain Layout

		int c = coda.front(); 		
\end_layout

\begin_layout Plain Layout

		coda.pop(); 		
\end_layout

\begin_layout Plain Layout

		list <corridoio>::iterator i = cabine[c].corridoi.begin(); 		
\end_layout

\begin_layout Plain Layout

		for (; i != cabine[c].corridoi.end(); i++){
\end_layout

\begin_layout Plain Layout

			if (i->lunghezza < cabine[c].ossigeno_rimasto){ 				
\end_layout

\begin_layout Plain Layout

				if (cabine[c].distanza + i->lunghezza < 
\end_layout

\begin_layout Plain Layout

					cabine[i->porta_a].distanza){
\end_layout

\begin_layout Plain Layout

						cabine[i->porta_a].distanza = 
\end_layout

\begin_layout Plain Layout

						cabine[c].distanza + i->lunghezza;
\end_layout

\begin_layout Plain Layout

						if (cabine[i->porta_a].aria == false) 						
\end_layout

\begin_layout Plain Layout

							cabine[i->porta_a].ossigeno_rimasto =
\end_layout

\begin_layout Plain Layout

							cabine[c].ossigeno_rimasto - i->lunghezza;
\end_layout

\begin_layout Plain Layout

						coda.push(i->porta_a); 				
\end_layout

\begin_layout Plain Layout

				} 			
\end_layout

\begin_layout Plain Layout

			} 		
\end_layout

\begin_layout Plain Layout

		} 	
\end_layout

\begin_layout Plain Layout

	} 
\end_layout

\begin_layout Plain Layout

} 
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

int main() { 	
\end_layout

\begin_layout Plain Layout

	ifstream in("input.txt"); 	
\end_layout

\begin_layout Plain Layout

	ofstream out("output.txt"); 	
\end_layout

\begin_layout Plain Layout

	in >> N >> M >> C >> K; 	
\end_layout

\begin_layout Plain Layout

	for (int i = 0; i < K; i++){ 		
\end_layout

\begin_layout Plain Layout

		int temp; 		
\end_layout

\begin_layout Plain Layout

		in >> temp; 		
\end_layout

\begin_layout Plain Layout

		cabine[temp].aria = true; 	
\end_layout

\begin_layout Plain Layout

	} 	
\end_layout

\begin_layout Plain Layout

	for (int i = 0; i < M; i++){ 		
\end_layout

\begin_layout Plain Layout

		int r,s,t; 		
\end_layout

\begin_layout Plain Layout

		in >> r >> s >> t; 		
\end_layout

\begin_layout Plain Layout

		corridoio c(s,t); 		
\end_layout

\begin_layout Plain Layout

		cabine[r].corridoi.push_back(c); 		
\end_layout

\begin_layout Plain Layout

		corridoio d(r,t); 		
\end_layout

\begin_layout Plain Layout

		cabine[s].corridoi.push_back(d); 	
\end_layout

\begin_layout Plain Layout

	} 	
\end_layout

\begin_layout Plain Layout

	coda.push(1); 	
\end_layout

\begin_layout Plain Layout

	cabine[1].distanza = 0; 	
\end_layout

\begin_layout Plain Layout

	visita(); 	
\end_layout

\begin_layout Plain Layout

	if (cabine[C].distanza == INFINITO) 		
\end_layout

\begin_layout Plain Layout

		out << "-1" << endl; 	
\end_layout

\begin_layout Plain Layout

	else 		
\end_layout

\begin_layout Plain Layout

		out << cabine[C].distanza << endl; 	
\end_layout

\begin_layout Plain Layout

	return 0; 
\end_layout

\begin_layout Plain Layout

}	
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Come prima cosa vengono definite le strutture per gestire i dati di corridoi
 e cabine: ogni corridoio (righe 2-5) contiene informazioni sulla cabina
 verso la quale è diretto e la sua lunghezza, mentre ogni cabina (righe
 6-12) ha un flag booleano per indicare se contiene sacche d'aria o no,
 la lista dei corridoi che partono o arrivano a quella cabina, la distanza
 minima per arrivare a quella cabina partendo dalla cabina 1, che viene
 inizializzata a INFINITO dal costruttore, e la quantità di ossigeno rimasto
 rispetto al percorso fatto per giungere a quella cabina.
 Per memorizzare i dati viene quindi creato un vettore di cabine (lungo
 31 e non 30 per lavorare con gli indici dei dati del problema che partono
 da 1 e non da 0) e anche una coda che servirà nell'implementazione della
 visita in ampiezza.
\end_layout

\begin_layout Standard
Dopo aver letto i dati in input e averli inseriti nel vettore delle cabine
 (righe 40-53), viene inserita la prima cabina nella coda e viene chiamata
 la funzione che effettuerà la visita in ampiezza, registrando tutti i valori
 calcolati dei cammini per raggiungere le varie cabine.
 Questa funzione (righe 16-35) durante le visite registrerà nelle cabine
 la lunghezza minima in questo modo:
\end_layout

\begin_layout Itemize
viene estratta dalla coda il numero di cabina corrente, finchè ce ne sono
 (righe 17-19)
\end_layout

\begin_layout Itemize
per ognuno dei corridoi che partono da quella cabina (righe 20-21) si controlla
 che sia possibile attraversarlo, dato l'ossigeno rimasto nella cabina corrente
 (riga 22)
\end_layout

\begin_layout Itemize
se è possibile si verifica se la cabina alla quale porta quel corridoio
 verrà raggiunta con un percorso più corto di quello già presente nella
 cabina di arrivo (righe 23-24): se la cabina è la prima volta che viene
 visitata questa condizione sarà ovviamente vera, perchè la distanza era
 stata inizializzata a INFINITO, se non è la prima volta, la condizione
 sarà vera se il nuovo percorso è più corto di quello trovato in precedenza
 
\end_layout

\begin_layout Itemize
in caso di condizione soddisfatta verrà aggiornato il valore della distanza
 e se la cabina non contiene sacche d'aria verrà anche aggiornato il nuovo
 valore di ossigeno rimasto
\end_layout

\begin_layout Itemize
infine la cabina alla quale ha portato il corridoio verrà inserita in coda,
 per essere elaborata nei successivi passaggi.
\end_layout

\begin_layout Standard
Alla fine della funzione nella cabina numero C si troverà la distanza minima
 per raggiungerla oppure INFINITO, nel qual caso significa che non esiste
 un cammino per raggiungere la cabina del tesoro che soddisfi le condizioni
 sull'ossigeno.
\end_layout

\begin_layout Standard
Come si può vedere il codice non presenta delle complessità particolari,
 come già detto è una visita in ampiezza con aggiunte le condizioni descritte
 nel problema.
 Rimangono però dei problemi interessanti e non immediatamente visibili
 che verranno discussi adesso.
\end_layout

\begin_layout Standard
Un primo problema che può sorgere è quello di domandarsi se il numero di
 cammini da esplorare non sia troppo grande e quindi non computabile in
 un tempo ragionevole.
 Questo dipende ovviamente da quanti sono i cammini possibili in un grafo,
 dato che il nostro algoritmo tende a esplorarli tutti: l'esatto numero
 dipende oltre che dal numero di vertici e archi anche da come questi sono
 connessi, in generale comunque sono in un numero che cresce esponenzialmente
 al crescere dei vertici, come si era già visto in un semplice esempio a
 pagina 
\begin_inset CommandInset ref
LatexCommand pageref
reference "sec: cammino_minimo"

\end_inset

.
 In questo problema il numero di vertici viene limitato a 30 e il numero
 di archi a 100, ma anche in questo caso potrebbero esserci grafi la cui
 esplorazione, se venissero analizzati tutti i cammini, richiederebbe troppo
 tempo.
 Di fatto questo però non dovrebbe succedere, perchè le limitazioni sull'ossigen
o e il fatto che non vengono riesplorati percorsi che si sa già non poter
 essere minimi portano a drastiche riduzioni del numero di percorsi esplorati.
 Esistono poi delle semplici modifiche al codice proposto, lasciate come
 esercizio al lettore, che possono ridurre ancora di più il numero potenziale
 di percorsi:
\end_layout

\begin_layout Itemize
nell'input di esempio sono presenti dei corridoi di lunghezza maggiore di
 20: è evidente che tali corridoi non potranno mai essere percorsi dal sub,
 quindi non devono essere inseriti nel grafo
\end_layout

\begin_layout Itemize
quando si arriva alla cabina del tesoro si può memorizzare la lunghezza
 minore trovata fino a quel momento, che non è detto essere quella finale,
 ma che sicuramente pone un limite superiore agli altri percorsi che devono
 ancora essere visitati: se cioè mentre procedo con le visite mi accorgo
 di arrivare a delle cabine intermedie con una distanza superiore al valore
 attuale del percorso per arrivare al tesoro, non procederò oltre perchè
 sicuramente quel percorso non potrà migliorare il costo per arrivare alla
 cabina del tesoro.
\end_layout

\begin_layout Standard
Un'altra domanda che potrebbe sorgere è quella se convenga scegliere una
 visita in ampiezza o in profondità: in problemi come questi dove le visite
 vengono usate per esplorare i cammini senza sapere a priori nulla sulle
 caratteristiche del percorso più breve, non c'è differenza tra l'una e
 l'altra e quindi la scelta non è importante: anche in questo caso il lettore
 è invitato a provare a sostituire la coda con una pila e verificare che
 le prestazioni mediamente non cambiano.
\end_layout

\begin_layout Standard
Rimane un ultimo interrogativo che, pur essendo approfondito per ultimo,
 è quello più importante: ma l'algoritmo proposto è in grado di trovare
 la soluzione in tutti i casi possibili? La risposta purtroppo è no e il
 perchè lo si può vedere dall'esempio di figura 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:Casi-barbablu"

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename ../materiali/problemi territoriali/2012_barbablu/esempio cattivo totale.eps
	display false
	scale 60

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:Casi-barbablu"

\end_inset

Casi 
\begin_inset Quotes eld
\end_inset

problematici
\begin_inset Quotes erd
\end_inset

 per il problema
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Se si guarda il grafo (a), l'algoritmo proposto darebbe come cammino minimo
 54, ottenuto percorrendo i vertici 1 - 2 - 4 - 5 - 6.
 In realtà si vede subito che il percorso 1 - 3 - 4 - 2 - 6 darebbe un risultato
 migliore (46), ma l'algoritmo non può scoprirlo perchè la cabina 2 può
 essere raggiunta con costo 15 e quindi passare da 3 e 4 darebbe un risultato
 peggiore, anche se poi verrebbe ripagato dal minore costo dell'arco 2 -
 6.
 Ovviamente fare direttamente 1 - 2 - 6 non è possibile, perchè non si riesce
 a percorrere il corridoio 2 - 6 avendo solo una riserva di ossigeno pari
 a 5, ma se si guarda meglio si può vedere che c'è una possibilità non evidente
 che permette di ottenre un valore minore di 46: se il sub, dopo essere
 arrivato alla cabina 2 direttamente dalla cabina 1 va alla cabina 4 per
 riprendere fiato (la sua scorta di ossigeno torna a 20), poi può tornare
 indietro e andare dalla 2 alla 6 perchè adesso ha una riserva di ossigeno
 di 19.
 Quindi il cammino minimo per arrivare al tesoro costa 24 ed è 1 - 2 - 4
 - 2 - 6.
 
\end_layout

\begin_layout Standard
Perchè l'algoritmo proposto non lo trova? Per come è fatto non è in grado
 di tornare sui propri passi, cioè trovare cammini che contengano più volte
 lo stesso nodo e questo gli impedisce di scoprire cammini come quello dell'esem
pio (a): però con alcune semplici modifiche si può fare in modo che vengano
 scoperti percorsi come quello.
 
\end_layout

\begin_layout Standard
In particolare il problema risiede nel fatto che a volte si può affrontare
 il costo di un cammino più lungo in cambio di una situazione migliore per
 quanto riguarda l'ossigeno rimasto, se questo può portare successivamente
 a un cammino globale più corto.
 Se ad ogni passo si controlla se è possibile migliorare la situazione dell'ossi
geno, è possibile passare più volte sullo stesso nodo se questo aumenta
 la quantità di ossigeno rimasto.
 Il codice che realizza questo controllo è il seguente:
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "basicstyle={\small\ttfamily},frame=lr,language={C++},numbers=left,showstringspaces=false,tabsize=4"
inline false
status open

\begin_layout Plain Layout

if (cabine[c].ossigeno_rimasto - i->lunghezza > 
\end_layout

\begin_layout Plain Layout

	cabine[i->porta_a].ossigeno_rimasto && i->porta_a != C)
\end_layout

\begin_layout Plain Layout

{ 					
\end_layout

\begin_layout Plain Layout

	cabine[i->porta_a].distanza = cabine[c].distanza + i->lunghezza;
\end_layout

\begin_layout Plain Layout

	cabine[i->porta_a].ossigeno_rimasto = 
\end_layout

\begin_layout Plain Layout

	cabine[c].ossigeno_rimasto - i->lunghezza;
\end_layout

\begin_layout Plain Layout

	coda.push(i->porta_a);
\end_layout

\begin_layout Plain Layout

}	
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Come si può vedere, se la situazione dell'ossigeno viene migliorata si aggiorna
 il valore di ossigeno rimasto e anche la nuova distanza, anche se fosse
 peggiore di quella trovata in precedenza: l'unica accortezza è quella di
 mettere in AND la condizione che la cabina di arrivo non sia quella del
 tesoro, altrimenti il rischio è quello di aggiornare in quella cabina l'ossigen
o peggiorando un risultato ottenuto in precedenza, cosa che ovviamente non
 va bene e che succederebbe ad esempio nel grafo di figura 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:Casi-barbablu"

\end_inset

 (b).
 
\end_layout

\begin_layout Standard
Questo nuovo frammento di codice va inserito tra la riga 31 e la 32 del
 primo codice proposto, in modo da rendere il programma corretto anche su
 esempi 
\begin_inset Quotes eld
\end_inset

patologici
\begin_inset Quotes erd
\end_inset

.
\end_layout

\begin_layout Section
Gardaland - territoriali 2013
\end_layout

\begin_layout Standard
\begin_inset Box Framed
position "t"
hor_pos "c"
has_inner_box 0
inner_pos "t"
use_parbox 0
use_makebox 0
width "100col%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout Subsection*
Gardaland (gardaland) 
\end_layout

\begin_layout Subsubsection*
Difficoltà D = 1 
\end_layout

\begin_layout Subsubsection*
Descrizione del problema
\end_layout

\begin_layout Plain Layout
Nel 2012 le Olimpiadi Internazionali di Informatica (IOI) si sono svolte,
 per la prima volta, in Italia, a Sirmione.
 Come da tradizione, nella giornata tra le due gare i concorrenti sono andati
 a divertirsi in un parco giochi, in questo caso, Gardaland.
 La mattina di quel giorno decine di pullman hanno prelevato i quattro ragazzi
 che costituiscono la squadra olimpica di ciascuna nazione dal Garda Village,
 dove erano stati alloggiati, e li hanno portati a Gardaland.
 Come sempre negli spostamenti, le varie nazioni erano state ripartite a
 blocco unico tra i pullman, ossia tutti gli atleti di una stessa nazione
 trovavano posto su uno stesso pullman.
 Per esempio, sul pullman dell’Italia viaggiavano anche Giappone, Israele
 e Irlanda.
 Al ritorno però, come sempre succede alle IOI, dopo una giornata in un
 parco giochi i ragazzi hanno fatto amicizia tra di loro, e al momento di
 tornare sui pullman sono saliti alla rinfusa.
 Grazie al lavoro delle guide, per ogni pullman è stata stilata una lista
 contenente, per ogni nazione, il numero di ragazzi a bordo.
 Il vostro compito è quello di aiutare Monica, responsabile dell’organizzazione,
 a capire se i pullman possono partire, ovvero se tutti i quattro ragazzi
 di ogni nazione che sono arrivati a Gardaland sono saliti sui pullman.
 In caso contrario, dovete segnalare a Monica in quanti mancano all’appello,
 divisi per nazioni.
\end_layout

\begin_layout Subsubsection*
Dati di input
\end_layout

\begin_layout Plain Layout
Il file input.txt è composto da 1+N+L righe.
 La prima riga contiene due interi positivi separati da uno spazio: il numero
 N delle nazioni e il numero L di righe contenenti informazioni su chi è
 attualmente già salito sui pullman.
 (Ciascuna nazione verrà qui rappresentata con un intero compreso tra 0
 e N-1).
 Ognuna delle successive N righe contiene un intero positivo: nella riga
 i+1 (con i >= 1) troviamo il numero totale di ragazzi della nazione i-1.
 Ciascuna delle rimanenti L righe contiene due interi positivi: un intero
 compreso tra 0 e N-1 che rappresenta la nazione, e un intero positivo che
 specifica quanti ragazzi di quella nazione sono su un certo pullman.
 Ovviamente una stessa nazione può comparire diverse volte nelle L righe,
 e più precisamente compare su tante righe quanti sono i pullman ospitanti
 atleti di quella nazione.
\end_layout

\begin_layout Subsubsection*
Dati di output
\end_layout

\begin_layout Plain Layout
Il file output.txt è composto da una sola riga contenente l’intero 0 (zero)
 se non manca alcun ragazzo.
 Altrimenti, il file contiene 1+C righe: la prima riga contiene un intero
 C, ovvero il numero di nazioni che hanno ragazzi ancora a Gardaland.
 Le restanti C righe contengono due interi: l’identificativo della nazione
 e il numero di ragazzi di quella nazione che non sono ancora saliti su
 alcun pullman.
 É necessario stampare le nazioni nell’ordine in cui sono state lette, ovvero
 in ordine crescente in base all’identificativo.
\end_layout

\begin_layout Subsubsection*
Assunzioni
\end_layout

\begin_layout Itemize
\begin_inset Formula $2\leq N\leq100$
\end_inset


\end_layout

\begin_layout Itemize
\begin_inset Formula $N\leq L\leq1000$
\end_inset


\end_layout

\begin_layout Itemize
Contrariamente alle olimpiadi di informatica reali, dove gareggiano (massimo)
 4 ragazzi per ogni nazione, nei casi di input si assume che ogni nazione
 abbia al massimo 100 ragazzi, e almeno 1 ragazzo.
 Quindi, indicando con R
\begin_inset script subscript

\begin_layout Plain Layout
i
\end_layout

\end_inset

 il numero di ragazzi della i-esima nazione, vale sempre 1 ≤ R
\begin_inset script subscript

\begin_layout Plain Layout
i
\end_layout

\end_inset

 ≤ 100.
\end_layout

\begin_layout Subsubsection*
Esempi di input/output 
\end_layout

\begin_layout Plain Layout
\begin_inset Tabular
<lyxtabular version="3" rows="2" columns="2">
<features tabularvalignment="middle">
<column alignment="left" valignment="top" width="1in">
<column alignment="left" valignment="top" width="1.3in">
<row>
<cell alignment="left" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
File input.txt
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
File output.txt
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
3 5 
\end_layout

\begin_layout Plain Layout
4
\end_layout

\begin_layout Plain Layout
4
\end_layout

\begin_layout Plain Layout
3
\end_layout

\begin_layout Plain Layout
0 2 
\end_layout

\begin_layout Plain Layout
1 3 
\end_layout

\begin_layout Plain Layout
0 1 
\end_layout

\begin_layout Plain Layout
2 2 
\end_layout

\begin_layout Plain Layout
1 1
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
2
\end_layout

\begin_layout Plain Layout
0 1
\end_layout

\begin_layout Plain Layout
2 1
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Suggerimenti
\end_layout

\begin_layout Standard
A una prima occhiata il problema non sembra essere difficile, i limiti temporali
 data la dimensione del problema sembrano essere piuttosto larghi, si tratta
 eventualmente di trovare la soluzione più rapida e efficiente da scrivere,
 per risparmiare tempo per gli altri problemi.
\end_layout

\begin_layout Itemize
Quali sono le informazioni rilevanti? I pullman, i ragazzi, le nazioni?
\end_layout

\begin_layout Itemize
Il fatto che ogni nazione sia indicata da un numero intero e che i numeri
 siano tutti quelli compresi tra 0 e N-1, può aiutarmi a scegliere la struttura
 di supporto più adatta?
\end_layout

\begin_layout Itemize
Dal momento che devo memorizzare le nazioni e i ragazzi che mancano per
 ogni nazione, di quante variabili/strutture dati ho bisogno?
\end_layout

\begin_layout Itemize
Durante la lettura dei dati è possibile risolvere il problema? Prova a immaginar
e Monica che, armata di carta e penna, gira per ogni pullman e raccoglie
 le informazioni sui ragazzi di ogni nazione: quando arriva all'ultimo pullman
 può già essere in grado di avere la soluzione?
\end_layout

\begin_layout Subsection
Soluzione
\end_layout

\begin_layout Standard
Il problema può essere risolto con un costo lineare e, come evidenziato
 nell'ultima domanda dei suggerimenti, già al momento della lettura dei
 dati è possibile trovare la soluzione.
 La scelta fondamentale che permette di raggiungere questo risultato è quella
 di usare un vettore per memorizzare i ragazzi di ogni nazione, sfruttando
 l'indice del vettore come 
\begin_inset Quotes eld
\end_inset

segnaposto
\begin_inset Quotes erd
\end_inset

 della nazione e il valore di ogni cella come il numero di ragazzi corrispondent
i alla nazione individuata dall'indice.
 
\end_layout

\begin_layout Standard
A questo punto è immediato aggiornare la situazione mano a mano che vengono
 lette le coppie nazione - numero ragazzi, in modo da avere infine una lista
 delle nazioni a cui mancano ancora ragazzi.
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "basicstyle={\small\ttfamily},frame=lr,language={C++},numbers=left,showstringspaces=false,tabsize=4"
inline false
status open

\begin_layout Plain Layout

int nazioni[100]; 
\end_layout

\begin_layout Plain Layout

int N,L;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

int main() { 	
\end_layout

\begin_layout Plain Layout

	ifstream in("input.txt"); 	
\end_layout

\begin_layout Plain Layout

	ofstream out("output.txt"); 	
\end_layout

\begin_layout Plain Layout

	in >> N >> L; 	
\end_layout

\begin_layout Plain Layout

	for (int i = 0; i < N; i++) 		
\end_layout

\begin_layout Plain Layout

		in >> nazioni[i]; 	
\end_layout

\begin_layout Plain Layout

	for (int i = 0; i < L; i++) { 		
\end_layout

\begin_layout Plain Layout

		int n,r; 		
\end_layout

\begin_layout Plain Layout

		in >> n >> r; 		
\end_layout

\begin_layout Plain Layout

		nazioni[n] -= r; 
\end_layout

\begin_layout Plain Layout

	} 	
\end_layout

\begin_layout Plain Layout

	int assenti = 0; 	
\end_layout

\begin_layout Plain Layout

	for (int i = 0; i < N; i++)
\end_layout

\begin_layout Plain Layout

		if (nazioni[i] != 0)
\end_layout

\begin_layout Plain Layout

			assenti++;	 	
\end_layout

\begin_layout Plain Layout

	out << assenti << endl; 		
\end_layout

\begin_layout Plain Layout

	if (assenti) 		
\end_layout

\begin_layout Plain Layout

		for (int i = 0; i < N; i++) 			
\end_layout

\begin_layout Plain Layout

			if (nazioni[i] != 0) 				
\end_layout

\begin_layout Plain Layout

				out << i << " " << nazioni[i] << endl; 		 	
\end_layout

\begin_layout Plain Layout

	return 0; 
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Come si vede dal codice il vettore 
\emph on
nazioni
\emph default
 conterrà tutti i ragazzi presenti alle Olimpiadi per ogni nazione, vettore
 che viene inizializzato alle righe 8-9.
 Scorrendo poi le 
\series bold
L
\series default
 righe che contengono i ragazzi presenti nei vari pullman, ad ogni lettura
 viene aggiornata la situazione relativa alla nazione letta, decrementando
 il valore contenuto nella cella di indice 
\series bold
n
\series default
 del numero 
\series bold
r
\series default
 di ragazzi appartenenti a quella nazione (righe 10-14).
 A questo punto è semplice scorrere il vettore aggiornato, che conterrà
 in ogni cella il numero di ragazzi rimasti a Gardaland, 0 nel caso che
 tutti quelli della nazione siano sui pullman.
 Dopo aver contato il numero di nazioni che non hanno tutti i ragazzi (righe
 16-18), si procede con la stampa del risultato (riga 19) ed eventualmente,
 se ci sono ragazzi assenti, con le assenze per ogni nazione (righe 21-23).
\end_layout

\begin_layout Section
Brisbane - territoriali 2013
\end_layout

\begin_layout Standard
\begin_inset Box Framed
position "t"
hor_pos "c"
has_inner_box 0
inner_pos "t"
use_parbox 0
use_makebox 0
width "100col%"
special "none"
height "1in"
height_special "totalheight"
status collapsed

\begin_layout Subsection*
Brisbane (brisbane) 
\end_layout

\begin_layout Subsubsection*
Difficoltà D = 2.
 
\end_layout

\begin_layout Subsubsection*
Descrizione del problema
\end_layout

\begin_layout Plain Layout
Nel 2013, le IOI si svolgeranno a Brisbane (in Australia).
 La rappresentativa italiana ha già iniziato a studiare la città, per capire
 cosa ci sia di interessante da vedere, e come ci si possa spostare nella
 giornata libera successiva alla seconda gara delle Olimpiadi.
 L’offerta di trasporto pubblico a Brisbane è abbastanza variegata: ci sono
 due linee di bus, di cui una gratuita che gira intorno alla città, e due
 linee di traghetti che fermano in diversi punti del fiume Brisbane, che
 taglia la città in due; per quello che riguarda i prezzi, esiste un abbonamento
 giornaliero a tutti i trasporti pubblici, bus e traghetti insieme, oppure
 è possibile prendere un più economico abbonamento giornaliero ai soli traghetti
, o un ancor più economico abbonamento ai soli bus.
 
\end_layout

\begin_layout Plain Layout
La squadra italiana vorrà visitare il maggior numero di attrazioni possibile
 e per questo motivo Monica, la responsabile dell’organizzazione, ha deciso
 di cercare un buon compromesso tra il prezzo dei biglietti e le attrazioni
 che sarà possibile raggiungere partendo dall’hotel.
 Data una lista di attrazioni e la mappa dei collegamenti delle diverse
 linee del trasporto pubblico, il vostro compito è quello di aiutare Monica
 a capire 
\emph on
quante attrazioni sono raggiungibili
\emph default
 per ogni possibile scelta dei biglietti per i trasporti pubblici.
 
\end_layout

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename ../materiali/problemi territoriali/2013_brisbane/piantina.png
	lyxscale 30
	scale 25

\end_inset


\end_layout

\begin_layout Plain Layout
Per esempio, possiamo fare riferimento alla figura qui sopra, dove ad ogni
 fermata è associato un cerchio (o un quadrato nel caso di luogo di attrazione)
 e i collegamenti sono: 
\end_layout

\begin_layout Itemize
tratteggiati – collegamenti gratuiti (bus gratuiti e brevi percorsi a piedi);
 
\end_layout

\begin_layout Itemize
rossi – bus a pagamento; 
\end_layout

\begin_layout Itemize
gialli – traghetto.
 
\end_layout

\begin_layout Plain Layout
Il punto di partenza della rappresentativa italiana è la fermata numero
 0; le attrazioni da vedere sono quelle rappresentate con un quadrato, numerate
 rispettivamente 8, 12, 15, 22 e 28.
 Come si può vedere, spostandosi con i mezzi gratuiti si raggiungono solo
 due attrazioni (la numero 8 e la numero 22); comprando il biglietto del
 bus si raggiungono tutte le attrazioni; comprando il biglietto del traghetto
 si raggiungono, oltre alla 8 e la 22, anche la 12 e la 15 per un totale
 di quattro attrazioni.
 Il biglietto combinato, in questo caso, raggiunge tutte le attrazioni.
 
\end_layout

\begin_layout Subsubsection*
Dati di input
\end_layout

\begin_layout Plain Layout
Il file input.txt è composto da 1+A+Mg+Mb+Mt righe.
 La prima riga contiene cinque interi positivi separati da uno spazio, che
 rappresentano il numero 
\emph on
N
\emph default
 delle fermate, il numero 
\emph on
A
\emph default
 di attrazioni, il numero 
\emph on
Mg
\emph default
 dei collegamenti gratuiti, il numero 
\emph on
Mb
\emph default
 dei collegamenti via bus e il numero 
\emph on
Mt
\emph default
 dei collegamenti via traghetto.
 Ogni fermata è rappresentata da un intero compreso tra 0 e N-1.
 Le successive 
\emph on
A
\emph default
 righe contengono ognuna una fermata (un intero compreso tra 0 e N-1) corrispond
ente ad una delle attrazioni che la rappresentativa italiana può visitare.
 Ognuna delle successive 
\emph on
Mg+Mb+Mt
\emph default
 righe contiene un collegamento del trasporto pubblico, rappresentato da
 due interi positivi: le fermate collegate.
 Le prime 
\emph on
Mg
\emph default
 righe contengono i collegamenti gratuiti (bus gratuiti e brevi percorsi
 a piedi), poi le successive 
\emph on
Mb
\emph default
 contengono i collegamenti del bus a pagamento e infine le ultime 
\emph on
Mt
\emph default
 righe contengono i collegamenti dei traghetti.
 Il punto di partenza della rappresentativa italiana è la sempre la fermata
 numero 0.
 
\end_layout

\begin_layout Subsubsection*
Dati di output
\end_layout

\begin_layout Plain Layout
Il file output.txt è composto da 4 righe contenenti ognuna un intero non
 negativo, rispettivamente, il numero di attrazioni raggiungibili:
\end_layout

\begin_layout Enumerate
senza comprare biglietti (solo con mezzi gratuiti); 
\end_layout

\begin_layout Enumerate
comprando solo il biglietto giornaliero dei bus; 
\end_layout

\begin_layout Enumerate
comprando solo il biglietto giornaliero dei traghetti; 
\end_layout

\begin_layout Enumerate
comprando entrambe le tipologie di biglietti.
 
\end_layout

\begin_layout Subsubsection*
Assunzioni
\end_layout

\begin_layout Itemize
\begin_inset Formula $2\leq N\leq1000$
\end_inset


\end_layout

\begin_layout Itemize
\begin_inset Formula $N\leq Mg+Mb+Mt\leq10000$
\end_inset


\end_layout

\begin_layout Subsubsection*
Esempi di input/output 
\end_layout

\begin_layout Plain Layout
\begin_inset Tabular
<lyxtabular version="3" rows="2" columns="2">
<features tabularvalignment="middle">
<column alignment="left" valignment="top" width="1in">
<column alignment="left" valignment="top" width="1.3in">
<row>
<cell alignment="left" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
File input.txt
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
File output.txt
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
6 2 2 4 2
\end_layout

\begin_layout Plain Layout

\family typewriter
1
\end_layout

\begin_layout Plain Layout
5
\end_layout

\begin_layout Plain Layout
0 1
\end_layout

\begin_layout Plain Layout
2 5
\end_layout

\begin_layout Plain Layout
0 3
\end_layout

\begin_layout Plain Layout
1 3
\end_layout

\begin_layout Plain Layout
2 4
\end_layout

\begin_layout Plain Layout
4 5
\end_layout

\begin_layout Plain Layout
1 2
\end_layout

\begin_layout Plain Layout
3 4
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
1
\end_layout

\begin_layout Plain Layout
1
\end_layout

\begin_layout Plain Layout
2
\end_layout

\begin_layout Plain Layout
2
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Suggerimenti
\end_layout

\begin_layout Itemize
Come in molti altri problemi la figura suggerisce immediatamente che genere
 di problema si vuole affrontare: qual è?
\end_layout

\begin_layout Itemize
Se il problema fosse semplicemente quello di scoprire se dati una serie
 di nodi e archi quali sono raggiungibili da un certo nodo e quali no, cosa
 bisognerebbe fare?
\end_layout

\begin_layout Itemize
Da momento che in questo caso il problema non sembra esattamente dello stesso
 tipo, è possibile scomporlo in più istanze dello stesso problema, risolvibili
 separatamente?
\end_layout

\begin_layout Subsection
Soluzione
\end_layout

\begin_layout Standard
Dalla figura sembra evidente, e in effetti lo è, che il problema abbia a
 che fare con i grafi.
 Si trascuri per un attimo il fatto che ci siano varie tipologie di trasporto
 e si prendano in considerazione, ad esempio, solo gli archi che fanno parte
 del trasporto gratuito.
 Il problema si riduce a verificare se, dato un nodo di partenza, alcuni
 nodi particolari sono raggiungibili o meno.
 Per risolvere questo tipo di problema è sufficiente fare una visita, in
 profondità o in ampiezza (vedi pagina 
\begin_inset CommandInset ref
LatexCommand pageref
reference "sec:visite"

\end_inset

), e contare quanti dei nodi visitati sono delle attrazioni.
 Se alcune attrazioni non sono raggiungibili tramite la visita quelle non
 verranno contate.
\end_layout

\begin_layout Standard
Per risolvere i vari problemi è sufficiente trattare ogni tipo di trasporto
 (gratuito, bus, traghetti, tutti) come un grafo diverso e applicare a ognuno
 la stessa idea: per costruire i quattro diversi grafi è sufficiente, quando
 si leggono i dati dei collegamenti, inserirli nel grafo o nei grafi opportuni:
 ad esempio un collegamento del trasporto gratuito andrà in tutti i grafi,
 mentre quello dei bus solo nel grafo dei bus e in quello che li contiene
 tutti.
 Anche se questa idea prevede la ripetizione degli stessi dati più volte,
 cosa non necessaria se venissero adottati altri approci, ha dalla sua una
 semplicità implementativa notevole, perchè non richiede altro che di riapplicar
e quattro volte una visita di un grafo.
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "basicstyle={\small\ttfamily},frame=lr,language={C++},numbers=left,showstringspaces=false,tabsize=4"
inline false
status collapsed

\begin_layout Plain Layout

struct fermata{ 	
\end_layout

\begin_layout Plain Layout

	bool attrazione; 	
\end_layout

\begin_layout Plain Layout

	list <int> collegamenti; 	
\end_layout

\begin_layout Plain Layout

	fermata():attrazione(false){} 
\end_layout

\begin_layout Plain Layout

};
\end_layout

\begin_layout Plain Layout

int N, A, Mg, Mb, Mt;
\end_layout

\begin_layout Plain Layout

fermata gratuiti[1000], bus[1000], traghetti[1000], tutti[1000];
\end_layout

\begin_layout Plain Layout

void inserisci_collegamento(fermata *grafo,int a, int b) {
\end_layout

\begin_layout Plain Layout

	grafo[a].collegamenti.push_back(b);
\end_layout

\begin_layout Plain Layout

	grafo[b].collegamenti.push_back(a); 
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

int visita(fermata *grafo, int n) { 	
\end_layout

\begin_layout Plain Layout

	int contatore = 0; 	
\end_layout

\begin_layout Plain Layout

	bool visitato[1000]; 	
\end_layout

\begin_layout Plain Layout

	stack <int> pila; 	
\end_layout

\begin_layout Plain Layout

	fill(visitato, visitato + 1000,false); 	
\end_layout

\begin_layout Plain Layout

	pila.push(n); 	
\end_layout

\begin_layout Plain Layout

	while(!pila.empty()) { 		
\end_layout

\begin_layout Plain Layout

		int corrente = pila.top(); 		
\end_layout

\begin_layout Plain Layout

		pila.pop(); 		
\end_layout

\begin_layout Plain Layout

		if (visitato[corrente] == false) {
\end_layout

\begin_layout Plain Layout

			visitato[corrente] = true; 			
\end_layout

\begin_layout Plain Layout

			if (grafo[corrente].attrazione == true) contatore++;
\end_layout

\begin_layout Plain Layout

			list <int>::iterator i; 			
\end_layout

\begin_layout Plain Layout

			for (i = grafo[corrente].collegamenti.begin();
\end_layout

\begin_layout Plain Layout

				i!=grafo[corrente].collegamenti.end(); i++)
\end_layout

\begin_layout Plain Layout

				pila.push(*i); 		
\end_layout

\begin_layout Plain Layout

		} 	
\end_layout

\begin_layout Plain Layout

	} 	
\end_layout

\begin_layout Plain Layout

	return contatore; 
\end_layout

\begin_layout Plain Layout

} 
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

int main() { 	
\end_layout

\begin_layout Plain Layout

	ifstream in("input.txt"); 	
\end_layout

\begin_layout Plain Layout

	ofstream out("output.txt"); 	
\end_layout

\begin_layout Plain Layout

	int temp,a,b; 	
\end_layout

\begin_layout Plain Layout

	in >> N >> A >> Mg >> Mb >> Mt; 	
\end_layout

\begin_layout Plain Layout

	for (int i = 0; i < A; i++) { 		
\end_layout

\begin_layout Plain Layout

		in >> temp; 		
\end_layout

\begin_layout Plain Layout

		gratuiti[temp].attrazione = bus[temp].attrazione =
\end_layout

\begin_layout Plain Layout

		traghetti[temp].attrazione = tutti[temp].attrazione = true; 	
\end_layout

\begin_layout Plain Layout

	} 	
\end_layout

\begin_layout Plain Layout

	for (int i = 0; i < Mg; i++) 	{ 		
\end_layout

\begin_layout Plain Layout

		in >> a >> b;
\end_layout

\begin_layout Plain Layout

		inserisci_collegamento(gratuiti,a,b);
\end_layout

\begin_layout Plain Layout

		inserisci_collegamento(bus,a,b);
\end_layout

\begin_layout Plain Layout

		inserisci_collegamento(traghetti,a,b);
\end_layout

\begin_layout Plain Layout

		inserisci_collegamento(tutti,a,b); 	
\end_layout

\begin_layout Plain Layout

	} 	
\end_layout

\begin_layout Plain Layout

	for (int i = 0; i < Mb; i++) 	{ 		
\end_layout

\begin_layout Plain Layout

		in >> a >> b; 		
\end_layout

\begin_layout Plain Layout

		inserisci_collegamento(bus,a,b);
\end_layout

\begin_layout Plain Layout

		inserisci_collegamento(tutti,a,b); 	
\end_layout

\begin_layout Plain Layout

	} 	
\end_layout

\begin_layout Plain Layout

	for (int i = 0; i < Mt; i++) 	{ 		
\end_layout

\begin_layout Plain Layout

		in >> a >> b;
\end_layout

\begin_layout Plain Layout

		inserisci_collegamento(traghetti,a,b);
\end_layout

\begin_layout Plain Layout

		inserisci_collegamento(tutti,a,b); 	
\end_layout

\begin_layout Plain Layout

	} 	
\end_layout

\begin_layout Plain Layout

	out << visita(gratuiti,0) << endl; 	
\end_layout

\begin_layout Plain Layout

	out << visita(bus,0) << endl; 	
\end_layout

\begin_layout Plain Layout

	out << visita(traghetti,0) << endl; 	
\end_layout

\begin_layout Plain Layout

	out << visita(tutti,0) << endl;     
\end_layout

\begin_layout Plain Layout

	return 0; 
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Come prima cosa viene creata una struttura che rappresenta ogni fermata,
 che contiene le informazioni dei collegamenti che partono da quella fermata
 all'interno di una lista e un booleano che indica se la fermata è un'attrazione
 o meno, informazione che servirà a contare le attrazioni visitabili (righe
 1-5).
\end_layout

\begin_layout Standard
I quattro grafi saranno quindi dei vettori di fermate, dimensionati secondo
 i limiti del problema.
\end_layout

\begin_layout Standard
La parte risolutiva vera e propria del problema è la funzione 
\emph on
visita
\emph default
, che ha come parametri il grafo su cui deve essere applicata e il nodo
 di partenza (che in questo particolare problema è sempre il nodo 0).
 In questo caso è stata implementata una visita in profondità, ma si poteva
 fare anche una visita in ampiezza e non sarebbe cambiato niente.
 Il codice è uguale a quello mostrato a pagina 
\begin_inset CommandInset ref
LatexCommand pageref
reference "sec:visite"

\end_inset

, con alla riga 23 il controllo sulla condizione che il nodo visitato sia
 un'attrazione o no, per incrementare il contatore che poi verrà restituito
 dalla funzione.
 Due parole sulla funzione 
\emph on
fill
\emph default
 usata alla riga 16: come l'algoritmo 
\emph on
sort
\emph default
 fa parte dell'header 
\emph on
algorithm
\emph default
 e può essere comoda quando si deve inizializzare un vettore, in questo
 caso con tutte le cella a false: è chiaro che si sarebbe potuto usare un
 semplice 
\emph on
for
\emph default
, ma abituarsi a usare le librerie che mette a disposizione il C++ può essere
 utile in casi più complessi.
\end_layout

\begin_layout Standard
A questo punto l'altra parte del processo risolutivo prevede una corretta
 lettura dei dati di input, in particolare dei collegamenti: dopo aver segnato
 le stazioni che sono anche delle attrazioni (righe 38-42), si ripete per
 tre volte la stessa serie di istruzioni, per leggere i tre tipi di collegamenti
: i collegamenti gratuiti verranno inseriti in ogni grafo (righe 43-49),
 quelli dei bus solo nel grafo dei bus e in quello che li contiene tutti
 (righe 50-54) e quelli dei traghetti solo nel grafo dei traghetti e in
 quello che li contiene tutti (righe 55-59).
\end_layout

\begin_layout Standard
Dopo aver creato i grafi si chiamerà semplicemente la 
\emph on
funzione
\emph default
 visita sui quattro grafi (righe 60-63), ottenendo l'output desiderato.
\end_layout

\begin_layout Section
Trova la parola - territoriali 2013
\end_layout

\begin_layout Standard
\begin_inset Box Framed
position "t"
hor_pos "c"
has_inner_box 0
inner_pos "t"
use_parbox 0
use_makebox 0
width "100col%"
special "none"
height "1in"
height_special "totalheight"
status collapsed

\begin_layout Subsection*
Trova la parola (trovaparola) 
\end_layout

\begin_layout Subsubsection*
Difficoltà D = 2.
 
\end_layout

\begin_layout Subsubsection*
Descrizione del problema
\end_layout

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename ../materiali/problemi territoriali/2013_trovaparola/ruzzle.png
	scale 60

\end_inset


\end_layout

\begin_layout Plain Layout
Visto il successo del gioco Ruzzle©, che riprende il noto paroliere, i giochi
 basati su trovare parole stanno vivendo un periodo molto popolare.
 Luciano, patito di giochi di tutti i tipi, ha ideato un nuovo gioco, che
 funziona nel modo seguente: avete una griglia di caratteri e una parola
 da trovare nella griglia, partendo dalla cella in alto a sinistra.
 Le uniche mosse consentite sono gli spostamenti a destra o in basso.
 Ad esempio, considerate la seguente griglia e la parola “olimpiadi”: 
\end_layout

\begin_layout Plain Layout
\begin_inset Tabular
<lyxtabular version="3" rows="8" columns="7">
<features tabularvalignment="middle">
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0pt">
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0pt">
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
O
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
L
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
I
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
V
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
E
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
N
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
T
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
G
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Q
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
M
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
P
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
W
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
E
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
R
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
G
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
T
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
R
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
I
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
A
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Y
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
E
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
I
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
U
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
I
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
C
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
D
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
P
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
E
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
A
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
F
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
C
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
O
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
I
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
G
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
H
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
J
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
K
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
X
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
C
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
V
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
R
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
S
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
R
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
O
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
M
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
I
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
T
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
A
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
A
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
S
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
T
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
A
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
N
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
L
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
E
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
E
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Plain Layout
In questo caso, la sequenza di spostamenti è “DDBDBDBB”, rappresentando
 gli spostamenti a destra con il carattere D e quelli in basso con il carattere
 B.
 Non esiste nessuna soluzione, invece, se la parola da cercare è “olimpionico”.
 Il vostro compito consiste nello scrivere un programma che, ricevute in
 ingresso una parola (da cercare) e una griglia, restituisca la sequenza
 di spostamenti, qualora esista una soluzione, oppure stampi “ASSENTE”.
 Se dovessero esistere molteplici sequenze di spostamenti corrette, è sufficient
e stamparne una qualunque.
 
\end_layout

\begin_layout Subsubsection*
Dati di input
\end_layout

\begin_layout Plain Layout
Il file input.txt è composto da 2+R righe.
 La prima riga contiene due interi positivi R e C: le dimensioni della griglia,
 ovvero il numero di righe R e il numero di colonne C.
 La riga successiva contiene P, una parola da cercare, rappresentata da
 una stringa lunga almeno 2 caratteri (alfabetici maiuscoli) e al massimo
 R+C-1 caratteri.
 Le rimanenti R righe del file contengono le righe della griglia, rappresentate
 da stringhe di C caratteri alfabetici maiuscoli.
 
\end_layout

\begin_layout Subsubsection*
Dati di output
\end_layout

\begin_layout Plain Layout
Il file output.txt è composto da una sola riga contenente una stringa di
 testo: la sequenza di spostamenti necessari per trovare la parola nella
 griglia, se la parola è presente, oppure la stringa “ASSENTE” (senza le
 virgolette).
 
\end_layout

\begin_layout Subsubsection*
Assunzioni
\end_layout

\begin_layout Itemize
2 ≤ R,C ≤ 100; 
\end_layout

\begin_layout Subsubsection*
Esempi di input/output 
\end_layout

\begin_layout Plain Layout
\begin_inset Tabular
<lyxtabular version="3" rows="2" columns="2">
<features tabularvalignment="middle">
<column alignment="left" valignment="top" width="1in">
<column alignment="left" valignment="top" width="0">
<row>
<cell alignment="left" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
File input.txt
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
File output.txt
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
8 7
\end_layout

\begin_layout Plain Layout

\family typewriter
OLIMPIADI
\end_layout

\begin_layout Plain Layout

\family typewriter
OLIVENT
\end_layout

\begin_layout Plain Layout

\family typewriter
GQMPWER
\end_layout

\begin_layout Plain Layout

\family typewriter
GTRIAYE
\end_layout

\begin_layout Plain Layout

\family typewriter
IUICDPE
\end_layout

\begin_layout Plain Layout

\family typewriter
AFCOIGH
\end_layout

\begin_layout Plain Layout

\family typewriter
JKXCVRS
\end_layout

\begin_layout Plain Layout

\family typewriter
ROMITAA
\end_layout

\begin_layout Plain Layout

\family typewriter
STANLEE
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
DDBDBDBB
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset VSpace bigskip
\end_inset


\begin_inset Tabular
<lyxtabular version="3" rows="2" columns="2">
<features tabularvalignment="middle">
<column alignment="left" valignment="top" width="1in">
<column alignment="left" valignment="top" width="0">
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
File input.txt
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
File output.txt
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
8 7
\end_layout

\begin_layout Plain Layout

\family typewriter
OLIMPIONICO
\end_layout

\begin_layout Plain Layout

\family typewriter
OLIVENT
\end_layout

\begin_layout Plain Layout

\family typewriter
GQMPWER
\end_layout

\begin_layout Plain Layout

\family typewriter
GTRIAYE
\end_layout

\begin_layout Plain Layout

\family typewriter
IUICDPE
\end_layout

\begin_layout Plain Layout

\family typewriter
AFCOIGH
\end_layout

\begin_layout Plain Layout

\family typewriter
JKXCVRS
\end_layout

\begin_layout Plain Layout

\family typewriter
ROMITAA
\end_layout

\begin_layout Plain Layout

\family typewriter
STANLEE
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
ASSENTE
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Suggerimenti
\family typewriter

\begin_inset Foot
status collapsed

\begin_layout Plain Layout

\family typewriter
John Romita e Stan Lee, che compaiono nell'ultima e penultima riga dell'esempio,
 sono rispettivamente il secondo disegnatore del fumetto Spider Man e il
 creatore dello stesso.
\end_layout

\end_inset


\end_layout

\begin_layout Itemize
Dalla figura sembra ovvio quale sia la struttura dati più adatta per memorizzare
 i dati, una matrice, può essere meno ovvio quali funzioni del linguaggio
 usare per la lettura dell'input (scanf, gets, una riga alla volta, un carattere
 alla volta,...).
 Quale ti sembra la migliore (magari prova in modi diversi)?
\end_layout

\begin_layout Itemize
Le dimensioni massime dell'input fino a quale complessità computazionale
 permettono di arrivare senza problemi (lineare, quadratica, cubica, ...)?
\end_layout

\begin_layout Itemize
Come in altri problemi sembra utile potersi 
\begin_inset Quotes eld
\end_inset

muovere
\begin_inset Quotes erd
\end_inset

 nella matrice, seguendo due possibili direzioni: siccome quando mi sposto
 in una matrice devo sempre stare attento a non uscire dei bordi, dove posso
 mettere delle sentinelle per evitare controlli espliciti?
\end_layout

\begin_layout Itemize
Riesco a implementare i movimenti tramite un approccio iterativo o viene
 più naturale un approccio ricorsivo?
\end_layout

\begin_layout Itemize
Se l'approccio ricorsivo creasse dei problemi nell'implementazione, potrei
 sostituirlo con uno iterativo molto semplice che, seppur non mi garantisca
 la correttezza in tutti i casi, può ragionevolmente portare molti punti
 in saccoccia?
\end_layout

\begin_layout Subsection
Soluzione
\end_layout

\begin_layout Standard
Come già detto nei suggerimenti sembra piuttosto chiaro che una matrice
 sia la struttura dati adatta per affrontare questo problema: bisogna però
 porre qualche attenzione su come popolare la matrice, dato il file di input
 nel formato proposto.
 Quando infatti all'interno dello stesso file compaiono sia numeri che stringhe
 le normali funzioni per l'input potrebbero generare qualche problema: per
 questo particolare problema potremmo procedere in tre modi distinti
\end_layout

\begin_layout Itemize
usare l'operatore 
\emph on
<<
\emph default
 (o 
\emph on
fscanf
\emph default
) sia per i numeri che per le stringhe
\end_layout

\begin_layout Itemize
usare l'operatore 
\emph on
<<
\emph default
 (o 
\emph on
fscanf
\emph default
) per leggere i numeri e la 
\emph on
getline
\emph default
 (o la 
\emph on
fgets
\emph default
) per le stringhe, leggendo quindi una riga di testo alla volta
\end_layout

\begin_layout Itemize
usare l'operatore 
\emph on
<<
\emph default
 (o la 
\emph on
fscanf
\emph default
) per leggere il contenuto della matrice carattere per carattere
\end_layout

\begin_layout Standard
Il primo approccio è in questo caso quello corretto, in quanto la lettura
 dei numeri non interferisce con la successiva lettura delle stringhe ed
 è molto comodo poichè, siccome ogni riga non contiene spazi, può essere
 letta tutta in un colpo e messa nella matrice così com'è.
\end_layout

\begin_layout Standard
Il secondo pone dei problemi, in quanto la 
\emph on
getline
\emph default
 (o la 
\emph on
fgets
\emph default
) non funzionano nello stesso modo dell'operatore 
\emph on
<<
\emph default
 (o della 
\emph on
fscanf
\emph default
), in particolare gestiscono diversamente il terminatore, quindi alternarle
 all'interno dello stesso programma non è mai una buona idea.
\end_layout

\begin_layout Standard
L'ultimo approccio potrebbe sembrare corretto dal momento che nei dati forniti
 in output compare anche la lunghezza delle stringhe, sotto forma del valore
 di C, e sembra quindi un invito a leggere carattere per carattere con due
 cicli annidati limitati da C e R.
 In realtà così è molto più scomodo che con il primo approccio, poichè bisognere
bbe anche gestire il terminatore di linea che altrimenti verrebbe letto
 come un qualsiasi altro carattere.
\end_layout

\begin_layout Standard
Di fatto il primo approccio rende anche inutile la lettura del valore di
 C, che non viene mai usato, ma in questo caso non bisogna preoccuparsene,
 quindi va letto ma poi ignorato, come mostrato alle righe 24-27 del codice
 sottostante.
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "basicstyle={\small\ttfamily},frame=lr,language={C++},numbers=left,showstringspaces=false,tabsize=4"
inline false
status collapsed

\begin_layout Plain Layout

int R,C; 
\end_layout

\begin_layout Plain Layout

char matrice[101][101]; 
\end_layout

\begin_layout Plain Layout

char parola[201]; 
\end_layout

\begin_layout Plain Layout

stack <char> percorso;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

bool naviga(int i, int j, int l) { 	
\end_layout

\begin_layout Plain Layout

	if (l == strlen(parola)-1 && matrice[i][j] == parola[l] )
\end_layout

\begin_layout Plain Layout

		return true; 	
\end_layout

\begin_layout Plain Layout

	if (matrice[i][j] != parola[l]) 		
\end_layout

\begin_layout Plain Layout

		return false; 	
\end_layout

\begin_layout Plain Layout

	if (naviga(i+1,j,l+1) == true) {
\end_layout

\begin_layout Plain Layout

		percorso.push('B'); 		
\end_layout

\begin_layout Plain Layout

		return true; 
\end_layout

\begin_layout Plain Layout

	} 	
\end_layout

\begin_layout Plain Layout

	if (naviga(i,j+1,l+1) == true) {
\end_layout

\begin_layout Plain Layout

		percorso.push('D'); 		
\end_layout

\begin_layout Plain Layout

		return true; 	
\end_layout

\begin_layout Plain Layout

	}	 
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

int main() { 	
\end_layout

\begin_layout Plain Layout

	ifstream in("input.txt"); 	
\end_layout

\begin_layout Plain Layout

	ofstream out("output.txt"); 	
\end_layout

\begin_layout Plain Layout

	in >> R >> C; 	
\end_layout

\begin_layout Plain Layout

	in >> parola; 	
\end_layout

\begin_layout Plain Layout

	for (int i = 0; i < R; i++) 		
\end_layout

\begin_layout Plain Layout

		in >> matrice[i]; 	
\end_layout

\begin_layout Plain Layout

	if (naviga(0,0,0) == true) {
\end_layout

\begin_layout Plain Layout

		while(!percorso.empty()) {
\end_layout

\begin_layout Plain Layout

			out << percorso.top(); 			
\end_layout

\begin_layout Plain Layout

			percorso.pop(); 	
\end_layout

\begin_layout Plain Layout

		} 		
\end_layout

\begin_layout Plain Layout

		out << endl; 	
\end_layout

\begin_layout Plain Layout

	} 	
\end_layout

\begin_layout Plain Layout

	else 		
\end_layout

\begin_layout Plain Layout

		out << "ASSENTE" << endl; 	
\end_layout

\begin_layout Plain Layout

	return 0; 
\end_layout

\begin_layout Plain Layout

}	
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Una volta chiarito come procedere con la lettura dei dati, si può provare
 a risolvere il problema con un approccio banale, che può anche far guadagnare
 diversi punti, ma che fallisce in alcuni casi.
 L'idea potrebbe essere la seguente:
\end_layout

\begin_layout Itemize
si pone la posizione di partenza uguale all'angolo in alto a sinistra, cioè
 con i=0 e j=0 e la lettera da controllare uguale alla prima lettera nella
 parola P, cioè P[0].
 Se la lettera in posizione di partenza e P[0] coincidono allora si procede,
 altrimenti ci si può già fermare
\end_layout

\begin_layout Itemize
si verifica che la lettera in posizione (i+1,j) sia uguale alla prossima
 lettera di P
\end_layout

\begin_deeper
\begin_layout Itemize
se lo è si sposta la posizione corrente in (i+1,j), si concatena la lettera
 B in una stringa di supporto e si ripete il procedimento
\end_layout

\begin_layout Itemize
se non lo è si verifica che la lettera in posizione (i,j+1) sia uguale alla
 prossima lettera di P
\end_layout

\begin_deeper
\begin_layout Itemize
se lo è si sposta la posizione corrente in (i,j+1), si concatena la lettera
 D in una stringa di supporto e si ripete il procedimento
\end_layout

\begin_layout Itemize
se non lo è la parola è ASSENTE
\end_layout

\end_deeper
\end_deeper
\begin_layout Itemize
se si arriva a una posizione pari alla lunghezza della parola P allora la
 parola è stata trovata e si stampa la stringa di supporto.
\end_layout

\begin_layout Standard
Questo procedimento è estremamente semplice da capire e implementare, ma
 ha il difetto di non portare sempre alla soluzione e apro un inciso: perchè
 vedere allora un procedimento non corretto? Come già detto in altre parti
 lo scopo di queste competizioni non è necessariamente quello di risolvere
 un problema correttamente, ma fare più punti possibile.
 É chiaro che la soluzione corretta porta al maggior numero di punti e quindi
 va ricercata, ma se non si riesce a fare di meglio anche una soluzione
 come questa non è da disdegnare.
 
\end_layout

\begin_layout Standard
Ma perchè non è corretta? Il problema sorge in alcuni casi, come si può
 vedere nella figura 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:Problema-trovaparola"

\end_inset

.
 Supponendo di dover cercare la parola BANCONE, nel caso indicato con (a)
 l'algoritmo produrrebbe la soluzione corretta, mentre nel caso (b) dopo
 essere giunto alla C si fermerebbe, poichè non troverebbe la O nè a destra
 nè in basso.
 Il problema nasce dal fatto che al passaggio precedente l'algoritmo era
 costretto a scegliere di scendere verso il basso, poichè è la prima cosa
 che controlla, e una volta sceso non ha modo di tornare sui propri passi.
 Per arrivare alla soluzione corretta sarebbe dovuto andare verso destra
 e avrebbe così trovato la soluzione con le lettere in italico.
 Ovviamente il problema non si può risolvere semplicemente scambiando l'ordine
 dei controlli (prima a destra e poi in basso), perchè basterebbe 
\begin_inset Quotes eld
\end_inset

ruotare
\begin_inset Quotes erd
\end_inset

 l'esempio (b) e il problema si presenterebbe comunque.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename ../materiali/problemi territoriali/2013_trovaparola/esempio problema.eps
	display false

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:Problema-trovaparola"

\end_inset

Problema con l'algoritmo banale
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Standard
A questo punto dovrebbe essere chiaro che il modo naturale di impostare
 questo problema è quello di permettere all'algoritmo di poter effettuare
 sia la visita nella casella in basso che in quella di sinistra e questo
 può essere ottenuto molto semplicemente attraverso una funzione ricorsiva.
 
\end_layout

\begin_layout Standard
Come impostare la ricorsione? L'idea, come nel precedente approccio, è quella
 di, partendo dalla casella in alto a sinistra, visitare ogni casella che
 sia compatibile con la parola da cercare o in basso o a destra e ripetere
 questo procedimento fino a quando la lettera nella casella corrente non
 sia diversa da quella nella parola da cercare oppure fino a quando non
 troviamo la parola.
 Tradotto in pseudocodice la ricorsione può essere impostata così:
\end_layout

\begin_layout Itemize
siano 
\emph on
i
\emph default
 e 
\emph on
j
\emph default
 le coordinate di riga e colonna nella matrice del Ruzzle© e 
\emph on
l
\emph default
 l'indice della lettera corrente nella parola da cercare
\end_layout

\begin_layout Itemize
le condizioni di terminazioni saranno
\end_layout

\begin_deeper
\begin_layout Itemize
se siamo arrivati fino alla fine della parola e la casella corrente ha il
 valore dell'ultima lettera, allora abbiamo trovato un percorso per la parola
 e restituiamo 
\emph on
true
\emph default
 (righe 7-8)
\end_layout

\begin_layout Itemize
se la casella corrente è diversa dalla lettera alla quale siamo arrivati
 restituiamo 
\emph on
false
\emph default
 perchè quella strada non porta da nessuna parte (righe 9-10)
\end_layout

\end_deeper
\begin_layout Itemize
se è possibile spostarsi nella casella in basso lo faccio e memorizzo il
 valore di spostamento 'B' in uno stack temporaneo (di cui si parlerà dopo)
 (righe 11-14)
\end_layout

\begin_layout Itemize
se è possibile spostarsi nella casella a destra lo faccio e memorizzo il
 valore di spostamento 'D' in uno stack temporaneo (righe 15-17)
\end_layout

\begin_layout Standard
Come si vede dal codice l'implementazione è immediata e la chiamata (riga
 28) avrà come parametri i valori i = 0, j = 0 e l = 0, poichè si parte
 dalla casella in alto a sinistra e dalla prima lettera della parola cercata.
 Se la funzione ritorna 
\emph on
false
\emph default
 vuol dire che la parola non è stata trovata e quindi verrà stampato ASSENTE,
 altrimenti bisogna stampare un possibile percorso (non è necessariamente
 l'unico, ma è il primo che viene trovato).
 Per far questo nella funzione 
\emph on
naviga
\emph default
 viene utilizzato uno stack, nel quale vengono inserire tutte le mosse fatte
 per arrivare alla soluzione.
 Siccome lo stack verrà riempito a partire dalla fine, via via che le chiamate
 ricorsive ritornano, basterà svuotare lo stack (righe 29-32) in stampa
 per ritrovarsi il percorso nell'ordine corretto.
 Si sarebbe anche potuta usare una semplice stringa per poi stamparla al
 contrario, ma l'utilizzo di strutture dati più adatte (in questo caso uno
 stack), mette al riparo da ogni errore banale, poichè forza ad utilizzare
 il modo giusto.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename ../materiali/problemi territoriali/2013_trovaparola/caso pessimo.eps
	display false
	scale 70

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:Caso-pessimo-trovaparola"

\end_inset

Caso pessimo per trovaparola
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Standard
Vale la pena a questo punto fare due osservazioni: 
\end_layout

\begin_layout Itemize
l'algoritmo non rischia di uscire dai bordi della matrice in qualche caso
 particolare? No, e il motivo è che, spostandosi solo in basso o a destra,
 incontrerà sempre un terminatore di stringa che lo farà fermare perchè
 renderà il carattere non uguale a quello cercato: per la colonna di destra
 dopo i caratteri validi, il terminatore sarà presente perchè inserito in
 fase di lettura, per la riga sotto agli ultimi caratteri validi la presenza
 del terminatore (un carattere con tutti i bit a zero) è garantita dal fatto
 che essendo la matrice una variabile globale tutte le sue caselle vengono
 azzerate alla partenza del programma
\end_layout

\begin_layout Itemize
qual è la complessità di questo algoritmo? Mentre il primo algoritmo proposto
 era di complessità lineare questo è in generale di tipo esponenziale, poichè
 ogni chiamata ricorsiva richiama due volte la stessa funzione e quindi,
 anche se N è piccolo (≤100) il numero di chiamate ricorsive nel caso pessimo
 (
\begin_inset Formula $2^{100}$
\end_inset

) è troppo elevato.
 Però il caso pessimo è un caso molto particolare, che deve essere costruito
 di proposito, come si può vedere in figura 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:Caso-pessimo-trovaparola"

\end_inset

, dove la parola da cercare è BANCO.
 In questo esempio la ricorsione è 
\begin_inset Quotes eld
\end_inset

obbligata
\begin_inset Quotes erd
\end_inset

 a provare tutte le strade, poichè si accorge che non porta a niente solo
 all'ultima lettera.
 Se però il caso è creato inserendo delle lettere casuali più eventualmente
 la parola da trovare, la maggior parte delle chiamate ricorsive verranno
 terminate all'inizio e quindi la maggior parte dei rami non verrà mai svolta,
 rendendo il costo poco più che lineare.
 Essendo al livello delle regionali si suppone che questa soluzione sia
 quella che consente di raccogliere tutti punti.
\end_layout

\begin_layout Section
La congettura di Collatz - territoriali 2014
\end_layout

\begin_layout Standard
\begin_inset Box Framed
position "t"
hor_pos "c"
has_inner_box 0
inner_pos "t"
use_parbox 0
use_makebox 0
width "100col%"
special "none"
height "1in"
height_special "totalheight"
status collapsed

\begin_layout Subsection*
La congettura di Collatz (collatz) 
\end_layout

\begin_layout Subsubsection*
Difficoltà D = 1 
\end_layout

\begin_layout Subsubsection*
Descrizione del problema
\end_layout

\begin_layout Plain Layout
Consideriamo il seguente algoritmo, che prende in ingresso un intero positivo
 N: 
\end_layout

\begin_layout Enumerate
Se N vale 1, l’algoritmo termina.
 
\end_layout

\begin_layout Enumerate
Se N è pari, dividi N per 2, altrimenti (se N è dispari) moltiplicalo per
 3 e aggiungi 1.
\end_layout

\begin_layout Plain Layout
Per esempio, applicato al valore N = 6, l’algoritmo produce la seguente
 sequenza (di lunghezza 9, contando anche il valore iniziale N = 6 e il
 valore finale 1): 
\end_layout

\begin_layout Plain Layout
\align center
6, 3, 10, 5, 16, 8, 4, 2, 1.
\end_layout

\begin_layout Plain Layout
La congettura di Collatz, chiamata anche congettura 3N+1, afferma che l’algoritm
o qui sopra termini sempre per qualsiasi valore N; in altri termini, se
 prendo un qualsiasi numero intero maggiore di 1 applicare la regola numero
 2 conduce sempre al numero 1.
\end_layout

\begin_layout Plain Layout
È riferendosi a questa celebre congettura che il famoso matematico Erdős
 ha commentato sul come questioni semplici ma elusive mettono in evidenza
 quanto poco noi si possa accedere ai misteri del “grande Libro”.
\end_layout

\begin_layout Plain Layout
Giovanni sta cercando di dimostrare la congettura, ed è interessato alla
 lunghezza della sequenza.
 Il vostro compito è quello di aiutare Giovanni scrivendo un programma che,
 ricevuto in ingresso un numero N, calcoli la lunghezza della sequenza che
 si ottiene a partire da N.
 
\end_layout

\begin_layout Subsubsection*
Dati di input
\end_layout

\begin_layout Plain Layout
Il file 
\emph on
input.txt
\emph default
 è composto da una riga contenente N, un intero positivo.
 
\end_layout

\begin_layout Subsubsection*
Dati di output
\end_layout

\begin_layout Plain Layout
Il file 
\emph on
output.txt
\emph default
 è composto da una sola riga contenente un intero positivo L: la lunghezza
 della sequenza a partire da N.
 
\end_layout

\begin_layout Subsubsection*
Assunzioni
\end_layout

\begin_layout Itemize
2 ≤ N ≤ 1000; 
\end_layout

\begin_layout Itemize
E’ noto che, per qualsiasi N minore di 1000, la lunghezza L della sequenza
 è minore di 200.
\end_layout

\begin_layout Subsubsection*
Esempi di input/output 
\end_layout

\begin_layout Plain Layout
\begin_inset Tabular
<lyxtabular version="3" rows="2" columns="2">
<features tabularvalignment="middle">
<column alignment="left" valignment="top" width="1in">
<column alignment="left" valignment="top" width="0">
<row>
<cell alignment="left" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
File input.txt
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
File output.txt
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
6
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
9
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Tabular
<lyxtabular version="3" rows="2" columns="2">
<features tabularvalignment="middle">
<column alignment="left" valignment="top" width="1in">
<column alignment="left" valignment="top" width="0">
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
File input.txt
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
File output.txt
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
24
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
11
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Suggerimenti
\end_layout

\begin_layout Standard
Questo problema è molto semplice, perchè chiede solo di implementare una
 successione di numeri seguendo la regola che permette di calcolare il nuovo
 elemento della successione in base al valore dell'elemento attuale.
 L'unica domanda che ci si potrebbe porre è quella se prediligere una soluzione
 iterativa o una ricorsiva.
 
\end_layout

\begin_layout Itemize
Riesco a risolverlo sia in modo iterativo che ricorsivo?
\end_layout

\begin_layout Itemize
Quali sono i vantaggi o gli svantaggi di entrambe le soluzioni?
\end_layout

\begin_layout Itemize
Ai fini della soluzione di questo particolare problema, con i vincoli imposti
 sulla sua dimensione, sono rilevanti le differenze tra le due implementazioni?
\end_layout

\begin_layout Subsection
Soluzione
\end_layout

\begin_layout Standard
Considerando la semplicità del problema, spenderemo alcune parole solo sulla
 differenza tra le due possibili implementazioni, mostrate di seguito.
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "basicstyle={\small\ttfamily},frame=lr,language={C++},numbers=left,showstringspaces=false,tabsize=4"
inline false
status collapsed

\begin_layout Plain Layout

int lunghezza_collatz(int n) { 	
\end_layout

\begin_layout Plain Layout

	int lunghezza = 1; 	
\end_layout

\begin_layout Plain Layout

	while (n != 1) 	{ 		
\end_layout

\begin_layout Plain Layout

		if (n % 2) 			
\end_layout

\begin_layout Plain Layout

			n = n*3 + 1; 		
\end_layout

\begin_layout Plain Layout

		else 			
\end_layout

\begin_layout Plain Layout

			n = n/2; 		
\end_layout

\begin_layout Plain Layout

		lunghezza++; 	
\end_layout

\begin_layout Plain Layout

	} 	
\end_layout

\begin_layout Plain Layout

	return lunghezza; 
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

int lunghezza_collatz_ric(int n) { 	
\end_layout

\begin_layout Plain Layout

	if (n == 1) 		
\end_layout

\begin_layout Plain Layout

		return 1; 	
\end_layout

\begin_layout Plain Layout

	if (n % 2) 		
\end_layout

\begin_layout Plain Layout

		return lunghezza_collatz_ric(3*n + 1) + 1; 	
\end_layout

\begin_layout Plain Layout

	else 		
\end_layout

\begin_layout Plain Layout

		return lunghezza_collatz_ric(n/2) + 1; 
\end_layout

\begin_layout Plain Layout

} 	
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Come si può vedere la prima funzione, quella iterativa, non fa altro che
 riapplicare la regola numero 2 del testo finchè non si verifica la condizione
 1: l'unica attenzione è da porre nell'inizializzazione del contatore della
 lunghezza, che viene messo a 1 per garantire il rispetto dei requisiti
 del problema (contare tutti gli elemento della successione, compreso il
 numero di partenza e l'1).
 La seconda funzione, quella ricorsiva, appare ancora più naturale, essendo
 una riscrittura pari pari delle due condizioni spiegate nel testo.
\end_layout

\begin_layout Standard
Appurato quindi che da un punto di vista della scrittura del codice sono
 entrambe semplici da scrivere, possiamo vedere che differenze ci sono in
 termini di prestazioni e occupazione di memoria:
\end_layout

\begin_layout Itemize
la funzione ricorsiva richiederà alla peggio 200 chiamate (vedi testo del
 problema), dove quella iterativa viene chiamata una sola volta, quindi
 potrebbe esserci un costo maggiore dovuto all'overhead di chiamata di funzione:
 su test fatti sulla mia macchina usando l'utility 
\series bold
time
\series default
 presente di default sui sistemi Linux non si nota nessuna differenza significat
iva tra le due impelementazioni.
 Per stressare maggiormente le differenze ho quindi modificato il programma
 per calcolare la lunghezza di tutte le successioni di Collatz da 2 a 100000,
 ottenendo dei risultati che effettivamente mostrano che la versione iterativa
 ha delle performance leggermente migliori, come si può vedere dalla seguente
 tabella (i dati esatti sono differenti tra differenti esecuzioni del comando,
 ma indicativamente sono sempre intorno ai valori mostrati)
\end_layout

\begin_layout Standard
\align center
\begin_inset Tabular
<lyxtabular version="3" rows="2" columns="2">
<features tabularvalignment="middle">
<column alignment="left" valignment="top" width="5cm">
<column alignment="left" valignment="top" width="5cm">
<row>
<cell alignment="left" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
\series bold
\size small
Versione iterativa
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
\series bold
\size small
Versione ricorsiva
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
\size small
real 0m0.136s 
\end_layout

\begin_layout Plain Layout

\family typewriter
\size small
user 0m0.020s 
\end_layout

\begin_layout Plain Layout

\family typewriter
\size small
sys 0m0.072s 
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
\size small
real 0m0.196s 
\end_layout

\begin_layout Plain Layout

\family typewriter
\size small
user 0m0.068s 
\end_layout

\begin_layout Plain Layout

\family typewriter
\size small
sys 0m0.076s 
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Itemize
per quanto riguarda l'utilizzo della memoria, la versione iterativa potrebbe
 avere il problema che lo stack cresce a ogni chiamata ricorsiva, ponendo
 quindi dei problemi di 
\begin_inset Quotes eld
\end_inset

sforamento
\begin_inset Quotes erd
\end_inset

 dello stack.
 Considerando però i vincoli del problema lo stack non crescerà mai a sufficienz
a per presentare un rischio di segmentation fault e anche con le prove fatte
 con N da 2 a 100000 la successione di Collatz di lunghezza maggiore si
 ferma a 351, limite ampiamente all'interno della possibilità di crescita
 dello stack.
\end_layout

\begin_layout Standard
Concludendo, pur essendo in generale utile fare delle considerazioni sulle
 differenze implementative tra diverse soluzioni, in questo caso tali differenze
 sono irrilevanti.
\end_layout

\begin_layout Standard
Come nota di colore voglio aggiungere una simpatica vignetta presa da xckd
\begin_inset Foot
status collapsed

\begin_layout Plain Layout
Il sito xckd.com è molto famoso nella comunità nerd e la descrizione che
 ne dà l'autore è
\end_layout

\end_inset

, che mostra cosa potrebbe succedere a Giovanni se si impegnasse troppo
 nella soluzione di questo problema...
\end_layout

\begin_layout Section
Giochiamo con Mojito - Territoriali 2014
\end_layout

\begin_layout Standard
\begin_inset Box Framed
position "t"
hor_pos "c"
has_inner_box 0
inner_pos "t"
use_parbox 0
use_makebox 0
width "100col%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout Subsection*
Giochiamo con Mojito (mojito) 
\end_layout

\begin_layout Subsubsection*
Difficoltà D = 2
\end_layout

\begin_layout Subsubsection*
Descrizione del problema
\end_layout

\begin_layout Plain Layout
Mojito, il jackrussell di Monica, è ormai diventato la mascotte dei Probabili
 Olimpici, i ragazzi che sono candidati a rappresentare l’Italia alle Olimpiadi
 Internazionali di Informatica 2014 a Taipei, Taiwan.
 Negli allenamenti a Volterra, Mojito gioca a palla con i ragazzi nel prato:
 lui porta la pallina al ragazzo più vicino che la calcia via; a quel punto
 Mojito rincorre la palla, l’acchiappa e la porta di nuovo al ragazzo che
 ha più vicino… e così via! Possiamo rappresentare questo gioco con una
 griglia: supponendo di avere tre ragazzi che giocano con Mojito, rappresentiamo
 la loro posizione nella griglia, rispettivamente, con R1, R2 e R3.
 Tutti i ragazzi sono piuttosto metodici, e ogni volta che tirano la palla
 questa finisce sempre nella stessa posizione (a seconda di chi tira!):
 sulla griglia indichiamo con P1 il punto in cui finisce la palla tirata
 da R1, P2 il punto in cui finisce la palla tirata da R2, ecc...
 La posizione iniziale di Mojito, con la palla, è rappresentata nella griglia
 da una M.
 Mojito misura la distanza come il minimo numero di spostamenti orizzontali
 e/o verticali per andare da una casella a un’altra.
 
\end_layout

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename ../materiali/problemi territoriali/2014_mojito/mojito.png
	display false
	scale 70

\end_inset


\end_layout

\begin_layout Plain Layout
Per esempio, consideriamo la griglia qui sopra, di dimensione 8x3.
 All’inizio Mojito si trova, insieme con la palla, nella casella (5,2);
 il ragazzo più vicino è R3, nella posizione (4,1), che dista due caselle
 da lui; il gioco inizia: 
\end_layout

\begin_layout Itemize
Mojito porta la palla a R3, che la tira nella casella (6,1); 
\end_layout

\begin_layout Itemize
a questo punto Mojito, presa la palla, la porta a R2, nella casella (7,1),
 che è il più vicino a lui; da qui la palla viene tirata nella casella (3,3);
 
\end_layout

\begin_layout Itemize
Mojito recupera la palla e la porta a R1, nella casella (1,3); R1 tira la
 palla nella casella (6,3); 
\end_layout

\begin_layout Itemize
da qui in poi saranno solo R1 e R2 a giocare, visto che quando tira R1 poi
 Mojito porta la palla a R2 e viceversa.
\end_layout

\begin_layout Plain Layout
Notiamo che, nel caso appena descritto, tutti e tre i ragazzi hanno giocato
 (anche se R3 ha toccato palla solo una volta).
 Se Mojito ha due o più ragazzi alla stessa distanza, sceglie quello che
 ha la coordinata X (orizzontale) minore e, se ve ne sono due o più con
 lo stesso valore, tra questi sceglie quello che ha la coordinata Y (verticale)
 minore.
 Mojito è molto concentrato sulla palla, e non riesce a ricordarsi se tutti
 i ragazzi l’hanno tirata.
 Il vostro compito è quello di scrivere un programma che calcoli il numero
 di ragazzi che lanciano la palla almeno una volta! 
\end_layout

\begin_layout Subsubsection*
Dati di input
\end_layout

\begin_layout Plain Layout
Il file 
\emph on
input.txt
\emph default
 è composto da 3+N righe.
 La prima riga contiene due interi positivi X e Y: le dimensioni della griglia.
 La seconda riga contiene una coppia di interi positivi: le coordinate della
 posizione iniziale di Mojito con la palla.
 La terza riga contiene N, il numero di ragazzi che giocano con Mojito.
 Ognuna delle successive N righe contiene due coppie di interi: le coordinate
 dell’i-esimo ragazzo (prima coppia di interi) e le coordinate di dove l’i-esimo
 ragazzo tirerà la palla.
 
\end_layout

\begin_layout Subsubsection*
Dati di output
\end_layout

\begin_layout Plain Layout
Il file 
\emph on
output.txt
\emph default
 è composto da una sola riga contenente un solo intero non negativo: il
 numero di ragazzi che giocano con Mojito, ovvero il numero di ragazzi che
 tirano la palla almeno una volta, a partire dalla posizione iniziale di
 Mojito.
 
\end_layout

\begin_layout Subsubsection*
Assunzioni
\end_layout

\begin_layout Itemize
1 ≤ X,Y,N ≤ 100 
\end_layout

\begin_layout Itemize
Le coordinate della griglia vanno da 1 a X e da 1 a Y (inclusi).
 
\end_layout

\begin_layout Itemize
Tutte le posizioni nel file di input sono distinte: non ci possono essere
 due ragazzi nella stessa casella, non ci sono due ragazzi che tirano nella
 stessa casella, nessun ragazzo tira nella casella dove c’è un altro ragazzo.
 
\end_layout

\begin_layout Itemize
Mojito, inizialmente, è in una casella non occupata da nessun ragazzo e
 dove nessun ragazzo tira la palla.
 
\end_layout

\begin_layout Itemize
Mojito, piccolo com’è, riesce agevolmente a passare tra le gambe dei ragazzi;
 non viene quindi ostacolato nel suo movimento da ragazzi presenti in una
 cella tra lui e la palla.
\end_layout

\begin_layout Subsubsection*
Esempi di input/output 
\end_layout

\begin_layout Plain Layout
\begin_inset Tabular
<lyxtabular version="3" rows="2" columns="2">
<features tabularvalignment="middle">
<column alignment="left" valignment="top" width="1in">
<column alignment="left" valignment="top" width="0">
<row>
<cell alignment="left" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
File input.txt
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
File output.txt
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
5 3
\end_layout

\begin_layout Plain Layout
3 3
\end_layout

\begin_layout Plain Layout
2
\end_layout

\begin_layout Plain Layout
4 3 5 3
\end_layout

\begin_layout Plain Layout
5 1 1 1 
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
1
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\end_inset


\end_layout

\end_body
\end_document
