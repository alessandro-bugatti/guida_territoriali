#LyX 2.0 created this file. For more info see http://www.lyx.org/
\lyxformat 413
\begin_document
\begin_header
\textclass book
\use_default_options true
\master guida.lyx
\begin_modules
logicalmkup
\end_modules
\maintain_unincluded_children false
\language italian
\language_package default
\inputencoding auto
\fontencoding global
\font_roman palatino
\font_sans helvet
\font_typewriter courier
\font_default_family default
\use_non_tex_fonts false
\font_sc false
\font_osf false
\font_sf_scale 100
\font_tt_scale 100

\graphics default
\default_output_format default
\output_sync 0
\bibtex_command default
\index_command default
\paperfontsize default
\spacing single
\use_hyperref false
\papersize default
\use_geometry false
\use_amsmath 1
\use_esint 1
\use_mhchem 1
\use_mathdots 1
\cite_engine basic
\use_bibtopic false
\use_indices false
\paperorientation portrait
\suppress_date false
\use_refstyle 1
\index Index
\shortcut idx
\color #008000
\end_index
\secnumdepth 3
\tocdepth 3
\paragraph_separation indent
\paragraph_indentation default
\quotes_language english
\papercolumns 1
\papersides 1
\paperpagestyle default
\tracking_changes false
\output_changes false
\html_math_output 0
\html_css_as_file 0
\html_be_strict false
\end_header

\begin_body

\begin_layout Chapter
Altri problemi
\end_layout

\begin_layout Standard
Questo nuovo capitolo, non presente nella prima edizione, contiene una serie
 di problemi, solitamente provenienti da gare online, che contengono aspetti
 interessanti e che quindi ho ritenuto potenzialmente utili per l'allenamento.
 Non sono stati classificati secondo un qualche ordine, ma in generale sono
 stati inseriti man mano che mi sono trovato a doverli svolgere.
 A differenza dei problemi del capitolo precedente non vengono proposte
 delle domande per invitare a riflettere, ma vengono elencati gli aspetti
 interessanti del problema e poi viene mostrata direttamente la soluzione
 commentata: questo dovrebbe permettere al lettore di scegliere se affrontare
 o meno l'esercizio in base a ciò che ritiene più utile al proprio percorso
 di apprendimento.
 La difficoltà in genere non appare sul sito di appartenenza, quindi è stata
 aggiunta da me per poterli confrontare con quelli delle selezioni territoriali.
 
\end_layout

\begin_layout Standard
Come per tutti gli esercizi di questa guida il lettore è invitato prima
 a tentare la propria strada risolutiva e solo in un secondo momento a leggere
 la soluzione proposta, che come già detto dovrebbe sempre mostrare un qualche
 aspetto interessante.
\end_layout

\begin_layout Standard
Le soluzioni di tutti i problemi affrontati sono state sottoposte al correttore
 automatico della gara dalla quale i problemi sono stati estratti, risolvendo
 correttamente tutti i casi proposti: ciò non garantisce la correttezza
 assoluta, ma da una buona confidenza che le soluzioni proposte siano corrette.
 Come sempre è stata privilegiata la semplicità di scrittura e la linearità
 della soluzione, compatibilmente con le conoscenze presunte del tipico
 lettore di questa guida.
\end_layout

\begin_layout Standard
Spesso i problemi sono estratti estratti da gare in lingua inglese, il testo
 è stato tradotto e adattato da me cercando di preservare il messagio trasmesso
 dall'ideatore originale.
 Avrei anche potuto lasciare l'originale in inglese, per abituare alla lettura
 di testi in tale lingua, cosa probabilmente molto utile, ma per non porre
 in difficoltà nessuno ho optato per la traduzione.
 Un'altra differenza è che in alcune gare al posto di leggere e scrivere
 da e verso file si fa l'I/O direttamente da tastiera e su video
\begin_inset Foot
status collapsed

\begin_layout Plain Layout
Questo è causato da differenze nei vari sistemi di correzione: di fatto
 la lettura/scrittura avviene sempre da e verso file, però il correttore
 può far apparire la cosa diversa usando meccanismi di ridirezione.
\end_layout

\end_inset

, usando quindi le normali funzioni 
\emph on
scanf
\emph default
 e 
\emph on
printf
\emph default
 per il C e 
\emph on
cin
\emph default
 e 
\emph on
cout
\emph default
 per il C++.
\end_layout

\begin_layout Standard
Dalla terza edizione sono stati aggiunti anche alcuni problemi presenti
 nelle selezioni nazionali delle Olimpiadi Italiane, con lo scopo di poter
 offrire un minimo di supporto a chi ha passato i territoriali e si trova
 a doversi preparare per i nazionali.
 Vanno però tenute presenti due considerazioni:
\end_layout

\begin_layout Itemize
la guida è stata pensata e continua a rimanere un aiuto per la preparazione
 alle selezioni territoriali, quindi le tecniche risolutive utilizzate rimangono
 le stesse necessarie alla soluzione dei problemi delle territoriali, il
 che non garantisce in generale che le soluzioni proposte possano far guadagnare
 tutti i punti disponibili in un problema
\end_layout

\begin_layout Itemize
le soluzioni proposte sono comunque state testate su un correttore ufficiale
 e quindi viene sempre mostrato il punteggio che è possibile totalizzare
 con la soluzione illustrata.
\end_layout

\begin_layout Section
Gare di formula 7 (f7) - CoCi
\begin_inset Foot
status collapsed

\begin_layout Plain Layout
Il Coci (Croatian Open Competition in Informatics) è il sito con il quale
 la Croazia seleziona gli studenti che formeranno la loro squadra olimpica,
 ma le gare sono aperte a tutti.
 Il sito si trova all'indirizzo 
\begin_inset CommandInset href
LatexCommand href
name "http://www.hsin-hr/coci"
target "http://www.hsin-hr/coci"

\end_inset


\end_layout

\end_inset

 ottobre 2012
\end_layout

\begin_layout Standard
\begin_inset Box Framed
position "t"
hor_pos "c"
has_inner_box 0
inner_pos "t"
use_parbox 0
use_makebox 0
width "100col%"
special "none"
height "1in"
height_special "totalheight"
status collapsed

\begin_layout Subsection*
Gare di formula 7 (f7)
\end_layout

\begin_layout Subsubsection*
Difficoltà D = 2.
 
\end_layout

\begin_layout Subsubsection*
Descrizione del problema
\end_layout

\begin_layout Plain Layout
Il campionato del mondo di Formula 7 2012 è caratterizzato da corse mozzafiato
 e frequenti cambi di posizione al comando della classifica.
 Antonio ha perso la maggior parte delle gare perchè si stava allenando
 per le Olimpiadi di Informatica.
 Ora le sue uniche consolazioni sono le medaglie che ha vinto ed essere
 il protagonista di questo problema.
 Lui ha una domanda da farti in qualità di risolutore di questo problema:
 
\begin_inset Quotes eld
\end_inset

Quanti piloti che partecipano al campionato 2012 hanno ancora possibilità
 di diventare campioni del mondo 
\series bold
alla fine dell'ultima gara
\series default
?
\begin_inset Quotes erd
\end_inset

 Il campione del mondo è ovviamente il pilota con 
\series bold
il punteggio più alto
\series default
 alla fine (dopo l'ultima corsa).
\end_layout

\begin_layout Plain Layout
Ci sono 
\series bold
N
\series default
 piloti che partecipano al campionato.
 Tutti prendono dei punti alla fine di ogni gara, incluso l'ultimo arrivato.
 Al vincitore della gara vengono dati 
\series bold
N punti
\series default
, al secondo 
\series bold
N-1
\series default
 punti e così via fino all'ultimo pilota, al quale viene dato 
\series bold
1 punto
\series default
.
 Due piloti non possono finire una gara nella stessa posizione.
\end_layout

\begin_layout Plain Layout
Scrivi un programma che, dato in input il numero totale di punti che ogni
 pilota ha guadagnato prima dell'ultima gara, calcoli quanti piloti hanno
 ancora la possibilità teorica di avere il punteggio più alto dopo l'ultima
 gara e quindi di vincere il campionato.
 Se più di un pilota ha il punteggio massimo finale, diventano tutti campioni
 del mondo.
\end_layout

\begin_layout Subsubsection*
Dati di input
\end_layout

\begin_layout Plain Layout
La prima linea contiene un intero positivo 
\series bold
N
\series default
 (
\begin_inset Formula $3\leq N\leq300000)$
\end_inset

, il numero totale di piloti che partecipano al campionato.
\end_layout

\begin_layout Plain Layout
Ognuna delle successive 
\series bold
N
\series default
 linee contiene un solo intero 
\series bold
B
\begin_inset script subscript

\begin_layout Plain Layout

\series bold
i
\end_layout

\end_inset


\series default
 (
\begin_inset Formula $0\leq B_{i}\leq2000000,\: i=1,\ldots,N$
\end_inset

), il numero di punti che il pilota i-esimo ha prima dell'ultima gara.
\end_layout

\begin_layout Subsubsection*
Dati di output
\end_layout

\begin_layout Plain Layout
Un unico intero, che è il numero di piloti che possono ancora vincere il
 campionato.
\end_layout

\begin_layout Subsubsection*
Esempi di input/output 
\end_layout

\begin_layout Plain Layout
\noindent
\begin_inset Tabular
<lyxtabular version="3" rows="2" columns="2">
<features tabularvalignment="middle">
<column alignment="left" valignment="top" width="1in">
<column alignment="left" valignment="top" width="0">
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
Input
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
Output
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
3
\end_layout

\begin_layout Plain Layout
8 
\end_layout

\begin_layout Plain Layout
10 
\end_layout

\begin_layout Plain Layout
9
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
3
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\begin_inset Newline newline
\end_inset


\end_layout

\begin_layout Plain Layout
\noindent
\begin_inset Tabular
<lyxtabular version="3" rows="2" columns="2">
<features tabularvalignment="middle">
<column alignment="left" valignment="top" width="1in">
<column alignment="left" valignment="top" width="0">
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
Input
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
Output
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
5
\end_layout

\begin_layout Plain Layout
15
\end_layout

\begin_layout Plain Layout
14
\end_layout

\begin_layout Plain Layout
15
\end_layout

\begin_layout Plain Layout
12
\end_layout

\begin_layout Plain Layout
14
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
4
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Aspetti interessanti
\end_layout

\begin_layout Standard

\series bold
Parole chiave
\series default
: ordinamento, greedy.
\end_layout

\begin_layout Standard
Il problema può essere facilmente risolto con un algoritmo greedy, ma bisogna
 stare attenti perchè nella formulazione e negli esempi proposti potrebbero
 non essere subito evidenti alcuni casi che, se non gestiti correttamente,
 porterebbero alla scrittura di un programma sbagliato.
\end_layout

\begin_layout Subsection
\begin_inset CommandInset label
LatexCommand label
name "sub:Soluzione f7"

\end_inset

Soluzione
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "basicstyle={\small\ttfamily},frame=lr,language={C++},numbers=left,showstringspaces=false,tabsize=4"
inline false
status collapsed

\begin_layout Plain Layout

int punteggi[300000];
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

int main() {     
\end_layout

\begin_layout Plain Layout

	int N, quanti=0;     
\end_layout

\begin_layout Plain Layout

	cin >> N;     
\end_layout

\begin_layout Plain Layout

	for (int i=0; i<N ; i++)         
\end_layout

\begin_layout Plain Layout

		cin >> punteggi[i];     
\end_layout

\begin_layout Plain Layout

	sort(punteggi, punteggi + N);     
\end_layout

\begin_layout Plain Layout

	reverse(punteggi, punteggi+N); 
\end_layout

\begin_layout Plain Layout

	int minimo = 0;     
\end_layout

\begin_layout Plain Layout

	for (int i = 0; i < N; i++)         
\end_layout

\begin_layout Plain Layout

		if (punteggi[i] + i + 1 > minimo) 
\end_layout

\begin_layout Plain Layout

			minimo = punteggi[i] + i + 1;     
\end_layout

\begin_layout Plain Layout

	for (int i = 0; i < N; i++)         
\end_layout

\begin_layout Plain Layout

		if (punteggi[i]+N >= minimo) quanti++;     
\end_layout

\begin_layout Plain Layout

	cout << quanti << endl;     
\end_layout

\begin_layout Plain Layout

	return 0; 
\end_layout

\begin_layout Plain Layout

}	
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Un'idea che potrebbe venire da una lettura non attenta del testo e pensando
 a come funzionano le gare reali di Formula Uno potrebbe essere quella di
 verificare per ogni pilota se, sommando il punteggio che può ottenere arrivando
 primo al punteggio che ha prima dell'ultima gara, ottiene un valore superiore
 al pilota in testa al mondiale.
 Questo però funzionerebbe solo nelle gare vere, dove la maggior parte dei
 piloti non prende punti e quindi si può ipotizzare che il primo non prenda
 punti e per superarlo basti fare un numero adeguato di punti.
 
\end_layout

\begin_layout Standard
Nel problema proposto, siccome tutti i piloti prendono dei punti alla fine
 della gara, potrebbe succedere che a un pilota non basti arrivare primo
 e raggiungere un punteggio superiore a quello che era primo fino alla penultima
 gara, poichè, data una qualsiasi combinazione di arrivi alle sue spalle,
 ci potrebbe sempre essere un pilota con più punti che gli preclude la possibili
tà teorica di arrivare primo.
 Un caso del genere lo si può vedere bene nel secondo esempio, dove il pilota
 con 12 punti non ha nessuna possibilità di vincere il campionato del mondo
 anche arrivando primo all'ultima gara, poichè, data una qualsiasi combinazione
 dei piloti dietro di lui, ci sarà sempre qualcuno che farà più di 17 punti.
\end_layout

\begin_layout Standard
A questo punto per applicare il paradigma greedy bisogna far vedere che
 esiste un qualche ordinamento dei piloti che è ottimo per il problema.
 Ragionando sugli esempi e generalizzando si può notare che la configurazione
 migliore per il problema è quella in cui ogni pilota arriva nell'ordine
 inverso alla sua posizione in classifica, cioè il primo arriva ultimo,
 il secondo penultimo, e così via fino all'ultimo che arriverà primo.
 Perchè questa è la configurazione migliore possibile? Perchè per un qualsiasi
 pilota garantisce che ogni altro pilota che si trovava davanti a lui prima
 dell'utlima gara prenda un punteggio che è il minimo possibile compatibilmente
 con le regole.
 Come si può vedere dall'esempio mostrato sotto la prima configurazione,
 quella che potremmo chiamare a 
\begin_inset Quotes eld
\end_inset

minima energia
\begin_inset Quotes erd
\end_inset

, garantisce al pilota che arriva primo all'ultima gara, quello con punteggio
 13, che dietro di lui ogni pilota abbia il minimo punteggio che può avere,
 poichè qualsiasi altra combinazione di arrivi porta un qualche pilota ad
 avere un punteggio migliore e quindi a impedire la vittoria ipotetica del
 pilota con punteggio 13.
\end_layout

\begin_layout Standard
\begin_inset VSpace medskip
\end_inset


\end_layout

\begin_layout Standard
\begin_inset Tabular
<lyxtabular version="3" rows="2" columns="4">
<features tabularvalignment="middle">
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
13
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
14
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
15
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
16
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
17
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
17
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
17
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
17
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\begin_inset space \space{}
\end_inset


\begin_inset space \space{}
\end_inset


\begin_inset space \space{}
\end_inset


\begin_inset Tabular
<lyxtabular version="3" rows="2" columns="4">
<features tabularvalignment="middle">
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
13
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
15
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
14
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
16
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
17
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
18
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
16
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
17
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\begin_inset space \space{}
\end_inset


\begin_inset space \space{}
\end_inset


\begin_inset space \space{}
\end_inset


\begin_inset Tabular
<lyxtabular version="3" rows="2" columns="4">
<features tabularvalignment="middle">
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
13
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
15
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
16
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
14
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
17
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
18
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
18
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
15
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Standard
\begin_inset VSpace medskip
\end_inset


\end_layout

\begin_layout Standard
\begin_inset Tabular
<lyxtabular version="3" rows="2" columns="4">
<features tabularvalignment="middle">
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
13
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
16
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
15
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
14
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
17
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
19
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
17
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
15
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\begin_inset space \space{}
\end_inset


\begin_inset space \space{}
\end_inset


\begin_inset space \space{}
\end_inset


\begin_inset Tabular
<lyxtabular version="3" rows="2" columns="4">
<features tabularvalignment="middle">
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
13
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
16
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
14
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
15
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
17
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
19
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
16
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
16
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\begin_inset space \space{}
\end_inset


\begin_inset space \space{}
\end_inset


\begin_inset space \space{}
\end_inset


\begin_inset Tabular
<lyxtabular version="3" rows="2" columns="4">
<features tabularvalignment="middle">
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
13
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
14
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
16
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
15
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
17
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
17
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
18
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
16
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Standard
\begin_inset VSpace medskip
\end_inset


\end_layout

\begin_layout Standard
Lo stesso discorso può essere applicato a uno qualsiasi degli altri piloti,
 supponendo che lui arrivi primo, il primo arrivi al suo posto e tutti gli
 altri nella stessa configurazione già mostrata.
\end_layout

\begin_layout Standard
A questo punto la soluzione diventa veloce da implementare: come prima cosa
 si ordina il vettore dei punteggi prima dell'ultima gara (riga 8) e, sempliceme
nte per comodità, lo si inverte in modo che il primo nel vettore sia quello
 che aveva più punti prima dell'ultima gara (riga 9).
 A questo punto si trova il minimo del punteggio della classifica dopo l'ultima
 gara, classifica calcolata al volo dentro il ciclo for di riga 11 semplicemente
 aggiungendo a ogni pilota i punti relativi alla sua posizione nell'ultima
 gara tramite la somma dell'indice i, in modo che l'ordine di arrivo sia
 l'inverso della posizione in classifica prima dell'ultima gara.
 Trovato questo minimo basta contare quanti piloti, supponendo che arrivino
 primi, possano superare questo minimo (righe 14-15), perchè se non ci riescono
 vuol dire che non hanno possibilità di arrivare primi poichè, come abbia
 già detto, questa è la configurazione migliore, qualsiasi altra non farebbe
 che peggiorare le cose.
\end_layout

\begin_layout Section
\begin_inset CommandInset label
LatexCommand label
name "sec:Il-boscaiolo-Mirko"

\end_inset

Il boscaiolo Mirko (Eko) - CoCi Marzo 2012
\end_layout

\begin_layout Standard
\begin_inset Box Framed
position "t"
hor_pos "c"
has_inner_box 0
inner_pos "t"
use_parbox 0
use_makebox 0
width "100col%"
special "none"
height "1in"
height_special "totalheight"
status collapsed

\begin_layout Subsection*
Il boscaiolo Mirko (Eko)
\end_layout

\begin_layout Subsubsection*
Difficoltà D = 2.
 
\end_layout

\begin_layout Subsubsection*
Descrizione del problema
\end_layout

\begin_layout Plain Layout
Il boscaiolo Mirko ha bisogno di tagliare 
\series bold
M
\series default
 metri di legna.
 Per lui questo è un lavoro molto semplice, poichè ha una nuova macchina
 taglialegna che è in grado di abbattere foreste con l'efficienza di un
 incendio.
 Comunque a Mirko è permesso solo di tagliare una fila di alberi a una certa
 altezza.
 Questo perchè la macchina di Mirko funziona così: una volta che Mirko imposta
 un'altezza 
\series bold
H
\series default
 (in metri), la macchina aziona la sua gigantesca lama a quell'altezza e
 taglia tutti le parti degli alberi che superano l'altezza 
\series bold
H
\series default
 (naturalmente gli alberi alti 
\series bold
H
\series default
 metri o meno non vengono toccati dalla lama).
 Mirko poi raccoglie le parti che sono state tagliate.
 Per esempio, se la fila di alberi ne contiene quattro con altezze 20, 15,
 10 e 17 e Mirko imposta l'altezza della lama a 15 metri, l'altezza degli
 alberi dopo il taglio sarà rispettivamente di 15, 15, 10 e 15 e MIrko potrà
 raccogliere 5 metri tagliati dal primo albero e 2 dal quarto, per un totale
 di 7 metri.
\end_layout

\begin_layout Plain Layout
Essendo Mirko un 
\series bold
ecologista
\series default
, non vuole tagliare più metri di legna del necessario e quindi vuole impostare
 l'altezza della lama il più in alto possibile compatibilmente con le sue
 necessità.
 Aiuta Mirko a trovare l'
\series bold
altezza massima intera
\series default
 a cui impostare la lama in modo che vengano tagliati 
\series bold
almeno M
\series default
 metri di legna.
\end_layout

\begin_layout Subsubsection*
Dati di input
\end_layout

\begin_layout Plain Layout
La prima linea contiene due interi positivi separati da uno spazio, 
\series bold
N
\series default
 (il numero di alberi, 
\begin_inset Formula $1\leq N\leq1.000.000$
\end_inset

) e 
\series bold
M
\series default
 (la quantità di legna che serve a Mirko, 
\begin_inset Formula $1\leq M\leq2.000.000.000$
\end_inset

).
\end_layout

\begin_layout Plain Layout
La seconda linea di input contiene 
\series bold
N
\series default
 interi separati da spazio minori di 1.000.000.000, l'altezza di ogni albero
 (in metri).
 La somma di tutte le altezza sarà sempre maggiore di 
\series bold
M
\series default
, quindi Mirko sarà sempre in grado di ottenere la quantità di legna che
 gli serve.
\end_layout

\begin_layout Subsubsection*
Dati di output
\end_layout

\begin_layout Plain Layout
Un unico intero, che è l'altezza a cui deve essere impostata la lama.
\end_layout

\begin_layout Subsubsection*
Esempi di input/output 
\end_layout

\begin_layout Plain Layout
\begin_inset Tabular
<lyxtabular version="3" rows="2" columns="2">
<features tabularvalignment="middle">
<column alignment="left" valignment="top" width="1in">
<column alignment="left" valignment="top" width="0">
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
Input
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
Output
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
4 7
\end_layout

\begin_layout Plain Layout
20 15 10 17
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
15
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\begin_inset Newline newline
\end_inset


\begin_inset Newline newline
\end_inset


\begin_inset Tabular
<lyxtabular version="3" rows="2" columns="2">
<features tabularvalignment="middle">
<column alignment="left" valignment="top" width="1in">
<column alignment="left" valignment="top" width="0">
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
Input
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
Output
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
5 20
\end_layout

\begin_layout Plain Layout
4 42 40 26 46
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
36
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Aspetti interessanti
\end_layout

\begin_layout Standard

\series bold
Parole chiave
\series default
: forza bruta, ricerca binaria, ordinamento.
\end_layout

\begin_layout Standard
A una prima analisi superficiale risulta evidente che il problema potrebbe
 essere risolto molto facilmente utilizzando un approccio a forza bruta:
 in realtà i limiti sulle dimensioni dei dati di input dovrebbero subito
 chiarire che un tale approccio non è fattibile all'interno dei limiti di
 tempo posti dal problema.
 Uno studio più attento porta invece all'ideazione di due possibili soluzioni,
 di fatto equivalenti, che sfruttano una l'ordinamento e l'altra la ricerca
 binaria.
\end_layout

\begin_layout Subsection
Soluzione
\end_layout

\begin_layout Standard
Per completezza viene fornito il sorgente della soluzione a forza bruta,
 senza commenti: come si può vedere il codice è estremamente semplice, non
 richiede più di una decina di minuti per essere scritto, ma nella prova
 reale delle gare CoCi porta alla soluzione in tempo utile di 4 casi su
 10.
 Il perchè dovrebbe essere evidente considerando che possono esserci fino
 a 1.000.000 di alberi e l'altezza massima può essere di 1.000.000.000: l'algoritmo
 a forza bruta esegue un numero di operazioni proporzionale al numero di
 alberi moltiplicato per l'altezza massima degli alberi, che quindi può
 andare tranquillamente oltre alle possibilità del calcolatore di risolvere
 il problema nei tempi stabiliti.
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "basicstyle={\small\ttfamily},frame=lr,language={C++},numbers=left,showstringspaces=false,tabsize=4"
inline false
status collapsed

\begin_layout Plain Layout

int N, M, alberi[1000000];
\end_layout

\begin_layout Plain Layout

int legno_tagliato(int altezza) { 	
\end_layout

\begin_layout Plain Layout

	int legno = 0; 	
\end_layout

\begin_layout Plain Layout

	for (int i = 0; i < N; i++) 		
\end_layout

\begin_layout Plain Layout

		if (alberi[i] > altezza) 			
\end_layout

\begin_layout Plain Layout

			legno += alberi[i] -  altezza; 	
\end_layout

\begin_layout Plain Layout

return legno; 
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

int main() { 	
\end_layout

\begin_layout Plain Layout

	int max = 0; 	
\end_layout

\begin_layout Plain Layout

	cin >> N >> M; 	
\end_layout

\begin_layout Plain Layout

	for (int i = 0; i < N; i++){ 		
\end_layout

\begin_layout Plain Layout

		cin >> alberi[i]; 		
\end_layout

\begin_layout Plain Layout

		if (alberi[i] > max) 			
\end_layout

\begin_layout Plain Layout

			max = alberi[i]; 	
\end_layout

\begin_layout Plain Layout

	} 	
\end_layout

\begin_layout Plain Layout

	for (int i = max-1; i >= 0; i--) 		
\end_layout

\begin_layout Plain Layout

		if (legno_tagliato(i) >= M){ 			
\end_layout

\begin_layout Plain Layout

			cout << i << endl; 			
\end_layout

\begin_layout Plain Layout

			return 0; 
\end_layout

\begin_layout Plain Layout

		} 	
\end_layout

\begin_layout Plain Layout

	return 0; 
\end_layout

\begin_layout Plain Layout

} 
\end_layout

\end_inset


\end_layout

\begin_layout Standard
A questo punto si possono avere due idee altrettanto valide e semplici da
 implementare, con complessità di tipo 
\begin_inset Formula $n\log n$
\end_inset

, che quindi risulta adatta alla soluzione di questo problema.
\end_layout

\begin_layout Subsubsection*
Soluzione con ricerca binaria
\end_layout

\begin_layout Standard
Dove nella soluzione a forza bruta scorriamo tutto il range di altezza degli
 alberi, partendo dall'altezza massima e scendendo di un metro alla volta
 (vedi riga 17 dell'approccio a forza bruta), possiamo invece sfruttare
 l'idea della ricerca binaria (vedi 
\begin_inset CommandInset ref
LatexCommand ref
reference "sec:La-ricerca"

\end_inset

) per muoverci velocemente tra i vari valori, dimezzando ad ogni passaggio
 il range da esplorare, impiegando quindi solo 
\begin_inset Formula $\log_{2}N$
\end_inset

 operazioni al posto di N, con N la dimensione del range da esplorare.
 Il vantaggio è evidente: se poniamo N = 1.000.000.000, il valore peggiore
 che può capitare nei casi di test, il numero di confronti si riduce al
 massimo a circa 30.
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "basicstyle={\small\ttfamily},frame=lr,language={C++},numbers=left,showstringspaces=false,tabsize=4"
inline false
status collapsed

\begin_layout Plain Layout

int main() { 	
\end_layout

\begin_layout Plain Layout

	int max = 0; 	
\end_layout

\begin_layout Plain Layout

	cin >> N >> M; 	
\end_layout

\begin_layout Plain Layout

	for (int i = 0; i < N; i++){ 		
\end_layout

\begin_layout Plain Layout

		cin >> alberi[i]; 		
\end_layout

\begin_layout Plain Layout

		if (alberi[i] > max) 			
\end_layout

\begin_layout Plain Layout

			max = alberi[i]; 	
\end_layout

\begin_layout Plain Layout

	} 	
\end_layout

\begin_layout Plain Layout

	int inizio = 0, fine = max-1, medio; 	
\end_layout

\begin_layout Plain Layout

	long long int legno; 	
\end_layout

\begin_layout Plain Layout

	while (inizio < fine) 	{ 		
\end_layout

\begin_layout Plain Layout

		medio = (inizio + fine)/2; 		
\end_layout

\begin_layout Plain Layout

		legno = legno_tagliato(medio); 		
\end_layout

\begin_layout Plain Layout

		if ( legno == M) 		{ 			
\end_layout

\begin_layout Plain Layout

			cout << medio << endl; 			
\end_layout

\begin_layout Plain Layout

			return 0; 
\end_layout

\begin_layout Plain Layout

		} 		
\end_layout

\begin_layout Plain Layout

		if (legno > M) 			
\end_layout

\begin_layout Plain Layout

			inizio = medio + 1; 		
\end_layout

\begin_layout Plain Layout

		if (legno < M) 			
\end_layout

\begin_layout Plain Layout

			fine = medio; 	
\end_layout

\begin_layout Plain Layout

	} 	
\end_layout

\begin_layout Plain Layout

	if (legno >= M) 		
\end_layout

\begin_layout Plain Layout

		cout << medio << endl; 	
\end_layout

\begin_layout Plain Layout

	else  		
\end_layout

\begin_layout Plain Layout

		cout << medio - 1 << endl; 	
\end_layout

\begin_layout Plain Layout

	return 0; 
\end_layout

\begin_layout Plain Layout

} 
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Come si vede nel codice il cuore dell'implementazione è piuttosto semplice
 ed è contenuto nel ciclo 
\emph on
while
\emph default
 (righe 11-22): 
\end_layout

\begin_layout Itemize
si calcola il punto medio del range corrente e si valuta quanto legname
 verrebbe tagliato con la lama posta a quell'altezza (la funzione 
\emph on
legno_tagliato
\emph default
 è la stessa del codice a forza bruta e non è stata inserita per brevità)
\end_layout

\begin_layout Itemize
se siamo fortunati e coincide con quanto richiesto stamperemo il valore
 e il programma terminerà
\end_layout

\begin_layout Itemize
altrimenti verifichiamo se la quantità è maggiore o minore rispetto a quella
 richiesta: se è maggiore allora vuol dire che a quell'altezza viene tagliata
 troppa legna e quindi si ripartirà a cercare da una quota superiore (cioè
 il nuovo inizio sarà al di sopra del valore attuale), in caso contrario
 è stata tagliata una quantità di legna insufficiente e quindi si ripartirà
 da una quota più bassa (cioè la nuova fine sarà al di sotto del valore
 attuale)
\end_layout

\begin_layout Itemize
a questo punto si riparte da capo con il nuovo range, che rispetto al giro
 precedente è stato dimezzato
\end_layout

\begin_layout Standard
L'ultimo controllo fuori dal ciclo è stato aggiunto perchè ci sono dei casi
 in cui il valore medio trovato potrebbe essere di un metro troppo in alto,
 in quanto non è detto che la quantità di legname sia esattamente M: nel
 caso che il punto sia troppo in alto togliamo un metro (riga 26) e abbiamo
 la garanzia che stavolta il legno sia sufficiente (il perchè è lasciato
 come esercizio al lettore).
\end_layout

\begin_layout Subsubsection*
Soluzione con ordinamento
\end_layout

\begin_layout Standard
Una seconda soluzione che dal punto di vista computazionale è esattamente
 equivalente a quella vista sopra è quella che sfrutta l'ordinamento: ovviamente
 risulta equivalente se viene usato un algoritmo di ordinamento con complessità
 di tipo 
\begin_inset Formula $n\log n$
\end_inset

, come le funzioni di ordinamento di libreria, se invece si usasse uno degli
 algoritmi banali con complessità quadratica le prestazioni degraderebbero.
\end_layout

\begin_layout Standard
L'idea è quella di ordinare tutti gli alberi a partire dal più alto al più
 basso e sfruttare il fatto che a questo punto la quantità di legna tagliata
 può essere calcolata in tempo lineare partendo dal più alto e scendendo,
 poichè il calcolo si riduce a una somma e una moltiplicazione e deve essere
 protratto fino a quando non ho legna a sufficienza.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename ../materiali/problemi nuovi/CoCi/eko/alberi.eps
	display false
	scale 65

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:Soluzione-con-ordinamento-eko"

\end_inset

Soluzione con ordinamento
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Standard
Questo algoritmo può essere facilmente compreso osservando figura 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:Soluzione-con-ordinamento-eko"

\end_inset

: impostiamo l'altezza di taglio al livello 1, pari all'altezza dell'albero
 successivo al primo, e per calcolare la quantità di legna è sufficiente
 aggiungere la differenza tra l'altezza dell'albero e il livello 1.
 Poi si imposta la nuova altezza di taglio al livello 2, l'altezza dell'albero
 successivo, e la nuova quantità, da aggiungere a quella calcolata in precedenza
, si ottiene come prodotto della differenza tra il livello 1 e il livello
 2 moltiplicata per il numero di alberi precedenti (riga 9 del listato),
 in questo caso 2.
 Iterando questo procedimento si può calcolare la quantità di legno tagliata
 ad ogni altezza con costo lineare.
 Una ulteriore (minima) ottimizzazione si può ottenere sfruttando il fatto
 che quando ci sono alberi di uguale altezza (nell'esempio in figura 
\emph on
c
\emph default
 e 
\emph on
d
\emph default
) prima di fare il calcolo della legna mi sposto fino all'ultimo albero
 in un colpo solo (riga 8 del listato).
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "basicstyle={\small\ttfamily},frame=lr,language={C++},numbers=left,showstringspaces=false,tabsize=4"
inline false
status open

\begin_layout Plain Layout

int main() { 	
\end_layout

\begin_layout Plain Layout

	cin >> N >> M; 	
\end_layout

\begin_layout Plain Layout

	for (int i = 0; i < N; i++) 		
\end_layout

\begin_layout Plain Layout

	cin >> alberi[i]; 	
\end_layout

\begin_layout Plain Layout

	sort(alberi,alberi + N, greater<int>()); 	
\end_layout

\begin_layout Plain Layout

	int alberi_tagliati = 1, legno = 0, altezza, i; 	
\end_layout

\begin_layout Plain Layout

	for (i = 1; i < N && legno < M; i++){ 		
\end_layout

\begin_layout Plain Layout

		while (alberi[i-1] == alberi[i]) i++; 		
\end_layout

\begin_layout Plain Layout

		legno += i * (alberi[i-1] - alberi[i]); 		
\end_layout

\begin_layout Plain Layout

	} 	
\end_layout

\begin_layout Plain Layout

	cout << alberi[i] + (legno - M)/i << endl; 	
\end_layout

\begin_layout Plain Layout

	return 0; 
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
All'uscita del ciclo (righe 7-10) avrò quindi un'altezza di taglio che è
 determinata dall'altezza dell'albero a cui mi sono fermato a tagliare,
 che garantisce che la legna tagliata sarà in quantità sicuramente maggiore
 o uguale a M: per fornire la risposta corretta dovrò eventualmente aggiungere
 una quantità che mi permetta di raggiungere un risultato migliore, cosa
 che posso facilmente ottenere dividendo la quantità di legna eccedente
 per il numero di alberi tagliati (riga 11).
\end_layout

\begin_layout Standard
Va infine fatto notare che dovendo ordinare gli alberi per altezza dal più
 grande al più piccolo è stata usata la funzione 
\emph on
sort
\emph default
 passando come ultimo parametro un 
\emph on
oggetto funzione
\emph default
 o 
\emph on
funtore
\emph default
 che altro non è che una specie di puntatore a funzione che poi l'algoritmo
 di ordinamento userà per fare i confronti: in questo modo il funtore 
\series bold
greater
\series default
 verrà usato dall'algoritmo di ordinamento per confrontare due elementi
 e verranno eventualmente scambiati in modo tale che alla fine il vettore
 sarà ordinato al contrario.
 Una soluzione alternativa era quella usata nell'esercizio 
\begin_inset CommandInset ref
LatexCommand ref
reference "sub:Soluzione f7"

\end_inset

, in cui veniva ordinato un vettore in modo standard (dal più piccolo al
 più grande) e poi veniva applicato il metodo 
\series bold
reverse
\series default
.
\end_layout

\begin_layout Section
Sostituzioni (sostituzioni) - ABC Bergamo 2013
\end_layout

\begin_layout Standard
\begin_inset Box Framed
position "t"
hor_pos "c"
has_inner_box 0
inner_pos "t"
use_parbox 0
use_makebox 0
width "100col%"
special "none"
height "1in"
height_special "totalheight"
status collapsed

\begin_layout Subsection*
Sostituzioni (sostituzioni)
\end_layout

\begin_layout Subsubsection*
Descrizione del problema
\end_layout

\begin_layout Plain Layout
Il professor Tarboto, appassionato di numeri, ha inventato un nuovo gioco
 per i suoi studenti.
 A partire da un numero M e da una sequenza di numeri interi positivi assegnati
 A
\begin_inset script subscript

\begin_layout Plain Layout
1
\end_layout

\end_inset

, A
\begin_inset script subscript

\begin_layout Plain Layout
2
\end_layout

\end_inset

, …, A
\begin_inset script subscript

\begin_layout Plain Layout
n
\end_layout

\end_inset

 bisogna sostituirne alcuni in modo che la somma dei quadrati di tutti i
 numeri risulti esattamente M.
 Il gioco prevede un costo per ogni sostituzione di un numero assegnato
 con un altro.
 L’obiettivo è trovare l’insieme di sostituzioni con costo minimo.
 Il costo della sostituzione del numero A
\begin_inset script subscript

\begin_layout Plain Layout
i
\end_layout

\end_inset

 con il numero B
\begin_inset script subscript

\begin_layout Plain Layout
i
\end_layout

\end_inset

 è pari a (A
\begin_inset script subscript

\begin_layout Plain Layout
i
\end_layout

\end_inset

-B
\begin_inset script subscript

\begin_layout Plain Layout
i
\end_layout

\end_inset

)*( A
\begin_inset script subscript

\begin_layout Plain Layout
i
\end_layout

\end_inset

-B
\begin_inset script subscript

\begin_layout Plain Layout
i
\end_layout

\end_inset

).
 Ogni numero della sequenza iniziale può essere sostituito una volta sola.
 Ad esempio è possibile sostituire un 3 con un 1 (costo 4) mentre non è
 possibile sostituire un 3 prima con un 2 e poi con un 1 (costo complessivo
 1+1=2).
\end_layout

\begin_layout Plain Layout
Determinare il costo minimo necessario per effettuare sostituzioni in modo
 che la somma dei quadrati di tutti i numeri della sequenza risulti M.
 Nel caso non fosse possibile ottenere M in alcun modo il risultato è -1.
\end_layout

\begin_layout Subsubsection*
Dati di input
\end_layout

\begin_layout Plain Layout
La prima linea contiene due interi positivi N (1<= N <=10) e M (1<= M <=10000).
 Le successive N linee contengono ognuna un intero positivo appartenente
 alla sequenza A
\begin_inset script subscript

\begin_layout Plain Layout
1
\end_layout

\end_inset

, …, A
\begin_inset script subscript

\begin_layout Plain Layout
N
\end_layout

\end_inset

 (1<= A
\begin_inset script subscript

\begin_layout Plain Layout
i
\end_layout

\end_inset

 <=100).
 Ogni numero A
\begin_inset script subscript

\begin_layout Plain Layout
i
\end_layout

\end_inset

 può essere sostituito una volta con un numero B
\begin_inset script subscript

\begin_layout Plain Layout
i
\end_layout

\end_inset

 (1<= B
\begin_inset script subscript

\begin_layout Plain Layout
i
\end_layout

\end_inset

 <=100).
\end_layout

\begin_layout Subsubsection*
Dati di output
\end_layout

\begin_layout Plain Layout
La prima e unica linea deve contenere il costo minimo per sostituire abbastanza
 numeri per ottenere M, o -1 se non esiste soluzione.
\end_layout

\begin_layout Subsubsection*
Assunzioni
\end_layout

\begin_layout Itemize
L’esecuzione non deve richiedere più di 1 secondo e 32 MB di RAM.
 In 5 casi input su 12, viene garantito che M < 100.
\end_layout

\begin_layout Subsubsection*
Esempi di input/output 
\end_layout

\begin_layout Plain Layout
\noindent
\begin_inset Tabular
<lyxtabular version="3" rows="2" columns="2">
<features tabularvalignment="middle">
<column alignment="left" valignment="top" width="1.5in">
<column alignment="left" valignment="top" width="1in">
<row>
<cell alignment="left" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
Input
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
Output
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
3 6
\end_layout

\begin_layout Plain Layout
3
\end_layout

\begin_layout Plain Layout
3
\end_layout

\begin_layout Plain Layout
1
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
5
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Subsubsection*
\noindent
Spiegazione dell'esempio
\end_layout

\begin_layout Plain Layout
Sostituire un 3 con il valore 2 (costo 1) e l’altro 3 con il valore 1 (costo
 4).
 La somma dei quadrati è 4+1+1=6 come richiesto e il costo è 5.
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Aspetti interessanti
\end_layout

\begin_layout Standard

\series bold
Parole chiave
\series default
: ricorsione, ricorsione con memoizzazione, programmazione dinamica top-down
 e bottom-up..
\end_layout

\begin_layout Standard
Questo problema è relativamente facile da risolvere usando opportunamente
 la ricorsione, ma in questo modo non è possibile raccogliere tutti i punti
 a disposizione, ma solo una parte di essi.
 Vengono quindi proposte due versioni migliorate, che sfruttando il paradigma
 della programmazione dinamica, risolvono correttamente il problema nei
 casi di test.
\end_layout

\begin_layout Subsection
Soluzione ricorsiva semplice
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "basicstyle={\small\ttfamily},frame=lr,language={C++},numbers=left,showstringspaces=false,tabsize=4"
inline false
status collapsed

\begin_layout Plain Layout

#define INT_MAX 1000000000 
\end_layout

\begin_layout Plain Layout

int a[100]; 
\end_layout

\begin_layout Plain Layout

int N, M;
\end_layout

\begin_layout Plain Layout

int costo(int m, int e) { 	
\end_layout

\begin_layout Plain Layout

	if (m == M && e == N) 		
\end_layout

\begin_layout Plain Layout

		return 0; 	
\end_layout

\begin_layout Plain Layout

	if (e == N) 		
\end_layout

\begin_layout Plain Layout

		return INT_MAX; 	
\end_layout

\begin_layout Plain Layout

	int min = INT_MAX; 	
\end_layout

\begin_layout Plain Layout

	int i = -a[e]; 	
\end_layout

\begin_layout Plain Layout

	for(;m + (a[e] + i)*(a[e] + i) <= M;i++) {
\end_layout

\begin_layout Plain Layout

		int ci = costo(m + (a[e] + i)*(a[e] + i), e + 1) + i*i; 		
\end_layout

\begin_layout Plain Layout

		if ( ci < min) 			
\end_layout

\begin_layout Plain Layout

			min = ci; 
\end_layout

\begin_layout Plain Layout

	} 	
\end_layout

\begin_layout Plain Layout

	return min; 
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

int main(int argc, char** argv) { 	
\end_layout

\begin_layout Plain Layout

	ifstream in("input.txt"); 	
\end_layout

\begin_layout Plain Layout

	ofstream out("output.txt"); 	
\end_layout

\begin_layout Plain Layout

	in >> N >> M; 	
\end_layout

\begin_layout Plain Layout

	for (int i = 0; i < N; i++) 		
\end_layout

\begin_layout Plain Layout

		in >> a[i]; 	
\end_layout

\begin_layout Plain Layout

	int c = costo (0,0) ; 	
\end_layout

\begin_layout Plain Layout

	if (c == INT_MAX)  		
\end_layout

\begin_layout Plain Layout

		out << -1 << endl; 	
\end_layout

\begin_layout Plain Layout

	else 		
\end_layout

\begin_layout Plain Layout

		out << c << endl; 	
\end_layout

\begin_layout Plain Layout

	return 0; 
\end_layout

\begin_layout Plain Layout

}	
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Soluzione ricorsiva con memoizzazione (o programmazione dinamica top-down)
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "basicstyle={\small\ttfamily},frame=lr,language={C++},numbers=left,showstringspaces=false,tabsize=4"
inline false
status open

\begin_layout Plain Layout

int tab[10000][11];
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

int costo(int m, int e) { 	
\end_layout

\begin_layout Plain Layout

	if (m == M && e == N) 		
\end_layout

\begin_layout Plain Layout

		return 0; 	
\end_layout

\begin_layout Plain Layout

	if (e == N) 		
\end_layout

\begin_layout Plain Layout

		return INT_MAX; 	
\end_layout

\begin_layout Plain Layout

	int min = INT_MAX; 	
\end_layout

\begin_layout Plain Layout

	int i = -a[e]; 	
\end_layout

\begin_layout Plain Layout

	for(;m + (a[e] + i)*(a[e] + i) <= M;i++) { 		
\end_layout

\begin_layout Plain Layout

		int ci; 		
\end_layout

\begin_layout Plain Layout

		if (tab[m][e] != -1) 			
\end_layout

\begin_layout Plain Layout

			ci = tab[m][e]; 		
\end_layout

\begin_layout Plain Layout

		else 			
\end_layout

\begin_layout Plain Layout

			ci = costo(m + (a[e] + i)*(a[e] + i), e + 1) + i*i; 		
\end_layout

\begin_layout Plain Layout

		if ( ci < min) 			
\end_layout

\begin_layout Plain Layout

			min = ci; 	
\end_layout

\begin_layout Plain Layout

	} 	
\end_layout

\begin_layout Plain Layout

	tab[m][e] = min; 	
\end_layout

\begin_layout Plain Layout

	return min; 
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Soluzione con programmazione dinamica bottom-up
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "basicstyle={\small\ttfamily},frame=lr,language={C++},numbers=left,showstringspaces=false,tabsize=4"
inline false
status open

\begin_layout Plain Layout

int tab[11][10001];
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

int main(int argc, char** argv) { 	
\end_layout

\begin_layout Plain Layout

	ifstream in("input.txt"); 	
\end_layout

\begin_layout Plain Layout

	ofstream out("output.txt"); 	
\end_layout

\begin_layout Plain Layout

	in >> N >> M; 	
\end_layout

\begin_layout Plain Layout

	for (int i = 1; i <= N; i++) 		
\end_layout

\begin_layout Plain Layout

		in >> a[i]; 	
\end_layout

\begin_layout Plain Layout

	for (int i = 0 ; i <11;i ++) 		
\end_layout

\begin_layout Plain Layout

		for (int j = 0 ; j <10001;j ++) 			
\end_layout

\begin_layout Plain Layout

			tab[i][j] = -1; 	
\end_layout

\begin_layout Plain Layout

	tab[0][0] = 0; 	
\end_layout

\begin_layout Plain Layout

	int i,j,k; 	
\end_layout

\begin_layout Plain Layout

	for (i = 1; i<=N; i++) 		
\end_layout

\begin_layout Plain Layout

		for (j=0; j<=M; j++) { 			
\end_layout

\begin_layout Plain Layout

			if (tab[i-1][j]!=-1) { 				
\end_layout

\begin_layout Plain Layout

				k = -a[i]; 				
\end_layout

\begin_layout Plain Layout

				for (;j + (a[i] + k)*(a[i] + k) <= M;k++){
\end_layout

\begin_layout Plain Layout

					int b = a[i]+k; 					
\end_layout

\begin_layout Plain Layout

					if(tab[i-1][j] + k*k < tab[i][j + b*b)]
\end_layout

\begin_layout Plain Layout

						|| tab[i][j + b*b] == -1)
\end_layout

\begin_layout Plain Layout

						tab[i][j + b*b)] = tab[i-1][j] + k*k;
\end_layout

\begin_layout Plain Layout

				}			
\end_layout

\begin_layout Plain Layout

			} 		
\end_layout

\begin_layout Plain Layout

		} 	
\end_layout

\begin_layout Plain Layout

	out << tab[N][M] << endl; 	
\end_layout

\begin_layout Plain Layout

	return 0; 
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Section
Per un pugno di baht (baht) - Nazionali 2010
\end_layout

\begin_layout Standard
\begin_inset Box Framed
position "t"
hor_pos "c"
has_inner_box 0
inner_pos "t"
use_parbox 0
use_makebox 0
width "100col%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout Subsection*
Per un pugno di baht (baht)
\end_layout

\begin_layout Subsubsection*
Descrizione del problema
\end_layout

\begin_layout Plain Layout
L'incredibile Hulk si trova in Tailandia e purtroppo ha un carattere irascibile:
 ha rotto diverse macchine automatiche per distribuire le merendine perché
 non erano in grado di fornirgli il resto.
 Per prevenire l'ira di Hulk in tali situazioni, la ditta costruttrice ha
 deciso di predisporre un sistema centrale che sia in grado di calcolare,
 per ciascuna di tali macchine, il minimo resto che la macchina stessa non
 è in grado di fornire.
\end_layout

\begin_layout Plain Layout
Le monete tailandesi (i baht) che sono presenti nelle macchine possono essere
 di qualsiasi taglia (1 baht, 2 baht, 3 baht, ecc.) e quantità.
 Possono essere combinate in qualsiasi modo: ad esempio, il resto di 5 baht
 non può essere dato se la macchina contiene una moneta da 1 baht e due
 monete da 3 baht (in questo caso il più piccolo resto che non può essere
 dato è 2).
 Con sei monete da 1 baht e due monete da 2 baht, è invece possibile fornire
 il resto di 5 baht in vari modi (in questo caso il resto più piccolo resto
 che non può essere dato è 11).
\end_layout

\begin_layout Plain Layout
Il tuo compito è di aiutare la ditta a calcolare, per un certo numero di
 macchine, qual è il minimo resto che ciascuna macchina 
\series bold
non
\series default
 è in grado di fornire.
 
\end_layout

\begin_layout Subsubsection*
Dati di input
\end_layout

\begin_layout Plain Layout
Il file input.txt è composto da 2P+1 righe, dove P è il numero di macchine
 su cui valutare il resto.
 Per ogni macchina, la ditta presenta la corrispondente sequenza di monete
 e chiede il minimo resto che la macchina non è in grado di fornire.
\end_layout

\begin_layout Plain Layout
Sulla prima riga si trova P, il numero di macchine.
 Le rimanenti righe sono così composte.
 Per 1 ≤ i ≤ P, le righe 2i e 2i+1 contengono le informazioni per la i-esima
 macchina distributrice: la riga 2i contiene N
\begin_inset script subscript

\begin_layout Plain Layout
i
\end_layout

\end_inset

, il numero di monete presenti nella macchina; la riga successiva (2i+1),
 contiene la sequenza di valori M
\begin_inset script subscript

\begin_layout Plain Layout
1
\end_layout

\end_inset

,M
\begin_inset script subscript

\begin_layout Plain Layout
2
\end_layout

\end_inset

,…,M
\begin_inset script subscript

\begin_layout Plain Layout
N
\begin_inset script subscript

\begin_layout Plain Layout
i
\end_layout

\end_inset


\end_layout

\end_inset

 delle monete presenti nella macchina, separati l'un l'altro da uno spazio.
 I valori delle monete sono interi positivi.
\end_layout

\begin_layout Plain Layout
Per esempio, se la seconda riga del file contiene il numero 7 e la terza
 riga i numeri 10 2 14 1 13 2 3, questo significa che nella prima macchina
 sono presenti 7 monete.
 Siccome le monete vanno inserite una alla volta, risulta una moneta da
 10 bath, poi una da 2 bath, poi una da 14 baht, una da 1 bath, una da 13
 bath, ancora una da 2 bath e, infine, una da 3 bath.
 In tal caso, il minimo resto che la macchina non riesce a restituire è
 di 9 baht.
 
\end_layout

\begin_layout Subsubsection*
Dati di output
\end_layout

\begin_layout Plain Layout
Il file output.txt è composto da P righe.
 Sulla i-esima riga (con 1 ≤ i ≤ P) si deve trovare il minimo resto che
 la i-esima macchina non può fornire.
 
\end_layout

\begin_layout Subsection*
Assunzioni
\end_layout

\begin_layout Itemize
1 ≤ P ≤ 1000 
\end_layout

\begin_layout Itemize
1 ≤ N
\begin_inset script subscript

\begin_layout Plain Layout
i
\end_layout

\end_inset

 ≤ 10 000 per ogni i 
\end_layout

\begin_layout Itemize
1 ≤ M
\begin_inset script subscript

\begin_layout Plain Layout
j
\end_layout

\end_inset

 < 2
\begin_inset script superscript

\begin_layout Plain Layout
20
\end_layout

\end_inset

 per ogni j 
\end_layout

\begin_layout Itemize
Per ciascuna macchina, la somma delle monete nella rispettiva sequenza è
 sempre inferiore a 2
\begin_inset script superscript

\begin_layout Plain Layout
31
\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection*
Esempi di input/output 
\end_layout

\begin_layout Plain Layout
\noindent
\begin_inset Tabular
<lyxtabular version="3" rows="2" columns="2">
<features tabularvalignment="middle">
<column alignment="left" valignment="top" width="1.5in">
<column alignment="left" valignment="top" width="1in">
<row>
<cell alignment="left" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
Input
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
Output
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
2 
\end_layout

\begin_layout Plain Layout
7 
\end_layout

\begin_layout Plain Layout
10 2 14 1 13 2 3 
\end_layout

\begin_layout Plain Layout
9 
\end_layout

\begin_layout Plain Layout
1 16 2 1 23 18 1 4 3 
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
9 
\end_layout

\begin_layout Plain Layout
13
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\begin_inset Newline newline
\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Aspetti interessanti
\end_layout

\begin_layout Standard

\series bold
Parole chiave
\series default
: ordinamento, greedy.
\end_layout

\begin_layout Standard
Non è immediatamente chiaro quale sia la tecnica da adottare per questo
 tipo di problema, in quanto potrebbe sembrare un problema da risolvere
 con la programmazione dinamica, poichè assomiglia al problema di 
\begin_inset Quotes eld
\end_inset

Lino il giornalaio
\begin_inset Quotes erd
\end_inset

 (vedi 
\begin_inset CommandInset ref
LatexCommand ref
reference "sec:Esempio:-Lino"

\end_inset

).
 Facendo però qualche prova su carta si può velocemente notare che se si
 mettono in ordine le monete dalla più piccola alla più grande è immediato
 verificare in quale situazione non si riesce a dare il resto.
\end_layout

\begin_layout Subsection
Soluzione
\end_layout

\begin_layout Standard
Per mostrare subito come si arrivi alla soluzione del problema può essere
 utile guardare la figura , dove vengono mostrati due esempi con insiemi
 di monete già ordinati.
 In ogni esempio viene indicato l'insieme M dei valori delle monete contenute
 nel distributore e ogni riga rappresenta l'insieme dei resti possibili
 che possono essere dati aggiungendo una nuova moneta, dove la X nella casella
 indica appunto se il resto può essere dato (se ad esempio ci sono delle
 X nelle caselle di posizione 1, 2, 3 allora possono essere dati quei tre
 resti).
 Come vengono inserite le X nelle righe? 
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement h
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename ../materiali/problemi nuovi/nazionali/baht/baht.eps
	display false
	scale 60

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:Soluzione-baht"

\end_inset

Soluzione grafica del problema
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Il primo passo è notare che vale la seguente osservazione: se posso dare
 tutti i resti da 1 a R, allora aggiungendo una moneta di valore V potrò
 dare tutti i resti da 1+V a R+V.
 Nonostante l'osservazione possa sembrare banale, se i valori delle monete
 sono ordinati dal più piccolo al più grande, mi permette di trovare facilmente
 il primo 
\begin_inset Quotes eld
\end_inset

buco
\begin_inset Quotes erd
\end_inset

 libero dove non posso dare un resto.
\end_layout

\begin_layout Standard
Guardando l'esempio 1, dove le monete sono di valore 1, 2, 2, 4 si può vedere
 che se usiamo solo la moneta 1 possiamo dare un resto di 1 (ovviamente
 anche di zero, anche se non appare in figura 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:Soluzione-con-ordinamento-eko"

\end_inset

), se aggiungiamo, nella seconda riga, una moneta di valore 2, possiamo
 ottenere anche i resti 2 e 3, se aggiungiamo l'altra moneta di valore 2
 otteniamo anche i resti 4 e 5 e se infine raggiungiamo la moneta di valore
 4 otteniamo i resti 6, 7, 8, 9.
 Quindi in questo esempio possiamo dare tutti i resti da 0 a 9 e quindi
 il primo resto che non può essere dato è quello di valore 10, ovviamente
 poichè nessuna macchina potrà mai dare un resto superiore alla somma dei
 valori delle monete che contiene.
 Il secondo esempio è più interessante, poichè si vede che nel passaggio
 dalla seconda alla terza riga si crea un 
\begin_inset Quotes eld
\end_inset

buco
\begin_inset Quotes erd
\end_inset

, che indica che il resto di valore 3 non può essere dato.
 Da questo esempio dovrebbe essere chiaro come ricavare una regola generale
 che ci permetta di stabilire qual è il più piccolo resto che non può essere
 dato con una certa configurazione di monete: supponiamo sia possibile dare
 tutti i resti usando solo le prime N monete (ordinate dalla più piccola
 alla più grande) e sia S la somma dei valori di queste monete, allora posso
 continuare a dare resti 
\begin_inset Quotes eld
\end_inset

senza buchi
\begin_inset Quotes erd
\end_inset

 se e solo se la nuova moneta aggiunta ha un valore al massimo pari a S+1.
 Se il valore è superiore, allora non sarà possibile dare il resto di valore
 S+1, che quindi sarà il più piccolo resto che il distributore non riesce
 a dare.
\end_layout

\begin_layout Standard
Compreso ciò il codice risulta estremamente semplice da scrivere.
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "basicstyle={\small\ttfamily},frame=lr,language={C++},numbers=left,showstringspaces=false,tabsize=4"
inline false
status collapsed

\begin_layout Plain Layout

int P, N, monete[10000];
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

int main() { 	
\end_layout

\begin_layout Plain Layout

	ifstream in("input.txt"); 	
\end_layout

\begin_layout Plain Layout

	ofstream out("output.txt"); 	
\end_layout

\begin_layout Plain Layout

	in >> P; 	
\end_layout

\begin_layout Plain Layout

	for (int i = 0; i < P; i++) {	 		
\end_layout

\begin_layout Plain Layout

		in >> N; 		
\end_layout

\begin_layout Plain Layout

		int j; 		
\end_layout

\begin_layout Plain Layout

		for (j = 0; j < N; j++) 			
\end_layout

\begin_layout Plain Layout

			in >> monete[j]; 		
\end_layout

\begin_layout Plain Layout

		sort (monete, monete + j);	 		
\end_layout

\begin_layout Plain Layout

		int quante = j; 		
\end_layout

\begin_layout Plain Layout

		int somma = 0; 		
\end_layout

\begin_layout Plain Layout

		for (int j = 0; j < quante; j++) 			
\end_layout

\begin_layout Plain Layout

			if (monete[j] <= somma + 1) 				
\end_layout

\begin_layout Plain Layout

				somma += monete[j]; 			
\end_layout

\begin_layout Plain Layout

			else 				
\end_layout

\begin_layout Plain Layout

				break; 		 		
\end_layout

\begin_layout Plain Layout

		out << somma + 1 << endl; 	
\end_layout

\begin_layout Plain Layout

	} 	
\end_layout

\begin_layout Plain Layout

	return 0; 
\end_layout

\begin_layout Plain Layout

}	
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Il codice che implementa quanto spiegato si trova tra la riga 8 e la riga
 20 e viene poi ripetuto P volte per ognuno dei P distributori descritti
 in input.
 Dopo aver letto i valori delle monete all'interno del vettore monete (righe
 10-11) e averlo ordinato (riga 12), le righe da 15 a 19 sommano di volta
 in volta una nuova moneta, fino a quando non si trova un valore di una
 moneta che sia superiore alla somma delle precedenti monete più uno, che
 è il valore cercato.
\end_layout

\begin_layout Section
Fulcro del gioco (fulcro) - GATOR 2014
\begin_inset Foot
status collapsed

\begin_layout Plain Layout
Questa gara è stata tenuta per la prima volta a marzo 2014 come allenamento
 per le territoriali in modalità online ed è stata organizzata dal Dipartimento
 di Informatica dell'Università di Roma Tor Vergata.
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Box Framed
position "t"
hor_pos "c"
has_inner_box 0
inner_pos "t"
use_parbox 0
use_makebox 0
width "100col%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout Subsection*
Fulcro del gioco (fulcro)
\end_layout

\begin_layout Subsubsection*
Descrizione del problema
\end_layout

\begin_layout Plain Layout
Una partita di calcio può essere analizzata (anche) in funzione della rete
 di passaggi che vengono effettuati tra i giocatori.
 Per esempio, qui sotto vediamo l’analisi della finale dei mondiali 2006:
 il verso delle frecce rappresenta la direzione dei passaggi, e la dimensione
 delle frecce è proporzionale al numero di passaggi tra due giocatori.
 
\end_layout

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename /home/xubuntu/Desktop/guida/materiali/problemi nuovi/gator/fulcrodelgioco/worldcup2006bn.png
	display false
	scale 40

\end_inset


\end_layout

\begin_layout Plain Layout
Prandelli, il CT della nazionale italiana, sta studiando il modo di pressare
 i giocatori avversari quando la palla è in possesso del portiere (avversario).
 Come dati a disposizione abbiamo lo schema dei passaggi tra i giocatori,
 e siamo interessati a capire quale sia il giocatore da marcare per impedire
 al maggior numero di giocatori di ricevere il pallone.
 Ad esempio, nella figura qui sotto, si vede che se si impedisce al 10 di
 prendere palla, non ci sono modi di farla arrivare al numero 8, al 9 e
 all’11.
 Possiamo pensare alla marcatura come la rimozione del giocatore dal campo:
 noi siamo interessati a capire chi sia il giocatore avversario che, se
 rimosso (mediante marcatura) danneggi maggiormente la squadra avversaria,
 come numero di giocatori che non riescono ad essere raggiunti dal pallone!
 
\end_layout

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename ../materiali/problemi nuovi/gator/fulcrodelgioco/fontedigiocobn.png
	display false
	scale 50

\end_inset


\end_layout

\begin_layout Plain Layout
Il vostro compito è quello di scrivere un programma che aiuti Prandelli
 a determinare quale giocatore avversario sia il fulcro del gioco.
 Ad esempio, nello schema qui sopra (ricordandosi che non si può rimuovere
 il portiere): 
\end_layout

\begin_layout Itemize
rimuovendo il numero 2 il numero 7 non è più raggiungibile;
\end_layout

\begin_layout Itemize
rimuovendo un solo giocatore qualsiasi, scelto tra i numeri 3, 4, 5, 6,
 7, 8, 9, 11 non ci sono conseguenze;
\end_layout

\begin_layout Itemize
rimuovendo il numero 10 i numeri 8, 9 e 11 non sono più raggiungibili.
 
\end_layout

\begin_layout Subsubsection*
Dati di input
\end_layout

\begin_layout Plain Layout
Come detto in precedenza, nel file input.txt M + 1 righe di testo: la prima
 riga contiene M, il numero di linee di passaggio (ovvero le frecce nella
 figura!) tra i giocatori.
 Le successive M linee contengono due interi A e B, a denotare che il giocatore
 A passa la palla al giocatore B.
 
\end_layout

\begin_layout Subsubsection*
Dati di output
\end_layout

\begin_layout Plain Layout
Nel file 
\emph on
output.txt
\emph default
 dovrai stampare un solo intero: il numero del fulcro del gioco della squadra
 avversaria.
 Se ci sono due o più giocatori ugualmente importanti (ovvero tali che rimuovend
oli non è raggiungibile lo stesso numero di giocatori) restituire quello
 con il numero di maglia più piccolo.
 
\end_layout

\begin_layout Subsection*
Assunzioni
\end_layout

\begin_layout Itemize
1 ≤ A,B ≤ 11
\end_layout

\begin_layout Subsubsection*
Esempi di input/output 
\end_layout

\begin_layout Plain Layout
\noindent
\begin_inset Tabular
<lyxtabular version="3" rows="2" columns="2">
<features tabularvalignment="middle">
<column alignment="left" valignment="top" width="1.5in">
<column alignment="left" valignment="top" width="1in">
<row>
<cell alignment="left" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
Input
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
Output
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
21 
\end_layout

\begin_layout Plain Layout
1 2 
\end_layout

\begin_layout Plain Layout
1 5 
\end_layout

\begin_layout Plain Layout
1 3 
\end_layout

\begin_layout Plain Layout
3 5 
\end_layout

\begin_layout Plain Layout
5 4 
\end_layout

\begin_layout Plain Layout
4 2 
\end_layout

\begin_layout Plain Layout
2 4 
\end_layout

\begin_layout Plain Layout
4 6 
\end_layout

\begin_layout Plain Layout
5 6 
\end_layout

\begin_layout Plain Layout
6 3 
\end_layout

\begin_layout Plain Layout
2 7 
\end_layout

\begin_layout Plain Layout
7 6 
\end_layout

\begin_layout Plain Layout
6 10 
\end_layout

\begin_layout Plain Layout
8 6 
\end_layout

\begin_layout Plain Layout
8 10 
\end_layout

\begin_layout Plain Layout
7 10 
\end_layout

\begin_layout Plain Layout
10 8 
\end_layout

\begin_layout Plain Layout
10 9 
\end_layout

\begin_layout Plain Layout
10 11 
\end_layout

\begin_layout Plain Layout
9 11 
\end_layout

\begin_layout Plain Layout
11 9 
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
10
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\begin_inset Newline newline
\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Aspetti interessanti
\end_layout

\begin_layout Standard

\series bold
Parole chiave
\series default
: grafi, visita.
\end_layout

\begin_layout Standard
Un altro esempio di come la conoscenza di semplici algoritmi sui grafi,
 in questo caso una semplice visita, permetta agevolmente di risolvere un
 problema.
 Che in questo problema l'approccio più semplice sia quello di modellarlo
 con un grafo appare chiaro fin da subito per via delle figure presenti
 nel testo, come poi usare una visita per risolverlo richiede solo di applicare
 qualche semplice considerazione .
\end_layout

\begin_layout Subsection
Soluzione
\end_layout

\begin_layout Standard
In questo problema ci si trova di fronte a un grafo orientato, in cui, come
 è già stato detto altre volte, gli archi sono orientati e quindi potrebbe
 esserci un arco che va da A verso B ma non un arco che va da B verso A.
 Per quanto riguarda la visita ciò non è importante, perchè quando il grafo
 verrà 
\begin_inset Quotes eld
\end_inset

mappato
\begin_inset Quotes erd
\end_inset

 in una struttura dati in memoria gli archi saranno naturalmente orientati.
 Come può una visita aiutarci a risolvere il problema? Come visto nel paragrafo
 
\begin_inset CommandInset ref
LatexCommand ref
reference "sec:visite"

\end_inset

, una visita permette di passare attraverso tutti i nodi senza mai ripassare
 due volte in un nodo già visitato.
 Questo vale per un grafo connesso, perchè se il grafo non è connesso allora
 partendo da alcuni nodi la visita non ci permetterà mai di raggiungere
 alcuni altri nodi, che detto in modo più preciso vuol dire che esiste almeno
 una coppia di nodi che non hanno un percorso che li unisce.
 Perchè è importante fare questa osservazione? Perchè in questo caso la
 nostra domanda di quale è il giocatore più importante può essere riscritta
 in questo modo: data una visita che usa come nodo di partenza il nodo etichetta
to con 1 (richiesta del problema), se eliminiamo un nodo questo ci rende
 il grafo non connesso? E se sì quanti sono i nodi che risultano non più
 raggiungibili? In questo modo abbiamo ridotto il problema a una visita,
 in profondità o in ampiezza è indifferente, di un grafo a cui eliminiamo
 un nodo.
 Basta poi ripetere la visita per ognuno dei nodi che eliminiamo e vedere
 qual è quello che 
\begin_inset Quotes eld
\end_inset

stacca
\begin_inset Quotes erd
\end_inset

 più nodi dal resto del grafo.
 Un'ultima osservazione: è necessario eliminare il nodo nel senso di togliere
 tutti gli archi che lo collegano al grafo? No, nella visita basterà indicare
 quel nodo come già visitato prima di partire con la visita e questo farà
 in modo che non possa essere più visitato, cosa di fatto equivalente all'elimin
azione, ma molto più semplice da implementare.
 
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "basicstyle={\small\ttfamily},frame=lr,language={C++},numbers=left,showstringspaces=false,tabsize=4"
inline false
status open

\begin_layout Plain Layout

int M;
\end_layout

\begin_layout Plain Layout

struct giocatore{ 	
\end_layout

\begin_layout Plain Layout

	list <int> passaggi; 
\end_layout

\begin_layout Plain Layout

};
\end_layout

\begin_layout Plain Layout

giocatore giocatori[12];
\end_layout

\begin_layout Plain Layout

bool visitato[12];
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

int visita(int n) { 	
\end_layout

\begin_layout Plain Layout

	int contatore = 0; 	
\end_layout

\begin_layout Plain Layout

	fill(visitato, visitato + 12,false); 	
\end_layout

\begin_layout Plain Layout

	visitato[n] = true; 
\end_layout

\begin_layout Plain Layout

	stack <int> pila; 	
\end_layout

\begin_layout Plain Layout

	pila.push(1); 
\end_layout

\begin_layout Plain Layout

	while(!pila.empty()){ 		
\end_layout

\begin_layout Plain Layout

		int corrente = pila.top(); 		
\end_layout

\begin_layout Plain Layout

		pila.pop(); 		
\end_layout

\begin_layout Plain Layout

		if (visitato[corrente] == false){ 			
\end_layout

\begin_layout Plain Layout

			visitato[corrente] = true; 			
\end_layout

\begin_layout Plain Layout

			list <int>::iterator i; 			
\end_layout

\begin_layout Plain Layout

			for (i = giocatori[corrente].passaggi.begin();
\end_layout

\begin_layout Plain Layout

						i!=giocatori[corrente].passaggi.end();
\end_layout

\begin_layout Plain Layout

				++i) 				
\end_layout

\begin_layout Plain Layout

				pila.push(*i); 		
\end_layout

\begin_layout Plain Layout

		} 	
\end_layout

\begin_layout Plain Layout

	} 	
\end_layout

\begin_layout Plain Layout

	for (int i = 2; i<12; i++) 		
\end_layout

\begin_layout Plain Layout

		if (visitato[i] == false) 			
\end_layout

\begin_layout Plain Layout

			contatore++; 	
\end_layout

\begin_layout Plain Layout

	return contatore; 
\end_layout

\begin_layout Plain Layout

} 
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

int main() { 	
\end_layout

\begin_layout Plain Layout

	ifstream in("input.txt"); 	
\end_layout

\begin_layout Plain Layout

	ofstream out("output.txt"); 	
\end_layout

\begin_layout Plain Layout

	in >> M; 	
\end_layout

\begin_layout Plain Layout

	for (int i = 0; i < M; i++) 	{ 		
\end_layout

\begin_layout Plain Layout

		int a, b; 		
\end_layout

\begin_layout Plain Layout

		in >> a >> b; 		
\end_layout

\begin_layout Plain Layout

		giocatori[a].passaggi.push_back(b); 	
\end_layout

\begin_layout Plain Layout

	} 	
\end_layout

\begin_layout Plain Layout

	int numero_maglia = 0, giocatori_esclusi = -1; 	
\end_layout

\begin_layout Plain Layout

	for (int i = 2; i < 12; i++) 	{ 		
\end_layout

\begin_layout Plain Layout

		int temp = visita(i); 		
\end_layout

\begin_layout Plain Layout

		if (temp > giocatori_esclusi) 		{ 			
\end_layout

\begin_layout Plain Layout

			giocatori_esclusi = temp; 			
\end_layout

\begin_layout Plain Layout

			numero_maglia = i; 		
\end_layout

\begin_layout Plain Layout

		} 	
\end_layout

\begin_layout Plain Layout

	} 	
\end_layout

\begin_layout Plain Layout

	out << numero_maglia << endl; 	
\end_layout

\begin_layout Plain Layout

	return 0; 
\end_layout

\begin_layout Plain Layout

} 	
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Come si può vedere nel codice (righe 8-29) la visita viene fatta in profondità
 usando il modello già visto 
\begin_inset CommandInset ref
LatexCommand vpageref
reference "codice:dfs"

\end_inset

, con solo alcune aggiunte interessanti:
\end_layout

\begin_layout Itemize
alla riga 10 viene usato l'algoritmo 
\emph on
fill
\emph default
 per inizializzare il vettore dei nodi visitati, che deve essere reinizializzato
 ad ogni chiamata di funzione: usare l'algoritmo 
\emph on
fill
\emph default
 al posto di un più classico ciclo for non dà un grosso vantaggio in termini
 di risparmio di scrittura di codice, però può essere un modo di abituarsi
 a sfruttare la liberia standard dove c'è la possibilità.
\end_layout

\begin_layout Itemize
alla riga 11 viene segnato come già visitato il nodo n, che per quanto detto
 qualche riga sopra per i nostri scopi equivale all'eliminazione di quel
 nodo
\end_layout

\begin_layout Itemize
alla riga 13 viene inserito il nodo 1 come nodo di partenza della visita
 come da testo del problema
\end_layout

\begin_layout Standard
Nel programma poi, dopo aver letto l'input (righe 34-39), viene chiamata
 la visita escludendo ogni giocatore dal 2 all'11 e trovando 
\begin_inset Quotes eld
\end_inset

al volo
\begin_inset Quotes erd
\end_inset

 il numero massimo di giocatori che rimangono non più raggiungibili (righe
 43-46)
\end_layout

\begin_layout Section
\begin_inset CommandInset label
LatexCommand label
name "sec:Teta"

\end_inset

La mensa (teta) - CoCi Marzo 2015
\end_layout

\begin_layout Standard
\begin_inset Box Framed
position "t"
hor_pos "c"
has_inner_box 0
inner_pos "t"
use_parbox 0
use_makebox 0
width "100col%"
special "none"
height "1in"
height_special "totalheight"
status collapsed

\begin_layout Subsection*
La mensa (teta)
\end_layout

\begin_layout Subsubsection*
Difficoltà D = 2.
 
\end_layout

\begin_layout Subsubsection*
Descrizione del problema
\end_layout

\begin_layout Plain Layout
C'è una simpatica ragazza che lavora come cassiera alla mensa scolastica.
 Uno dei tanti motivi per cui questa ragazza è considerata simpatica da
 tutti gli studenti è la sua attenzione a fargli spendere il meno possibile
 ogni volta che si servono della mensa.
\end_layout

\begin_layout Plain Layout
Come riesce a farlo? In realtà la sua strategia è piuttosto semplice.
 I vari piatti che possono essere comprati alla mensa e i loro prezzi sono
 noti.
 Ogni giorno viene offerto il menù del giorno.
 Il menù include 4 portate (una zuppa, il piatto principale, un contorno
 e un dolce), ma il prezzo è minore o uguale alla somma dei prezzi delle
 portate di cui è composto.
 Quando la ragazza nota che spenderesti di meno a comprare un menù piuttosto
 che a comprare le singole portate separatamente, sceglie di farti pagare
 il menù al posto delle singole portate, in modo che uscirai dalla mensa
 sazio e con più soldi nel portafoglio .
 
\end_layout

\begin_layout Plain Layout
Sei di fronte alla cassa con il tuo vassoio e vuoi sapere quanto ti farà
 pagare la cassiera.
 Scrivi un programma per scoprirlo!
\end_layout

\begin_layout Plain Layout

\series bold
Attenzione
\series default
: La ragazza può farti comprare più di un menù se questo ti permetterà di
 risparmiare.
\end_layout

\begin_layout Subsubsection*
Dati di input
\end_layout

\begin_layout Plain Layout
La prima linea contiene l'intero K (
\begin_inset Formula $1\leq K\leq20$
\end_inset

), il numero di portate che possono essere comprate alla mensa.
 Per semplicità, ogni portata verrà rappresentata da un intero compreso
 tra 1 e K.
\end_layout

\begin_layout Plain Layout
La seconda linea di input contiene K interi, con l'
\emph on
i
\emph default
-esimo numero che rappresenta il prezzo della portata di indice 
\emph on
i
\emph default
.
 I prezzi sono compresi tra 1 e 250.
\end_layout

\begin_layout Plain Layout
La terza linea contiene l'intero X (
\begin_inset Formula $1\leq X\leq1000$
\end_inset

), il prezzo del menù.
\end_layout

\begin_layout Plain Layout
La linea seguente contiene 4 interi, i numeri delle portate contenute nel
 menù del giorno, diversi tra loro.
\end_layout

\begin_layout Plain Layout
La quinta linea contiene l'intero T (
\begin_inset Formula $1\leq T\leq20$
\end_inset

), il numero di portate sul tuo vassoio.
\end_layout

\begin_layout Plain Layout
L'ultima linea contiene la lista delle T portate che hai preso.
 Non è detto che tutte le portate siano distinte, la stessa portata può
 comparire più volte.
\end_layout

\begin_layout Subsubsection*
Dati di output
\end_layout

\begin_layout Plain Layout
Un unico intero che deve contenere il costo totale delle portate acquistate.
\end_layout

\begin_layout Subsubsection*
Esempi di input/output 
\end_layout

\begin_layout Plain Layout
\begin_inset Tabular
<lyxtabular version="3" rows="2" columns="2">
<features tabularvalignment="middle">
<column alignment="left" valignment="top" width="1.5in">
<column alignment="left" valignment="top" width="0">
<row>
<cell alignment="left" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
Input
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
Output
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
7 
\end_layout

\begin_layout Plain Layout
10 6 8 9 4 5 3 
\end_layout

\begin_layout Plain Layout
14 
\end_layout

\begin_layout Plain Layout
1 2 3 4 
\end_layout

\begin_layout Plain Layout
5 
\end_layout

\begin_layout Plain Layout
1 3 4 6 7
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
22
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\begin_inset Newline newline
\end_inset


\begin_inset Newline newline
\end_inset


\begin_inset Tabular
<lyxtabular version="3" rows="2" columns="2">
<features tabularvalignment="middle">
<column alignment="left" valignment="top" width="1.5in">
<column alignment="left" valignment="top" width="0">
<row>
<cell alignment="left" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
Input
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
Output
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
6 
\end_layout

\begin_layout Plain Layout
12 5 7 8 9 3 14 
\end_layout

\begin_layout Plain Layout
4 3 1 2 
\end_layout

\begin_layout Plain Layout
5 
\end_layout

\begin_layout Plain Layout
1 2 1 6 6
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
32
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Plain Layout

\series bold
Chiarimenti sul primo esempio
\series default
: le portate 1, 3 e 4 contenute nel tuo vassoio fanno anche parte del menù,
 così la cassiera ti addebiterà il costo del menù, che è vantaggioso rispetto
 alla somma dei singoli piatti.
 Le portate 6 e 7, non facendo parte del menù, vengono pagate il loro prezzo.
\end_layout

\begin_layout Plain Layout

\series bold
Chiarimenti sul secondo esempio
\series default
: nel vassoio ci sono due volte la portata 1 (Wiener Schnitzel), così la
 cassiera di addebiterà il costo di un menù con anche compresa la portata
 2 e l'altra portata 1 verrà pagata a prezzo pieno (perchè non conviene
 che venga pagato un secondo menù).
 Poi dovrai pagare 2 volte per la portata 6, che non appartiene al menù,
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Aspetti interessanti
\end_layout

\begin_layout Standard

\series bold
Parole chiave
\series default
: matrici, contatori, organizzazione del codice.
\end_layout

\begin_layout Standard
Questo problema, pur non essendo particolarmente complesso, richiede di
 organizzare bene il codice in modo da prendere in considerazione tutti
 i casi possibili.
 Definendo opportunamente alcune variabili che agiranno come strutture di
 supporto alla soluzione del problema, vedremo che il codice risulterà compatto,
 sfruttando anche l'utilizzo di elementi di vettori come indici per altri
 vettori/matrici.
\end_layout

\begin_layout Subsection
Soluzione
\end_layout

\begin_layout Standard
Data la dimensione del problema (di fatto 20x20, considerando il numero
 totale di portate e il numero di portate che possono essere acquistate)
 non sembra essere necessario utilizzare nessun algoritmo particolarmente
 veloce o furbo, ma è sufficiente scrivere un programma ben organizzato
 che esplori tutti i casi possibili.
 Una delle prime difficoltà potrebbe essere quella di comprendere bene il
 testo, in considerazione anche dell'elevato numero di campi di input.
 Come al solito la lettura dei casi di esempio può aiutare: in questo caso,
 essendo presenti delle chiarificazioni, è una buona idea leggerle per migliorar
e o confermare la comprensione del problema.
\end_layout

\begin_layout Standard
La parte 
\begin_inset Quotes eld
\end_inset

complicata
\begin_inset Quotes erd
\end_inset

 deriva dal fatto che per decidere se prendere o meno un menù è necessario
 valutare se l'insieme delle portate che voglio prendere e che fanno parte
 del menù mi costerebbero di meno se prese separatamente oppure all'interno
 del menù: mentre è evidente che se desidero prendere tutte e quattro le
 portate del menù mi conviene prendere il menù, in tutti gli altri casi,
 con un numero di portate comprese nel menù inferiore a 4, devo valutare
 a seconda dei costi delle singole portate che mi interessano: anche con
 una portata sola potrebbe convenire prendere il menù se il prezzo di quella
 portata fosse superiore al prezzo del menù.
 
\end_layout

\begin_layout Standard
Un altro problema sorge dal fatto che si possono prendere portate ripetute
 e quindi potrebbe succedere che convenga prendere più di un menù.
 Invece ciò che sicuramente non comporta problema sono le portate non presenti
 nel menù, che ovviamente devono essere comprate a prezzo intero.
\end_layout

\begin_layout Standard
Dopo qualche riflessione si può arrivare a un algoritmo 
\begin_inset Quotes eld
\end_inset

costruttivo
\begin_inset Quotes erd
\end_inset

 che potrebbe essere descritto in questo modo:
\end_layout

\begin_layout Itemize
per ogni piatto di portata nel vassoio controlla se è presente nel menù
\end_layout

\begin_deeper
\begin_layout Itemize
se non è presente lo si compra al suo prezzo
\end_layout

\begin_layout Itemize
se è presente lo si tiene da parte, per verificare poi se, da solo o insieme
 ad altri, convenga prenderlo tramite l'acquisto di un menù
\end_layout

\end_deeper
\begin_layout Standard
Per vedere come risolvere il problema di stabilire se è meglio prendere
 o meno un menù, dati uno o più piatti contenuti al suo interno, possiamo
 usare un approccio greedy, nel senso che la cosa migliore che possiamo
 fare è quella di comporre menù formati dal maggior numero possibili di
 portate, fino a che compriamo tutte le portate che ci interessano.
 Per chiarire meglio il concetto si può guardare la figura 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:Esempio-di-calcolo-teta"

\end_inset

.
 Nell'esempio si suppone che sul nostro vassoio siano presenti due zuppe,
 tre polli arrosto e un contorno di verdure, i cui prezzi sono evidenziati
 sotto il menù.
 Se li inseriamo nella griglia in figura, possiamo facilmente notare che
 è possibile risolvere il problema analizzando le righe singolarmente.
 Partendo dalla riga più in basso, in cui la somma delle portate è uguale
 a 22, verrà scelto un menù, per la seconda riga, la cui somma dei costi
 delle portate è uguale a 15 verrà scelto ancora un menù ed infine per la
 terza riga in cui è presente solo un pollo, lo si acquisterà singolarmente
 al costo di 10.
 Nell'esempio non compaiono portate non presenti nel menù perchè abbiamo
 già detto che il loro costo andrà semplicemente sommato al costo totale.
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement h
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename ../materiali/problemi nuovi/CoCi/teta/soluzione.png

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:Esempio-di-calcolo-teta"

\end_inset

Esempio di calcolo dei menù
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Detto questo il codice traduce esattamente quanto mostrato in figura.
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "basicstyle={\small\ttfamily},breaklines=true,frame=lr,language={C++},numbers=left,showstringspaces=false,tabsize=4"
inline false
status collapsed

\begin_layout Plain Layout

int K; //meals in the canteen
\end_layout

\begin_layout Plain Layout

int prices[20]; 
\end_layout

\begin_layout Plain Layout

int menu_price;
\end_layout

\begin_layout Plain Layout

int menu[4];
\end_layout

\begin_layout Plain Layout

int T; //meals on the tray
\end_layout

\begin_layout Plain Layout

int meals[20];
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

int meals_in_menu[20][20];
\end_layout

\begin_layout Plain Layout

int how_many[20];
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

int sub_menu_cost(int n)
\end_layout

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

	int tot = 0;
\end_layout

\begin_layout Plain Layout

	for(int i = 0; i < 20; i++)
\end_layout

\begin_layout Plain Layout

		tot += meals_in_menu[n][i];
\end_layout

\begin_layout Plain Layout

	return tot;
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

bool in_menu(int n)
\end_layout

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

	for(int i = 0; i < 4; i++)
\end_layout

\begin_layout Plain Layout

		if (n == menu[i])
\end_layout

\begin_layout Plain Layout

			return true;
\end_layout

\begin_layout Plain Layout

	return false;
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

int main()
\end_layout

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

	int cost = 0;
\end_layout

\begin_layout Plain Layout

	cin >> K;
\end_layout

\begin_layout Plain Layout

	for(int i = 1; i <= K; i++)
\end_layout

\begin_layout Plain Layout

		cin >> prices[i];
\end_layout

\begin_layout Plain Layout

	cin >> menu_price;
\end_layout

\begin_layout Plain Layout

	for(int i = 0; i < 4; i++)
\end_layout

\begin_layout Plain Layout

		cin >> menu[i];
\end_layout

\begin_layout Plain Layout

	cin >> T;
\end_layout

\begin_layout Plain Layout

	for(int i = 0; i < T; i++)
\end_layout

\begin_layout Plain Layout

	{
\end_layout

\begin_layout Plain Layout

		cin >> meals[i];
\end_layout

\begin_layout Plain Layout

		if (in_menu(meals[i]))
\end_layout

\begin_layout Plain Layout

			meals_in_menu[how_many[meals[i]]++][meals[i]] = prices[meals[i]];
\end_layout

\begin_layout Plain Layout

		else
\end_layout

\begin_layout Plain Layout

			cost += prices[meals[i]];
\end_layout

\begin_layout Plain Layout

	}
\end_layout

\begin_layout Plain Layout

	int max_menus = *max_element(how_many, how_many+20);
\end_layout

\begin_layout Plain Layout

	for(int i = 0; i < max_menus; i++)
\end_layout

\begin_layout Plain Layout

		if (sub_menu_cost(i) < menu_price)
\end_layout

\begin_layout Plain Layout

			cost += sub_menu_cost(i);
\end_layout

\begin_layout Plain Layout

		else
\end_layout

\begin_layout Plain Layout

			cost += menu_price;
\end_layout

\begin_layout Plain Layout

	cout << cost << endl;
\end_layout

\begin_layout Plain Layout

	return 0;
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

 
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Le prime 6 righe dichiarano le strutture necessarie per contenere i dati
 di input: da notare che i costi vengono messi nel vettore dei costi partendo
 dall'indice 1 e non 0, poichè essendo le portate numerate a partire da
 1, questo renderà più naturale l'utilizzo degli indici delle portate così
 come usati negli input successivi.
 Alla riga 8 viene dichiarata la matrice che corrisponde a quella mostrata
 in figura 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:Esempio-di-calcolo-teta"

\end_inset

 e alla riga successiva un vettore di contatori, 
\emph on
how_many
\emph default
, che servirà a stabilire il numero di portate presenti in ogni colonna.
 Nell'esempio in figura il vettore avrebbe i valori [2,0,3,0,1,0,0] (per
 motivi di spazio la figura è più piccola della matrice reale).
 Nelle linee dalla 29 alla 36 vengono letti tutti i valori di input tranne
 le portate presenti nel vassoio, che invece vengono lette nel successivo
 ciclo.
 Nel leggerle si controlla se la portata è presente nel menu (con la funzione
 
\emph on
in_menu
\emph default
) e se lo è si inserisce nella matrice 
\emph on
meals_in_menu
\emph default
 un 1 nella prima posizione disponibile, in modo da riempire la matrice
 come in figura.
 Il codice è scritto in modo da usare come indice di riga il numero di portate
 di quel tipo già presenti nella matrice (numero che poi verrà incrementato
 grazie al ++) e come indice di colonna il numero della portata attuale.
 Se invece non è presente nel menù basta sommare il suo costo al costo totale.
\end_layout

\begin_layout Standard
Una volta riempita la matrice con le portate che appaiono nel menù, basta
 scorrere la matrice dalla prima riga all'ultima che contiene almeno un
 1 (per sapere qual è l'ultima riga che contiene un 1 basta trovare il massimo
 del vettore 
\emph on
how_many,
\emph default
 cosa che nel codice viene fatta con l'algoritmo 
\series bold
max_element
\series default
), e, tramite la funzione 
\emph on
sub_menu_cost
\emph default
 (righe 11-17) calcolare il costo di quella riga: a questo punto un semplice
 controllo tra il costo calcolato e quello del menù ci dirà quale dei due
 scegliere.
\end_layout

\begin_layout Section
\begin_inset CommandInset label
LatexCommand label
name "sec:Teta-1"

\end_inset

Cerca le somme (cercalesomme) - GATOR 2015
\end_layout

\begin_layout Standard
\begin_inset Box Framed
position "t"
hor_pos "c"
has_inner_box 0
inner_pos "t"
use_parbox 0
use_makebox 0
width "100col%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout Subsection*
Cerca le somme (cercalesomme)
\end_layout

\begin_layout Subsubsection*
Difficoltà D = 2.
 
\end_layout

\begin_layout Subsubsection*
Descrizione del problema
\end_layout

\begin_layout Plain Layout
Filippo, il nuovo assistente del sindaco di Roma, è molto preoccupato.
 Alla prima riunione in cui ha partecipato, si sono discusse le varie voci
 del bilancio delle olimpiadi.
 Lui ha trascritto tutti questi numeri su un foglio, ma poi lo ha lasciato
 nei pantaloni che sono finiti in lavatrice.
 Per fortuna non tutto è perduto: si intravedono le cifre, e lui si ricorda
 qual era il totale del bilancio previsto per le olimpiadi.
 Il vostro compito è quello di aiutare Filippo a capire quanti sono i modi
 di comporre le cifre, nel modo descritto di seguito, per poter ricostruire
 correttamente il bilancio delle olimpiadi.
 
\end_layout

\begin_layout Plain Layout
Dato il foglio con le cifre, vogliamo inserire alcuni segni “+” in modo
 che il risultato delle operazioni di somma sia quello che si ricorda Filippo.
 Ad esempio, data la sequenza di cifre decimali:
\end_layout

\begin_layout Plain Layout
\align center
1 2 3 4 5 6 7 
\end_layout

\begin_layout Plain Layout
Possiamo inserire quattro operatori “+” in modo tale che il risultato delle
 somme sia uguale a 100.
 In questo particolare caso una possibile soluzione è:
\end_layout

\begin_layout Plain Layout
\align center
1 + 23 + 4 + 5 + 67
\end_layout

\begin_layout Plain Layout
Aiuta Filippo a trovare tutti i possibili modi di ottenere la somma data.
\end_layout

\begin_layout Subsubsection*
Dati di input
\end_layout

\begin_layout Plain Layout
Il file 
\begin_inset Flex Strong
status collapsed

\begin_layout Plain Layout
input.txt
\end_layout

\end_inset

 contiene tre righe di testo.
 Nella prima riga c’è un singolo numero intero positivo N che ci dice quante
 sono le cifre decimali nel foglio di Filippo.
 Nella seconda riga del file vi sono le cifre decimali separate tra loro
 da spazi.
 Nella terza riga del file c’è il totale del bilancio, ovvero il valore
 che deve essere ottenuto con le operazioni di somma.
\end_layout

\begin_layout Subsubsection*
Dati di output
\end_layout

\begin_layout Plain Layout
Il file 
\begin_inset Flex Strong
status collapsed

\begin_layout Plain Layout
output.txt
\end_layout

\end_inset

 contiene una riga per ciascuna soluzione esatta trovata; la riga contiene
 le posizioni dei segni “+” separate da spazi.
 Se una posizione ha valore 
\begin_inset Flex Emph
status collapsed

\begin_layout Plain Layout
i
\end_layout

\end_inset

, significa che il corrispondente segno “+” segue la 
\begin_inset Flex Emph
status collapsed

\begin_layout Plain Layout
i
\end_layout

\end_inset

-esima cifra.
\end_layout

\begin_layout Subsubsection*
Assunzioni
\end_layout

\begin_layout Itemize
La stessa cifra può apparire più volte nella sequenza.
\end_layout

\begin_layout Itemize
Vengono date al più N = 9 cifre.
\end_layout

\begin_layout Itemize
È garantito che esiste almeno una soluzione.
\end_layout

\begin_layout Subsubsection*
Esempi di input/output 
\end_layout

\begin_layout Plain Layout
\begin_inset Tabular
<lyxtabular version="3" rows="2" columns="2">
<features tabularvalignment="middle">
<column alignment="left" valignment="top" width="1.5in">
<column alignment="left" valignment="top" width="1in">
<row>
<cell alignment="left" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
Input
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
Output
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
7 
\end_layout

\begin_layout Plain Layout
1 2 3 4 5 6 7 
\end_layout

\begin_layout Plain Layout
100
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
1 3 4 5 
\end_layout

\begin_layout Plain Layout
1 2 4 6
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\begin_inset Newline newline
\end_inset


\begin_inset Newline newline
\end_inset


\begin_inset Tabular
<lyxtabular version="3" rows="2" columns="2">
<features tabularvalignment="middle">
<column alignment="left" valignment="top" width="1.5in">
<column alignment="left" valignment="top" width="1in">
<row>
<cell alignment="left" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
Input
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
Output
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
8 
\end_layout

\begin_layout Plain Layout
2 1 3 4 5 1 8 9 
\end_layout

\begin_layout Plain Layout
105
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
1 2 3 4 5 6 
\end_layout

\begin_layout Plain Layout
1 2 4 6 7
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Aspetti interessanti
\end_layout

\begin_layout Standard

\series bold
Parole chiave
\series default
: ricorsione, ricerca esaustiva, backtracking.
\end_layout

\begin_layout Standard
Questo, come altri problemi dove la dimensione dell'input risulta molto
 ridotta, invita a ricorrere a una semplice implementazione ricorsiva, nella
 quale provare esaustivamente tutti i possibili casi.
\end_layout

\begin_layout Subsection
Soluzione
\end_layout

\begin_layout Standard
Come nel problema 
\begin_inset CommandInset ref
LatexCommand ref
reference "sec:Esempio:-Domino-massimale"

\end_inset

, la dimensione massima dell'input, fissata a 9, permette di procedere senza
 preoccuparsi della complessità computazionale della soluzione, quindi è
 evidente che un approccio a forza bruta si presta a una semplice implementazion
e della soluzione.
\end_layout

\begin_layout Standard
Come in altri casi dello stesso tipo la ricorsione permette di scrivere
 una soluzione diretta, usando la tecnica del backtracking.
 L'idea è quella di provare tutti i modi possibili di inserire l'operatore
 di somma, tenendo traccia delle posizioni nelle quali è stato inserito.
 Data una serie di possibili posizioni è poi necessario 
\begin_inset Quotes eld
\end_inset

creare
\begin_inset Quotes erd
\end_inset

 i numeri composti dalle cifre comprese tra la posizione 
\emph on
i
\emph default
 e la posizione 
\emph on
i+1
\emph default
.
 Se ad esempio venisse inserito un 
\begin_inset Flex Strong
status collapsed

\begin_layout Plain Layout
+
\end_layout

\end_inset

 in posizione 1 e un 
\begin_inset Flex Strong
status collapsed

\begin_layout Plain Layout
+
\end_layout

\end_inset

 in posizione 3, bisognerebbe comporre la seconda e la terza cifra date
 in input per formare il numero da sommare.
 Questo si ottiene facilmente con un ciclo che va a pesare le cifre secondo
 la propria posizione.
\end_layout

\begin_layout Standard
Per stabilire poi se si è trovata una soluzione basterà confrontare la somma
 parziale con il totale, se coincidono si è in presenza di una soluzione,
 altrimenti si continua a cercare.
 Una semplice miglioria, lasciata al lettore come esercizio, è quella di
 fermarsi quando il parziale è maggiore del totale, perchè in quel caso
 non sarà possibile trovare una soluzione essendo tutti i numeri positivi.
\end_layout

\begin_layout Standard
Il codice sarà quindi:
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "basicstyle={\small\ttfamily},breaklines=true,frame=lr,language={C++},numbers=left,showstringspaces=false,tabsize=4"
inline false
status collapsed

\begin_layout Plain Layout

int operatori[10];
\end_layout

\begin_layout Plain Layout

int quanti;
\end_layout

\begin_layout Plain Layout

int cifre[9];
\end_layout

\begin_layout Plain Layout

int N, totale;
\end_layout

\begin_layout Plain Layout

ofstream out;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

int componi(int inizio, int fine)
\end_layout

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

	int totale = 0;
\end_layout

\begin_layout Plain Layout

	for (int i = inizio; i <= fine; i++)
\end_layout

\begin_layout Plain Layout

		totale = totale*10 + cifre[i];
\end_layout

\begin_layout Plain Layout

	return totale;
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

void cercasomme(int start, int parziale)
\end_layout

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

	if (start == N)
\end_layout

\begin_layout Plain Layout

		if (parziale == totale)
\end_layout

\begin_layout Plain Layout

		{
\end_layout

\begin_layout Plain Layout

			for (int i = 0; i < N; i++)
\end_layout

\begin_layout Plain Layout

			{
\end_layout

\begin_layout Plain Layout

				if (operatori[i] == 1)
\end_layout

\begin_layout Plain Layout

					out << i << " ";
\end_layout

\begin_layout Plain Layout

			}
\end_layout

\begin_layout Plain Layout

			out << endl;
\end_layout

\begin_layout Plain Layout

			return;
\end_layout

\begin_layout Plain Layout

		}
\end_layout

\begin_layout Plain Layout

	for (int i = start; i < N ; i++)
\end_layout

\begin_layout Plain Layout

	{
\end_layout

\begin_layout Plain Layout

		operatori[i+1] = 1;
\end_layout

\begin_layout Plain Layout

		cercasomme(i+1,parziale + componi(start,i));
\end_layout

\begin_layout Plain Layout

		operatori[i+1] = 0;
\end_layout

\begin_layout Plain Layout

	}
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

int main()
\end_layout

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

	ifstream in("input.txt");
\end_layout

\begin_layout Plain Layout

	out.open("output.txt");
\end_layout

\begin_layout Plain Layout

	in >> N;
\end_layout

\begin_layout Plain Layout

	for (int i = 0; i < N; i++)
\end_layout

\begin_layout Plain Layout

		in >> cifre[i];
\end_layout

\begin_layout Plain Layout

	in >> totale;
\end_layout

\begin_layout Plain Layout

	cercasomme(0,0);
\end_layout

\begin_layout Plain Layout

	return 0;
\end_layout

\begin_layout Plain Layout

} 
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Le due strutture dati principali sono i vettori delle cifre e quello degli
 operatori (che contiene un elemento in più in modo da poter partire da
 uno anzichè da zero).
\end_layout

\begin_layout Standard
La funzione 
\emph on
componi
\emph default
, come già detto, si occupa semplicemente di creare un numero componendo
 le cifre da 
\emph on
inizio
\emph default
 a 
\emph on
fine
\emph default
, estremi compresi.
 Per far questo la funzione considera che ogni numero 
\begin_inset Flex Strong
status collapsed

\begin_layout Plain Layout
N
\end_layout

\end_inset

 composto da 
\emph on
n+1
\emph default
 cifre in base 10, essendo scritto in notazione posizionale, è equivalente
 al numero
\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
N=c_{n}\cdot10^{n}+c_{n-1}\cdot10^{n-1}+\ldots+c_{1}\cdot10^{1}+c_{o}\cdot10^{0}
\]

\end_inset


\end_layout

\begin_layout Standard
e quindi un modo comodo per calcolarlo è quello di considarlo nella seguente
 forma equivalente:
\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
N=((\ldots((c_{n}\cdot10+c_{n-1})\cdot10+c_{n-2})\cdot10+\ldots)+c_{0}
\]

\end_inset


\end_layout

\begin_layout Standard
La funzione principale, ricorsiva, ha come condizione di terminazione un
 controllo sul fatto che siano state prese in considerazione tutte le cifre,
 poichè la somma deve includerle tutte.
 Nel caso questa condizione sia soddisfatta si controlla se la somma corrente
 sia uguale a quella richiesta e, nel caso lo sia, vengono stampate le posizioni
 dei segni +, memorizzate nel vettore operatori.
\end_layout

\begin_layout Standard
In tutti gli altri casi vuol dire che non sono state utilizzate ancora tutte
 le cifre e quindi bisogna proseguire: i parametri della funzione sono il
 valore 
\emph on
parziale
\emph default
 calcolato fine alla posizione 
\emph on
start
\emph default
, e da lì in poi si sommano a 
\emph on
parziale
\emph default
 tutti i possibili modi di sommare le cifre rimanenti, uno per volta utilizzando
 il backtracking.
 Il vettore di backtracking è quello che memorizza al suo interno le possibili
 scelte su dove vengono messi gli operatori, scandendo tutte le posizioni
 rimaste da testare (riga 28): per ogni possibile scelta si inserisce un
 segno + in quella posizione (riga 30), si procede in maniera ricorsiva
 sulle cifre rimaste, e poi si toglie il segno + (riga 32) per provare le
 altre possibilità.
\end_layout

\begin_layout Section
\begin_inset CommandInset label
LatexCommand label
name "sec:Anno-luce"

\end_inset

Anno luce (annoluce) - OIS 2015/2016
\end_layout

\begin_layout Standard
\begin_inset Box Framed
position "t"
hor_pos "c"
has_inner_box 0
inner_pos "t"
use_parbox 0
use_makebox 0
width "100col%"
special "none"
height "1in"
height_special "totalheight"
status collapsed

\begin_layout Subsection*
Anno luce (annoluce) 
\end_layout

\begin_layout Plain Layout
Grazie ad una recente ricerca che ha confermato l’esistenza delle onde gravitazi
onali, sempre più persone si stanno interessando allo spazio.
 Purtroppo però, lo spazio è ancora una realtà poco accessibile alle persone
 comuni.
 Sebbene sia un po’ demoralizzato da questo fatto, William è convinto che
 sia possibile sfruttare la recente attenzione mediatica delle onde gravitaziona
li per pubblicizzare un business: ha deciso infatti di aprire una startup
 di viaggi interstellari.
 C’è da dire però che, a parte il Sole che è la stella a noi più vicina,
 le altre stelle sono piuttosto distanti.
 Proxima Centauri, la “seconda stella più vicina”, dista dal Sole ben 4.24
 anni luce: questo vuol dire che sarebbero necessari più di quattro anni
 per raggiungere questa stella! (supponendo di poter viaggiare alla velocità
 della luce).
\end_layout

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename /home/xubuntu/Desktop/guida/materiali/problemi nuovi/squadre/annoluce/starts.png
	scale 50

\end_inset


\end_layout

\begin_layout Plain Layout
William pensa di riuscire a costruire un’astronave in grado di viaggiare
 alla velocità della luce (ha trovato un tutorial su YouTube che gli sembra
 piuttosto convincente) e ha perciò acquistato un telescopio per tracciare
 una mappa 3D della Via Lattea.
 Ogni stella è indicata nella mappa 3D mediante un punto (x, y, z) dello
 spazio.
 Il Sole è sempre presente nella mappa ed è sempre identificato dal punto
 (0, 0, 0).
 Scrivi un programma che data la mappa stellare sia in grado di rispondere
 a Q query: ogni query fornisce un numero intero D e chiede quante sono
 le stelle raggiungibili avendo a disposizione D anni di viaggio.
\end_layout

\begin_layout Subsubsection*
Dati di input 
\end_layout

\begin_layout Plain Layout
Il file input.txt è composto da N + Q + 2 righe.
 La prima riga contiene l’unico intero N .
 Le successive N righe contengono le coordinate X i , Y i , Z i dell’i-esima
 stella, separate da spazio.
 La successiva riga contiene l’unico intero Q.
 Le successive Q righe contengono i valori di D delle relative query.
 
\end_layout

\begin_layout Subsubsection*
Dati di output 
\end_layout

\begin_layout Plain Layout
Il file output.txt è composto da Q righe contenente un intero ciascuna: la
 risposta alla relativa query.
 
\end_layout

\begin_layout Subsubsection*
Assunzioni 
\end_layout

\begin_layout Itemize
1 ≤ N, Q ≤ 100 000.
 
\end_layout

\begin_layout Itemize
0 ≤ X i , Y i , Z i < 
\begin_inset Formula $2^{30}$
\end_inset

 per ogni i = 0 .
 .
 .
 N − 1.
 
\end_layout

\begin_layout Itemize
L’unità degli assi x, y, z è l’anno luce.
 
\end_layout

\begin_layout Itemize
0 ≤ D < 
\begin_inset Formula $2^{31}$
\end_inset

 per ogni chiamata a query(D).
 
\end_layout

\begin_layout Itemize
Il valore D è espresso in anni luce.
\end_layout

\begin_layout Subsubsection*
Assegnazione del punteggio 
\end_layout

\begin_layout Plain Layout
Il tuo programma verrà testato su diversi test case raggruppati in subtask.
 Per ottenere il punteggio relativo ad un subtask, è necessario risolvere
 correttamente tutti i test relativi ad esso.
\end_layout

\begin_layout Itemize
\begin_inset Flex Strong
status collapsed

\begin_layout Plain Layout
Subtask 1 [10 punti]
\end_layout

\end_inset

: Casi d’esempio.
\end_layout

\begin_layout Itemize
\begin_inset Flex Strong
status collapsed

\begin_layout Plain Layout
Subtask 2 [20 punti]
\end_layout

\end_inset

: Y[i] = Z[i] = 0 per ogni i.
 Invece che nello spazio tridimensionale, le stelle sono tutte su una retta!
 
\end_layout

\begin_layout Itemize
\begin_inset Flex Strong
status collapsed

\begin_layout Plain Layout
Subtask 3 [20 punti]
\end_layout

\end_inset

: Z[i] = 0 per ogni i.
 Invece che nello spazio tridimensionale, siamo su un piano bidimensionale!
\end_layout

\begin_layout Itemize
\begin_inset Flex Strong
status collapsed

\begin_layout Plain Layout
Subtask 4 [10 punti]
\end_layout

\end_inset

: N, Q, D ≤ 10.
 
\end_layout

\begin_layout Itemize
\begin_inset Flex Strong
status collapsed

\begin_layout Plain Layout
Subtask 5 [10 punti]
\end_layout

\end_inset

: N ≤ 100; D < 10 000.
 
\end_layout

\begin_layout Itemize
\begin_inset Flex Strong
status collapsed

\begin_layout Plain Layout
Subtask 6 [10 punti]
\end_layout

\end_inset

: Q ≤ 100; D < 10 000.
 
\end_layout

\begin_layout Itemize
\begin_inset Flex Strong
status collapsed

\begin_layout Plain Layout
Subtask 7 [20 punti]
\end_layout

\end_inset

: Nessuna limitazione specifica.
\end_layout

\begin_layout Subsubsection*
Esempi di input/output 
\end_layout

\begin_layout Plain Layout
\begin_inset Tabular
<lyxtabular version="3" rows="2" columns="2">
<features tabularvalignment="middle">
<column alignment="left" valignment="top" width="1.5in">
<column alignment="left" valignment="top" width="1in">
<row>
<cell alignment="left" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
Input
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
Output
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
3 
\end_layout

\begin_layout Plain Layout
0 0 0 
\end_layout

\begin_layout Plain Layout
1 1 1 
\end_layout

\begin_layout Plain Layout
2 2 2 
\end_layout

\begin_layout Plain Layout
5 
\end_layout

\begin_layout Plain Layout
0 
\end_layout

\begin_layout Plain Layout
1 
\end_layout

\begin_layout Plain Layout
2 
\end_layout

\begin_layout Plain Layout
3 
\end_layout

\begin_layout Plain Layout
4
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
1
\end_layout

\begin_layout Plain Layout
1
\end_layout

\begin_layout Plain Layout
2
\end_layout

\begin_layout Plain Layout
2
\end_layout

\begin_layout Plain Layout
3
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\begin_inset Newline newline
\end_inset


\begin_inset Newline newline
\end_inset


\begin_inset Tabular
<lyxtabular version="3" rows="2" columns="2">
<features tabularvalignment="middle">
<column alignment="left" valignment="top" width="1.5in">
<column alignment="left" valignment="top" width="1in">
<row>
<cell alignment="left" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
Input
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
Output
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
5 
\end_layout

\begin_layout Plain Layout
1 2 3
\end_layout

\begin_layout Plain Layout
4 5 6
\end_layout

\begin_layout Plain Layout
0 0 0
\end_layout

\begin_layout Plain Layout
9 9 9
\end_layout

\begin_layout Plain Layout
7 1 1
\end_layout

\begin_layout Plain Layout
3 
\end_layout

\begin_layout Plain Layout
20 
\end_layout

\begin_layout Plain Layout
8 
\end_layout

\begin_layout Plain Layout
9
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
5
\end_layout

\begin_layout Plain Layout
3
\end_layout

\begin_layout Plain Layout
4
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Subsubsection*
Spiegazione
\end_layout

\begin_layout Plain Layout
Nel 
\begin_inset Flex Strong
status collapsed

\begin_layout Plain Layout
primo caso di esempio
\end_layout

\end_inset

, le 3 stelle distano dal sole rispettivamente: 0 anni luce, 
\begin_inset Formula $\sqrt{3}$
\end_inset

 anni luce e 2
\begin_inset Formula $\sqrt{3}$
\end_inset

 anni luce.
 
\end_layout

\begin_layout Plain Layout
Nel 
\begin_inset Flex Strong
status collapsed

\begin_layout Plain Layout
secondo caso di esempio
\end_layout

\end_inset

, le 5 stelle distano dal sole rispettivamente: 
\begin_inset Formula $\sqrt{14}$
\end_inset

 anni luce, 
\begin_inset Formula $\sqrt{77}$
\end_inset

 anni luce, 0 anni luce, 9
\begin_inset Formula $\sqrt{3}$
\end_inset

 anni luce e 
\begin_inset Formula $\sqrt{51}$
\end_inset

 anni luce.
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Aspetti interessanti
\end_layout

\begin_layout Standard
\begin_inset Flex Strong
status collapsed

\begin_layout Plain Layout
Parole chiave
\end_layout

\end_inset

: ordinamento, ricerca binaria, upper_bound, interi lunghi, teorema di Pitagora,
 subtasks.
\end_layout

\begin_layout Standard
Questo problema ha una soluzione ovvia che però non permette di prendere
 l'intero punteggio, implementando invece la soluzione che prevede l'ordinamento
 e la ricerca binaria è possibile ottenere il punteggio massimo e se si
 utilizzano gli algoritmi della Libreria Standard del C++ bastano poche
 righe di codice.
 Un'attenzione particolare va poi posta nei calcoli perchè i numeri possono
 diventare molto grandi.
\end_layout

\begin_layout Subsection
Soluzione
\end_layout

\begin_layout Standard
La soluzione banale al problema consiste nel calcolare la distanza
\begin_inset Foot
status collapsed

\begin_layout Plain Layout
Per calcolare la distanza si usa il teorema di Pitagora, che vale in qualsiasi
 spazio n-dimensionale.
\end_layout

\end_inset

 di ogni stella dal centro e poi, per ogni singola query, scorrere le distanze
 delle stelle e confrontarle con il valore D di ogni query.
 Chiaramente questo approccio richiede un costo di N confronti per ogni
 query (uno per ogni stella) e siccome le query sono Q il numero totale
 di confronti risulta essere 
\begin_inset Formula $NxQ$
\end_inset

.
 Dati i limiti sui valori di N e Q, entrambi con un massimo di 100000, risulta
 evidente che non è possibile con questo approcio fare punteggio pieno,
 anche se comunque si possono fare un bel po' di punti.
 In questo esercizio difatti, a differenza dei normali problemi delle territoria
li, nel testo vengono descritti dei sottocasi  con limiti che semplificano
 la soluzione del problema (ad esempio garantendo che in alcuni sottocasi
 N e Q siano minori di 10): in questo modo anche soluzioni semplici possono
 far guadagnare diversi punti
\begin_inset Foot
status collapsed

\begin_layout Plain Layout
A mio avviso può essere che nelle edizioni future questa diventi la modalità
 standard
\end_layout

\end_inset

.
\end_layout

\begin_layout Standard
Una soluzione migliore prevede che si proceda ordinando le stelle in base
 alla loro distanza: una volta ordinate è possibile effettuare una ricerca
 binaria per trovare velocemente la prima stella con una distanza appena
 superiore alla distanza D assegnata nella query: siccome tutte le stelle
 con distanza minore nell'array ordinato saranno prima di essa, l'indice
 di questa stella equivale al numero di stelle per cui la distanza è minore
 di D e quindi alla risposta cercata.
 
\end_layout

\begin_layout Standard
In questo modo si ha un costo di 
\begin_inset Formula $N\log_{2}N$
\end_inset

 per l'ordinamento, che viene effettuato una volta soltanto all'inizio di
 ogni test, e un costo di 
\begin_inset Formula $\log_{2}N$
\end_inset

per ogni query, quindi il costo totale risulta di 
\begin_inset Formula $N\log_{2}N+Q\log_{2}N$
\end_inset

, che con N e Q entrambi pari a 100.000 fornisce un valore di circa 3.3 milioni
 contro i 10 miliardi della soluzione banale.
\end_layout

\begin_layout Standard
Applicando quest'idea si ottiene il seguente codice:
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "basicstyle={\small\ttfamily},breaklines=true,frame=lr,language={C++},numbers=left,showstringspaces=false,tabsize=4"
inline false
status open

\begin_layout Plain Layout

long long int distanza[100000];
\end_layout

\begin_layout Plain Layout

int pianeti;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

void mappatura(int N, int X[], int Y[], int Z[]) {
\end_layout

\begin_layout Plain Layout

	pianeti = N;
\end_layout

\begin_layout Plain Layout

    for (int i = 0; i < N; i++)
\end_layout

\begin_layout Plain Layout

		distanza[i] = (long long int)X[i]*X[i] + 
\end_layout

\begin_layout Plain Layout

		(long long int)Y[i]*Y[i] + (long long int)Z[i]*Z[i];
\end_layout

\begin_layout Plain Layout

	sort(distanza, distanza + N);
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

int query(int D) {
\end_layout

\begin_layout Plain Layout

    return upper_bound(distanza, distanza + pianeti, 
\end_layout

\begin_layout Plain Layout

		(long long int)D*D) - distanza;
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

 
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Pur essendo composto sostanzialmente da 4 linee di codice ci sono una serie
 di aspetti interessanti che vale la pena notare:
\end_layout

\begin_layout Itemize
negli ultimi anni è stata inserita in alcune competizioni una 
\begin_inset Quotes eld
\end_inset

nuova
\begin_inset Quotes erd
\end_inset

 modalità di scrittura delle soluzioni, che prevede vengano forniti dei
 template (modelli) di soluzione, in cui il codice per l'acquisizione dell'input
 e la stampa dell'output siano già presenti e lo studente debba solo scrivere
 il codice dentro ad alcune funzioni, che verranno chiamate nel main, anch'esso
 già presente.
 Il vantaggio è che non bisogna preoccuparsi di input/output, con un certo
 risparmio di tempo ed evitando la possibilità di commettere errori banali,
 in cambio bisogna 
\begin_inset Quotes eld
\end_inset

adeguarsi
\begin_inset Quotes erd
\end_inset

 alle modalità pensate dagli autori del template per l'utilizzo delle funzioni.
 Premesso che comunque rimane la possibilità di scriversi il codice da zero,
 l'utilizzo del template è in effetti molto comodo e potrebbe diventare
 una modalità standard anche alle selezioni territoriali (lo è già ad esempio
 alle selezioni nazionali e nelle Olimpiadi di Informatica a squadre).
 Un'altra novità presente da qualche anno alle nazionali e che potrebbe
 arrivare alle territoriali, è la presenza esplicita nel testo di una serie
 di sottocasi, di difficoltà crescente, in cui viene garantito il guadagno
 di una serie di punti alla soluzione di tutti i casi di test dello specifico
 sottocaso
\begin_inset Foot
status open

\begin_layout Plain Layout
Per una discussione più approfondita si veda 
\begin_inset CommandInset ref
LatexCommand ref
reference "sub:Subtask-e-template"

\end_inset


\end_layout

\end_inset

.
\end_layout

\begin_layout Itemize
come si può vedere nel testo della soluzione è stato usato un tipo, il 
\emph on
long long int
\emph default
, che non appare nei problemi precedenti, di cui si era discusso brevemente
 solo nel paragrafo sulla ricorsione (si veda 
\begin_inset CommandInset ref
LatexCommand ref
reference "sec:Costo-ricorsione"

\end_inset

).
 Il problema in questo caso è dovuto al fatto che le coordinate possono
 assumere valori fino a 
\begin_inset Formula $2^{30}$
\end_inset

, il che, una volta che vengono elevate al quadrato per calcolare la distanza
 con il teorema di Pitagora, porta a dei valori massimi di 
\begin_inset Formula $2^{60}$
\end_inset

, che non possono essere memorizzati all'interno di un int normale senza
 una drammatica perdita di precisione (tutti i bit che si trovano oltre
 il 32-esimo bit vengono eliminati).
 S potrebbe pensare di risolvere il problema considerando che una volta
 applicata la radice quadrata il numero tornerà ad avere un valore compatibile
 con la memorizzazione all'interno di un numero intero a 32 bit, ma, riflettendo
 un attimo, ci si accorge che comunque la somma dei quadrati dovrà essere
 memorizzata da qualche parte prima di poter calcolare la radice quadrata,
 quindi in ogni caso bisogna passare dalla trasformazione in long long int.
 Questo viene fatto utilizzando il 
\emph on
casting
\emph default
, cioè scrivendo davanti al nome della variabile una coppia di parentesi
 tonde che contengono il tipo di dati che si intende utilizzare, in modo
 da dire al compilatore che tipo di operazione svolgere, in questo caso
 di usare interi a 64 bit.
 Un'altra soluzione che poteva venire in mente era quella di fare un casting
 verso il tipo double.
 Mentre questo tipo è adatto per memorizzare numeri grandi (tra 
\begin_inset Formula $10^{-308}$
\end_inset

 e 
\begin_inset Formula $10^{308}$
\end_inset

), la sua possibilità di rappresentare esattamente i numeri è limitata alla
 quantità di cifre della mantissa, e quindi potrebbe introdurre errori di
 approssimazione che renderebbero scorretto il risultato.
 Per chi fosse interessato al perchè i double non sono precisi come gli
 interi si rimanda alla 
\begin_inset CommandInset href
LatexCommand href
name "voce di wikipedia"
target "https://en.wikipedia.org/wiki/Double-precision_floating-point_format"

\end_inset

 (
\begin_inset Flex URL
status collapsed

\begin_layout Plain Layout

https://en.wikipedia.org/wiki/Double-precision_floating-point_format
\end_layout

\end_inset

)
\end_layout

\begin_layout Itemize
guardando il codice si può notare che in effetti, pur parlando del teorema
 di Pitagora per il calcolo della distanza, non compare la funzione sqrt,
 che in C viene utilizzata per ottenere il valore della radice quadrata
 di un numero.
 Siccome interessa solamente verificare se una certa quantità positiva è
 minore di un'altra, non è necessario calcolare davvero la radice quadrata,
 è sufficiente confrontare tra loro i quadrati delle distanze, evitando
 così l'operazione di estrazione della radice quadrata.
\end_layout

\begin_layout Itemize
infine nel codice sono state usate due funzioni della Libreria Standard
 del C++, 
\emph on
sort
\emph default
 e 
\emph on
upper_bound.
 
\emph default
Mentre la prima è già stata utilizzata in molti problemi e spiegata in 
\begin_inset CommandInset ref
LatexCommand ref
reference "sub:L'algoritmo-sort-C++"

\end_inset

, la seconda serve quando si ha la necessità di trovare, all'interno di
 un vettore ordinato, la posizione del primo numero che è maggiore del numero
 passato come parametro.
 Il costo di questa operazione è garantito essere logaritmico in media (si
 basa essenzialmente sulla ricerca binaria) ed è molto comoda perchè, a
 differenza della ricerca binaria, non cerca un numero all'interno di un
 vettore, ma il primo numero maggiore del numero cercato.
 I parametri passati sono tre: 
\end_layout

\begin_deeper
\begin_layout Itemize
un iteratore alla posizione del vettore dalla quale si intende partire:
 quando il vettore è un array standard del C e si vuole partire dalla prima
 posizione, allora basta inserire il nome dell'array, in questo caso 
\emph on
distanza
\end_layout

\begin_layout Itemize
un iteratore alla posizione finale dell'intervallo in cui si intende fare
 la ricerca: quando il vettore è un array standard del C basta sommare alla
 posizione di partenza la lunghezza dell'intervallo, in questo caso 
\emph on
pianeti
\emph default
 
\end_layout

\begin_layout Itemize
infine il terzo parametro è il valore con il quale si vuole fare il confronto,
 in questo caso D*D, poichè come detto in precedenza viene fatto un confronto
 con il quadrato della distanza
\end_layout

\begin_layout Standard
Il valore di ritorno non è una posizione in senso stretto, cioè un numero,
 ma un iteratore.
 Anche in questo caso, avendo usato un array standard, il valore di ritorno
 è sostanzialmente un indirizzo, per trasformarlo in un indice viene sottratto
 l'indirizzo di partenza dell'array, cioè 
\emph on
distanza
\emph default
.
 Esiste anche una funzione 
\emph on
lower_bound
\emph default
 che trova la posizione del primo valore non minore del valore passato come
 parametro.
\end_layout

\end_deeper
\end_body
\end_document
